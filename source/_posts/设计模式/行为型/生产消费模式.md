---
toc:
  enable: true
  number: false
  max_depth: 3
title: 生产消费模式
date: 2023-04-13 10:46:32
tags: 设计模式
categories: 设计模式
---

生产者和消费者是面向过程的编程模式

生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞

```cpp
struct Task {
  Task() {}
  std::function<void()> m_func;
  typedef shared_ptr<Task> ptr;
};

class SyncQueue {
private:
  size_t max_size;
  list<Task::ptr> tasks;
  mutex mt;
  condition_variable cv_notempty;
  condition_variable cv_notfull;
  atomic<bool> flag;

public:
  SyncQueue(size_t size) : max_size(size), flag(true) {}
  ~SyncQueue() {
    if (flag) {
      stop();
    }
  }

  void push(Task::ptr ptr) {
    unique_lock<mutex> ul(mt);
    cv_notfull.wait(ul, [this]() { return !this->flag || this->notfull(); });
    if (!flag)
      return;
    tasks.push_back(ptr);
    std::cout << "push task " << ptr << std::endl;
    cv_notempty.notify_one();
  }

  Task::ptr take() {
    unique_lock<mutex> ul(mt);
    cv_notempty.wait(ul, [this]() { return !this->flag || this->notempty(); });
    if (!flag)
      return nullptr;
    auto res = tasks.front();
    tasks.pop_front();
    std::cout << "take task " << res << std::endl;
    return res;
  }

  void stop() {
    {
      // 缩短临界区
private:
  bool notempty() { return !tasks.empty(); }
  bool notfull() { return tasks.size() < max_size; }
};

class ThreadPool {
private:
  list<thread> ths;
  SyncQueue q;
  atomic<bool> flag;

private:
  void exec(Task::ptr task) {
    if (!task)
      return;
    task->m_func();
    this_thread::sleep_for(chrono::seconds(1));
  }

  void run() {
    while (flag) {
      std::cout << "try to take task " << std::this_thread::get_id() << std::endl;
      auto task = q.take();
      exec(task);
    }
  }

public:
  ThreadPool() : q(200) {}
  ~ThreadPool() {}

  void start(int num) {
    flag = true;
    for (int i = 0; i < num; ++i) {
      ths.emplace_back(thread(&ThreadPool::run, this));
    }
  }

  template <typename F, typename... Args>
  auto add(F &&f, Args &&...args) -> std::future<decltype(f(args...))> {
    using retType = decltype(f(args...));
    auto task = make_shared<std::packaged_task<retType()>>(
        bind(std::forward<F>(f), std::forward<Args>(args)...));
    Task::ptr fPtr = make_shared<Task>();
    fPtr->m_func = [task]() { (*task)(); };
    q.push(fPtr);
    return task->get_future();
  }

  void stop() {
    q.stop();
    flag = false;
    for (auto &it : ths) {
      it.join();
    }
  }
};

```
