---
toc:
  enable: true
  number: false
  max_depth: 3
title: 类型自动推导
date: 2023-05-10 21:32:07
tags: cpp
categories: cpp
---

类型是一个编译期概念，运行时全变成了机器指令，所以类型推导是在编译期进行的

## auto

`auto` 只是一个占位符，用来充当变量类型，它根据出现的位置本着最简单的原则进行类型推导

- 如果初始化表达式是引用，则去除引用语义

```cpp
int a = 10;
int &b = a;

auto c = b;// c 的类型为 int 而非 int&（去除引用）
auto &d = b;  // 此时 c 的类型才为 int&
```

- 如果初始化表达式为 `const` 或 `volatile`，则除去 `const` 或 `volatile` 语义

```cpp
const int a1 = 10;
auto  b1= a1;  // b1 的类型为 int 而非 const int（去除 const）
const auto c1 = a1;  // 此时 c1 的类型为 const int
b1 = 100;//合法
c1 = 100;//非法
```

- 如果 `auto` 关键字带上 `&` 或 `*` 时，则不去除 `const` 或 `volatile` 语意

```cpp
const int a2 = 10;
auto &b2 = a2;  //因为 auto 带上 &，故不去除 const，b2 类型为 const int &
b2 = 10; //非法

void (Test::*const pmf)(const int) const;
auto e = pmf; // void (Test::*)(const int) const
```

- 初始化表达式为数组时，`auto` 关键字推导类型为指针；若表达式为数组且 `auto` 带上 `&`，则推导类型为数组类型

- 函数或者模板参数不能被声明为 `auto`

## 万能引用 auto&&

`const auto&&` 也是遵循 `auto` 最简单原则进行类型推导，而 `auto&&` 是一个特殊情况

`auto&&` 的特殊性在于它既可以推导左值引用，也可以推导右值引用，这都取决于表达式是左值还是右值

`auto&&` 接收函数返回的右值引用仍然是右值引用

```cpp
int f1();
int &f2();
int &&f3();

void Demo() {
  int a = 0;

  auto &&e1 = a; // a 是左值，所以推导 e1 是 int &
  auto &&e2 = 5; // 5 是右值，所以推导 e2 是 int &&
  auto &&e3 = e2; // e2 是 int && 类型，但右值引用本身是左值，所以推导 e3 是 int &
  auto &&ef1 = f1(); // 返回值是右值，所以推导 ef1 是 int &&，
  auto &&ef2 = f2(); // 返回左值引用，所以推导 ef2 是 int &

  auto &&ef3 = f3(); // 返回值是右值，所以推导 ef3 是 int &&
  auto &&e4 = std::move(a); // 返回值是右值，所以推导 e4 是 int &&
}
```