---
toc:
  enable: true
  number: false
  max_depth: 3
title: 继承
date: 2023-06-02 20:05:55
tags: cpp
categories: cpp
---

## 派生类的构造析构

派生类构造函数必须使用基类的构造函数

创建派生类对象时，程序先创建基类对象，意味着基类对象应当在程序进入派生类构造函数之前被创建，可以使用初始化列表完成这一工作

如果不调用基类构造函数，程序将使用默认的基类构造函数，所以除非要使用默认构造函数，否则应显示调用正确的基类构造函数

释放对象顺序与创建顺序相反，即先释放派生类析构函数，再自动调用基类的析构函数

## 类成员的访问权限

- `public` 成员：派生类和外部都可以直接访问

- `protected` 成员：派生类中可以直接访问，外部不能直接访问

- `private` 成员：派生类和对象都不能直接访问

## 公有派生

```cpp
class derivedClass : public baseClass {
};
```

- 基类 `public` 成员继承后还是 `public`

- 基类 `protected` 成员继承后还是 `protected`

- 基类 `private` 成员继承后还是 `private``

## 保护继承

```cpp
class derivedClass : protected baseClass {
};
```

- 基类 `public` 成员继承后是 `protected`

- 基类 `protected` 成员继承后还是 `protected`

- 基类 `private` 成员继承后还是 `private``

## 私有继承

使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，意味着基类方法不会成为派生类对象公有接口的一部分，但可以在派生类的成员函数中使用

- 基类 `public` 成员继承后是 `private`

- 基类 `protected` 成员继承后是 `private`

- 基类 `private` 成员继承后还是 `private``

## 抽象基类

使用纯虚函数提供未实现的函数，`virtual type Func(int , double b) const = 0`

当类声明中包含纯虚函数时，则不能创建类的对象，只能用作基类，即抽象基类

派生类必须覆写纯虚函数

## 多态公有继承

```cpp
class baseClass
{
public:
    baseClass(){};
    virtual void func();
};

class derivedClass : public baseClass
{
public:
    derivedClass(){};
    virtual void func();
};
```

同一个方法在派生类和基类中的行为不同，成为多态

实现多态的两种机制：

- 在派生类中重新定义基类的方法

- 使用 `virtual` 虚方法

使用指针或引用调用成员函数：

- 如果没有 `virtual` 关键字，程序将根据引用类型或指针类型选择方法

- 如果有 `virtual` 关键字，程序将根据引用或指针指向的对象的类型来选择方法（基类指针或引用可以指向派生类）
