---
toc:
  enable: true
  number: false
  max_depth: 3
title: 分布式事务
date: 2023-09-01 19:16:19
tags: 常见概念
categories: 常见概念
---

## CAP

CAP 理论可以说是分布式系统的基石，它说的是一个分布式系统最多只能同时满足一致性 Consistency、可用性 Availability 和分区容错性 Partition tolerance 这三项中的两项，而不能同时满足

- C 一致性，所有客户端看到都是同一份数据，即使在数据更新和删除之后

- A 可用性，即使部分节点发生故障，所有客户端也能找到可用的数据备份

- P 分区容错性，即使发生网络分区故障，系统仍然能够按照预期正常工作

在构建大型分布式系统的时候必须根据自己业务的独特性在三者之间进行权衡，但由于网络的各种不确定因素，所以往往不得不考虑分区容忍性，从而这个时候通常只能在一致性和可用性之间进行选择

## BASE

根据 CAP 定理，如果要完整的实现事务的 ACID 特性只能放弃可用性选择一致性

BASE 是根据 CAP 定理提出的一种 ACID 替代性方案，从而来达到可用性和一致性之间的某种微妙的平衡，选择 AP 模型的同时最大限度的满足一致性。核心思想是：强一致性 Strong consistency 无法得到保障时，可以根据业务自身的特点，采用适当的方式来达到最终一致性 Eventual consistency

- BA：Basically Available ，基本可用性

- S：Soft State，软状态

- E：Eventually Consistency，最终一致性

基本可用是相对 CAP 完全可用而言的，即在部分节点出现故障的时候不要求整个系统完全可用，允许系统出现部分功能和性能上的损失，比如增加响应时间，引导用户到一个降级提示页面等等

软状态则是相对 CAP 强一致性而言的，CAP 定理的一致性要求数据变化要立即反映到所有的节点副本上去，软状态不要求数据变化立即反映到所有的服务器节点上，允许存在一个中间状态进行过渡，比如允许放大延时等

最终一致性则是相对 CAP 强一致性而言的，它不要求系统数据始终保持一致的状态，只要求系统经过一段时间后最终会达到一致状态即可

## 强一致性方案

### 2PC 二阶段提交

当一个事务跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点的操作结果并最终指示这些节点是否要把操作结果进行真正的提交

二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作

- 第一阶段 voting phase 投票阶段：事务协调者给每个参与者发送 Prepare 消息，每个参与者要么直接返回失败，要么在本地执行事务，写本地的 redo 和 undo日 志，但不提交

- 第二阶段 commit phase 提交阶段：如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚消息，否则发送提交消息。参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源

2PC 协议能够成功保证一致性还需要一些其他前提条件：

- 必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息。两段式提交中投票阶段失败了可以补救回滚，而提交阶段失败了无法补救（不再改变提交或回滚的结果，只能等崩溃的节点重新恢复），因而此阶段耗时应尽可能短，尽量控制网络风险的考虑

- 必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。由于在准备阶段已经写入了完整的重做日志，所以当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作

缺点：

- 单点故障问题：协调者在两段提交中具有举足轻重的作用，协调者等待参与者回复时可以有超时机制，允许参与者宕机，但参与者等待协调者指令时无法做超时处理。一旦协调者宕机，所有参与者都会受到影响。如果协调者一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待

- 同步阻塞问题：执行过程中所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。也就是说从投票阶段到提交阶段完成这段时间，资源是被锁住的

- 数据一致性问题：当网络稳定性和宕机恢复能力的假设不成立时，两阶段提交可能会出现一致性问题

### 3PC 三阶段提交

三段式提交主要是解决两段式提交的单点故障问题、同步阻塞问题和数据一致性问题

- 第一阶段 CanCommit 阶段：协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应

- 第二阶段 PreCommit阶段：协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有两种：

1. 假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行

2. 假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断

- 第三阶段 doCommit 阶段：该阶段进行真正的事务提交，也可以分为以下两种情况

1. 针对第一种情况，协调者向各个参与者发起事务提交请求

2. 协调者没有接收到参与者发送的 ACK 响应，那么就会执行中断事务

3PC 可以解决单点故障问题并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后会默认执行 commit，而不会一直持有事务资源并处于阻塞状态

3PC 对于数据一致性问题并未有任何改进，比如在进入 PreCommit 阶段后，如果协调者发送的是 abort 指令，而此时由于网络问题，有部分参与者在等待超时后仍未收到 abort 指令的话，那这些参与者就会执行 commit，这样就产生了不同参与者之间数据不一致的问题

由于 3PC 非常难实现，目前市面上主流的分布式事务解决方案都是 2PC 协议

## 最终一致性方案

在互联网应用中，为了提升性能和可用性，基于 BASE 理论使用最终一致性来替代强一致性，也就是通过牺牲部分一致性来换取性能和可用性的提升

### 本地事务状态表

1. 在调用方请求外部系统前将待执行的事务流程及其状态信息存储到 db 中，依赖数据库本地事务的原子特性保证本地事务和调用外部系统事务的一致性，这个存储事务执行状态信息的表称为本地事务状态表

2. 在将事务状态信息存储到 DB 后，调用方才会开始继续后面流程，同步调用外部系统，并且每次调用成功后会更新相应的子事务状态，某一步失败时则中止执行

3. 同时在后台运行一个定时任务，定期扫描事务状态表中未完成的子事务，并重新发起调用，或者执行回滚，或者在失败重试指定次数后触发告警让人工介入进行修复

{% asset_img 01.png %}

### 可靠消息队列

可靠消息队列方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方（消息消费者）一定能够接收到消息并处理事务成功，此方案强调的是只要消息发给事务参与方，则最终事务要达到一致

可靠消息最终一致性方案要解决以下几个问题：

- 本地事务与消息发送的原子性问题：要求事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息

- 事务参与方接收消息的可靠性：要求事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息

- 消息重复消费的问题：解决消息重复消费的问题就要实现事务参与方的方法幂等性

#### 本地消息表

如果是使用不支持事务消息的消息中间件，参与事务的系统需要在给消息中间件发送消息之前，把消息的信息和状态存储到本地的消息表中

{% asset_img 02.png %}

1. 参与分布式事务的系统接收到请求后，在执行本地事务的同时把将待发送的消息记录到事务消息表中，将业务表和消息表放在一个数据库事务里，保证两者的原子性

2. 执行完后系统不直接给消息中间件发消息，而是通过后台定时任务扫描消息表将消息 push 到消息中间件，对于 push 失败的消息则会不断重试，直到消息中间件成功返回 ack 消息，并更细消息表中投递状态，从而保证消息的不丢失

3. 消息中间件收到消息后，会将消息投递给订阅消息的外部系统，外部系统收到消息后执行本地事务，只有成功才应答 Ack 消息，消息中间件只有在收到 Ack 消息后才将该条消息丢弃，否则会不断的重复发送直到成功，所以事务的所有参与者需要自行保证事务执行的幂等性

#### 事务消息

如果是支持事务操作的消息中间件，本地消息表的定时任务的工作将交给消息中间件来提供

{% asset_img 03.png %}

消息中间件如果收到 comfirm 消息，则会将消息转为对消费者可见，并开始投递

如果收到 rollback 消息，则会删除之前的事务消息

如果未收到确认消息，则会通过事务回查机制定时检查本地事务的状态，决定是否可以提交投递

### 最大努力通知

最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果

业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失

业务活动的被动方，根据定时策略，向业务活动主动方查询，恢复丢失的业务消息

### TCC

TCC（Try-Confirm-Cancel）方案天生适用于需要强隔离性的分布式事务中，它是一种业务侵入性较强的事务方案，要求业务处理过程必须拆分为预留业务资源和确认/释放消费资源两个子过程

- Try：尝试执行阶段，完成所有业务可执行性的检查，保障一致性，并且预留好事务需要用到的所有业务资源

- Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此需要满足幂等性

- Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段也可能会重复执行，因此也需要满足幂等性

不同于 2PC 第一阶段的 Prepare，TCC 在 Try 阶段主要是对资源的预留操作这类的轻量级操作，比如冻结部分库存数量，它不需要像 2PC 在第二阶段完成之后才释放整个资源，也就是它不需要等待整个事务完成后才进行提交，这时其它用户的购买操作可以继续正常进行，因此它的阻塞范围小时间短暂，性能上比 2PC 方案要有很大的提升

TCC 是位于用户代码层面，而不是在基础设施层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力

TCC 要求所有的事务参与方都必须要提供三个操作接口：Try/Confirm/Cancel，带来了更高的开发成本和业务侵入性，意味着有更高的开发成本和更换事务实现方案的替换成本

## 弱一致性方案

弱一致性是指数据更新后，容忍后续只能访问到部分或者全部访问不到，并且不会对业务产生重大影响

### 基于状态的补偿

根据实际的业务场景对立面的数据重要性进行划分，放弃传统的全局数据一致，允许部分不重要的数据出现不一致，但不会对业务产生重大影响

比如在电商网站购物场景中，其中两个主要的步骤是创建订单和扣库存，这分别由订单服务和库存服务进行处理

- 如果采用前面可靠消息队列方案，创建订单的消息通知库存服务扣除库存，由于异步消息的延迟则会导致超卖

- 如果采用 TCC 的方案，每次请求操作都需要 Try、Confirm 两次请求调用，性能又不能达标

- 如果采用本地事务状态表，则需要对海量的事务进行状态更新操作，性能和延迟也同样会是个问题

但是可以依据实际的电商购物场景进行取舍：允许少卖，但不能超卖。于是可以先扣库存，库存扣减成功后才创建订单并关联库存，若扣库存失败则不创建订单。事后通过库存流水进行状态补偿，对未关联的订单进行撤销