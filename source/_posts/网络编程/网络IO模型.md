---
toc:
  enable: true
  number: false
  max_depth: 3
title: 网络 IO 模型
date: 2023-04-26 20:44:08
tags: 网络编程
categories: 网络编程
---

一次完整的 IO 是指用户空间的进程数据与内核空间的内核报文数据的完整交换。由于用户空间和内核空间在系统中是严格隔离的，所以其数据交换过程中不能由用户空间的进程直接读写内核空间的数据，而是需要经历一次从内核空间拷贝到用户空间的行为

## 输入操作的两个阶段

1. 等待数据从网络中到达

2. 当所等待数据到达时，它被存放在内核中的某个缓冲区，所以还需把数据从内核缓冲区复制到应用进程的缓冲区

`read`、`readv`、`recv`、`recvfrom`、`recvmsg` 等作用于非阻塞 fd 时在第一阶段返回异常，第二阶段阻塞

`accept` 与输入操作类似

## 输出操作的两个阶段

1. 将应用进程缓冲区中的数据拷贝至内核缓冲区

2. 内核将内核缓冲区中的数据发送出去

`write`、`writev`、`send`、`sendto`、`sendmsg` 等作用于阻塞 fd 且当内核可用的发送缓冲区小于待发送数据时会阻塞

`write`、`writev`、`send`、`sendto`、`sendmsg` 等作用于非阻塞 fd 且当内核可用的发送缓冲区小于待发送数据时会返回异常

`connect` 与输出操作类似

## 同步阻塞 IO

应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回

{% asset_img 01.png %}

进程在 `recv` 时大概率会阻塞，所以会发生一次进程切换；当数据到达网卡并复制到内核空间时，进程被唤醒从而发生第二次进程切换

同步阻塞 IO 的一次数据到达会发生两次进程切换，一次数据读取会发生两处阻塞

## 同步非阻塞 IO

应用进程执行系统调用之后，内核返回一个错误码后应用进程可以继续执行，但是需要以轮询的方式不断的执行系统调用来获知 IO 是否完成

因为应用进程在数据没有到达之前会不停查询，使 CPU 要处理更多的系统调用

{% asset_img 02.png %}

非阻塞 IO 不被推荐，虽然该方式能够在等待数据的时间里干其他活，但轮询将推高 CPU 占用，同时任务完成的响应延迟也将增大，降低整体数据吞吐量

同步非阻塞 IO 仍会有两次进程切换，但只有一次阻塞

## IO 复用

在同步非阻塞 IO 中，`recv()` 更多的是起到检测的作用，而操作系统提供了更为高效的检测操作是否完成接口，同时接口可以一次检测多个连接是否可读、可写

IO 复用让单个线程具有处理多个 IO 事件的能力

如果一个 Web 服务器没有 IO 复用，那么每一个 socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，IO 复用不需要进程线程创建和切换的开销，系统开销更小

{% asset_img 03.png %}

IO 复用的优势在于能处理更多的连接，如果处理的连接数不是很高的话，使用 IO 复用不一定比使用多线程阻塞 IO 性能更好，可能延迟更高，因为使用了两个系统调用

## 信号驱动 IO

应用进程使用 `sigaction` 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的

内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 `recvfrom` 将数据从内核复制到应用进程中

{% asset_img 04.png %}

## 异步 IO

进程执行 `aio_read` 系统调用会立即返回，进程可以继续执行不会被阻塞，内核会在所有操作完成之后向应用进程发送信号

异步 IO 与信号驱动 IO 的区别在于，异步 IO 的信号是通知应用进程 IO 完成，而信号驱动 IO 的信号是通知应用进程可以开始 IO

{% asset_img 05.png %}

## IO 模型比较

- 同步 IO：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞

- 异步 IO：第二阶段应用进程不会阻塞

同步 IO 包括阻塞式 IO、非阻塞式 IO、IO 复用和信号驱动 IO ，它们的主要区别在第一个阶段

非阻塞式 IO 、信号驱动 IO 和异步 IO 在第一阶段不会阻塞

{% asset_img 06.png %}