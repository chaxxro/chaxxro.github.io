---
toc:
  enable: true
  number: false
  max_depth: 3
title: 有权图最短路径算法
date: 2023-12-28 11:44:12
tags: algorithm
categories: algorithm
---

图结构中一个显而易见的定理：最短路径的子路径仍然是最短路径

对于有权图，如果权边有负数，则分两种情况：

1. 如果从某点出发，可以到达一个权值和为负数的环，那么这个点到其他点的最短距离就是负无穷了

2. 如果说不存在一个这样的负环，那么就和没有负权边一样了

## Floyd 算法

Floyd 算法一种基于动态规划的多源最短路算法，只能在不存在负权环的情况下使用，因为其并不能判断负权环

定义状态：`f[k][i][j]` 为经过前 k 个节点，从 i 到 j 所能得到的最短路径，可以从 `f[k - 1][i][j]` 转移过来（即不经过第 k 个节点）；也可以从 `f[k - 1][i][k] + f[k - 1][k][j]` 转移过来，即经过第 k 个节点；

状态转移方程：`f[k][i][j] = min(f[k-1][i][j], f[k-1][i][k] + f[k-1][k][j]) `，降维后为：`f[i][j] = min(f[i][j], f[i][k] + f[k][j]) `

```cpp
// 初始化为一个比较大的值
vector<vector<int>> graph(n, vector<int>(n, INT_MAX / 2));  
initGraph(graph);  // 给图中的边赋值

for(int k = 0; k < n; ++k) {
	for(int i = 0; i < n; ++i) {
		for(int j = 0; j < n; ++j) {
			graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
		}
	}
}

/*
// 记录路径
vector<vector<int>> path(n, vector<int>(n, -1));
for(int k = 0; k < n; ++k) {
	for(int i = 0; i < n; ++i) {
		for(int j = 0; j < n; ++j) {
			if(graph[i][j] > graph[i][k] + graph[k][j]) {
				graph[i][j] = graph[i][k] + graph[k][j];
				path[i][j] = k;
			}
		}
	}
}

function<string(int, int)> helper = [&](int i, int j)->string {
	if(path[i][j] == -1) {
		return to_string(i) + " -> " + to_string(j);
	}
	else {
		int k = path[i][j];
		return helper(i, k) + " -> " + helper(k, j);
	}
};
*/
```

维护路径矩阵使得空间复杂度达到了 O(n^2)，时间复杂度达到了 O(n^3)

## Dijkstra 算法

Dijkstra 算法适用于求单源最短路径，主要特点是以起始点为中心向外层层拓展（广度优先搜索思想），直到拓展到终点为止，要求图中的边全部非负

维护两个点集 A，B，A 点集代表已经求出源点到该点的最短路的点的集合，B 代表未求出源点到该点的最短路径的点的集合。维护一个向量 d，d[i] 代表源点到点 i 的最短路径长度；不断进行以下操作：找出点集 B 中 d[i] i∈B 最小的点，这个点为进入点集A的候选节点，然后通过该点松弛点集 B 中其他的点，更新向量 d，然后将该候选点放入点集 A，直到点集 B 为空

```cpp
vector<vector<int>> graph(n, vector<int>(n, INT_MAX));

int dijkstra(int start, int end) {
	vector<int> dist(n, INT_MAX / 2);
	unordered_set<int> A, B;
	A.insert(start);
	for (int i = 0; i < n; ++i) {
		dist[i] = (i == start ? 0 : graph[start][i]);
		if (i != start) B.insert(i);
	}

	// 在 B 中找 dist 里最小的值加入 A
	while (B.size()) {
		int pos = 0;
		int INF = INT_MAX;
		for (int i = 0; i < n; ++i) {
			if (B.count(i) && dist[i] < INF) {
				pos = i;
				INF = dist[i];
			}
		}
		B.erase(pos);
		A.insert(pos);
		for (int i = 0; i < n; ++i) {
			if (B.count(i)) {
				dist[i] = min(dist[i], dist[pos] + graph[pos][i]);
			}
		}
	}
	return dist[end];
}
```

算法的时间复杂度为 O(n^2)，若通过这个算法求所有的点的最短路，即调用 n 次，那么算法复杂度为 O(n^3)；对于集合 B 可使用优先队列进行优化，时间复杂度为 O(nlogn)

```cpp
int dijkstra(int start, int end) {
	vector<int> dist(n, INT_MAX / 2);
	vector<pair<int, int>> B;
	vector<int> path(n, start);  // 存储前驱节点
	for (int i = 0; i < n; ++i) {
		dist[i] = (i == start ? 0 : roads[start][i]);
		if (i != start) B.emplace_back(make_pair(dist[i], i));
	}
	make_heap(B.begin(), B.end(), greater<pair<int, int>>());

	// 在 B 中找 dist 里最小的值加入 A
	while (B.size()) {
		// 取出最小值
		pop_heap(B.begin(), B.end());
		auto pos = B.back();
		B.pop_back();
		
		// 更新
		for (int i = 0; i < B.size(); ++i) {			
			if (dist[B[i].second] > dist[pos.second] + roads[pos.second][B[i].second]) {
				dist[B[i].second] = dist[pos.second] + roads[pos.second][B[i].second];
				path[B[i].second] = pos.second;
			}
			B[i].first = dist[B[i].second];
		}
		make_heap(B.begin(), B.end(), greater<pair<int, int>>());
	}
	function<void(int, int)> print = [&](int s, int e) {
		if(s == e) return;
		print(s, path[e]);
		cout << s << " -> " << path[e];
	};
	print(start, end);
	return dist[end];
}
```

## Bellman-Ford 算法

用于计算出起点到各个节点的最短距离，支持存在负权重的情况

与 Dijkstra 最大的不同是每次都是从源点 s 重新出发进行松弛更新操作，而 Dijkstra 则是从源点出发向外扩逐个处理相邻的节点，不会去重复处理节点

流程：

1. 初始化时将起点 s 到各个顶点 v 的距离 dist(s->v) 赋值为无穷大，dist(s->s) 赋值为 0

2. 后续进行最多 n-1 次遍历操作，对所有的边进行松弛操作，因为在一个含有 n 个顶点的图中，任意两点之间的最短路径最多包含 n-1 边；第 i 轮在对所有边进行松弛后，得到的是源点最多经过 i 条边到达其他顶点的最短距离

3. 遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，则说明存在负环路

```cpp
vector<vector<int>> g(n, vector<int>(n, INT_MAX));
vector<int> dist(n, INT_MAX / 2);
InitGraph(g);

for(int i = 1; i < n; ++i) {
	for(int j = 0; j < n ; ++j) {
		for(int k = 0; k < n; ++k) {
			// 因为只是求最短路径，所以可以使用本次最外层循环更新过的数据
			dist[k] = min(dist[k], dist[j] + g[j][k]);
			// 如果有要求最多经过几条边，则不能使用本次最外层循环更新过的数据
		}
	}
}

bool loop = false;
for(int j = 0; j < n ; ++j) {
	for(int k = 0; k < n; ++k) {
		if(dist[k] < dist[j] + g[j][k]) {
			loop = true;  // 有负环
		}
	}
}
```