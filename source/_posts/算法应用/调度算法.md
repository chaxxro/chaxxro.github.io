---
toc:
  enable: true
  number: false
  max_depth: 3
title: 调度算法
date: 2023-08-17 14:43:24
tags: 算法应用
categories: 算法应用
---

## 轮询

轮询即将请求依次分配到各个服务节点，从第一个节点开始，依次将请求分配到最后一个节点，而后重新开始下一轮循环，最终所有的请求会均摊分配在每个节点上

假设每个请求的消耗是一样的，那么轮询调度是最平衡的调度算法

## 加权轮询

有些时候服务节点的性能配置各不相同，处理能力不一样。针对这种的情况，可以采用加权轮询的方式进行调度，根据节点处理能力的强弱配置不同的的权重值

1. 当有请求需要调度时，每次分配选择当前权重最高的节点，同时被选择的节点权重值减一

2. 若所有节点权重值都为零，则重置为初始化时配置的权重值

加权轮询算法比较容易造成某个服务节点短时间内被集中调用，导致瞬时压力过大

## 平滑权重轮询

针对加权轮询存在的瞬时压力大的情况，平滑权重轮询实现了基于权重的平滑轮询算法

在一段时间内，不仅服务节点被选择次数的分布和它们的权重一致，而且调度算法还能比较均匀的选择节点，不会在一段时间之内集中只选择某一个权重较高的服务节点

1. 初始状态时初始化配置权重 weight，然后给每个服务器加 1 个动态的当前权重 curWeight，默认为 0

2. 请求进来时 curWeight += weight，然后从 curWeight 中挑选最大的

3. curWeight -= sum(weight)

## 随机

每次将请求随机地分配到服务节点上，优点是完全无状态的调度，调度节点不需要记录过往请求分配情况的数据

理论上在请求量足够大的情况下，随机算法会趋近于完全平衡的负载均衡调度算法

## 加权随机

服务节点权重越大，随机到的概率就越大。最终所有请求分配到各服务节点的数量与节点配置的权重值成正比关系

## 最小负载

实际应用中，不同的请求对服务器的消耗各不相同，无论是使用轮询还是随机的方式，都可能无法准确的做到完全的负载均衡

最小负载算法是根据各服务节点当前的真实负载能力进行请求分配的，当前负载最小的节点会被优先选择

1. 服务节点定时向调度节点上报各自的负载情况，调度节点更新并记录所有服务节点的当前负载值

2. 当有请求需要调度时，每次分配选择当前负载最小的服务节点

## 两次随机选择

最小负载算法可以在请求对服务消耗相同时做到更好的均衡性，但一般情况下服务节点的负载数据都是定时同步到调度节点，存在一定的滞后性，而使用滞后的负载数据进行调度会导致产生群居行为。请求将批量地发送到当前某个低负载的节点，而当下一次同步更新负载数据时，该节点又有可能处于较高位置，然后不会被分配任何请求。再下一次又变成低负载节点被分配了更多的请求，一直处于这种很忙和很闲的循环状态，不利于服务器的稳定

1. 服务节点定时向调度节点上报各自的负载情况，调度节点更新并记录所有服务节点的当前负载值

2. 从所有可用节点列表中做两次随机选择操作，得到两个节点

3. 比较这两个节点负载情况，选择负载更低的节点作为被调度的节点

## 一致性哈希

为了保序和充分利用缓存，会希望相同请求 key 的请求总是会被分配到同一个服务节点上，以保持请求的一致性，从而有了一致性哈希的调度方式

### 划段法

事先规划好资源段，然后根据请求的 key 映射找到所属段，但这种方式存在很大的应用局限性，对于平衡性和稳定性也都不太理想

### 割环法

割环法本质上是一种取模算法，不过不是按数量取模，而是对固定值 2^32 取模

IPv4 的地址是 4 组 8 位 2 进制数组成，所以用 2^32 可以保证每个 IP 地址会有唯一的映射

1. 将 2^32 看成一个圆环，由 2^32 个点组成

2. 对服务器 IP 进行哈希运算后对 2^32 取模，将服务器映射到环上的一个点

3. 对 key 进行哈希运算后对 2^32 取模得到环上对应的点位，如果该点位没有相应的服务器则顺时针在环上找服务器

在实际场景中很难选取到一个哈希函数能够完美地将各个服务器散列到环上，从而在服务器节点数量太少的情况下，很容易因为节点分布不均匀而造成数据倾斜问题

针对数据倾斜问题，可以将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上。如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器

虚拟节点的哈希计算通常可以采用对应节点的 IP 地址加数字编号后缀的方式，如 10.24.23.227#1 的方式

引入虚拟节点的同时也增加了新的问题，要做虚拟节点和真实节点间的映射
