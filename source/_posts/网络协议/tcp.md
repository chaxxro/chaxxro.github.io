---
toc:
  enable: true
  number: false
  max_depth: 3
title: tcp
date: 2023-04-26 19:43:07
tags: 网络协议
categories: 网络协议
---

TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的

{% asset_img 01.png %}

TCP 数据包和 UDP 一样，都是由首部和数据两部分组成，唯一不同的是，TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割

{% asset_img 02.png %}

TCP 负责应用软件和网络软件之间的通信：IP 负责计算机之间的通信；TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们；IP 负责将包发送至接受者

- 32 位序列号：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401

- 32 位确认号：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701

- 4 位首部长度：数据部分距离报文段起始处的偏移量，实际上指的是首部的长度

- 源端口号/目的端口号: 表示数据从哪个进程来, 到哪个进程去

- 16 位窗口大小：作为接收方让发送方设置其发送窗口的依据

- 6 位标志域：紧急标志 URG (1 表示有效)、有意义的应答标志 ACK （1 时确认号字段有效，否则无效，在连接建立后所有传送的报文段都必须把 ACK 置 1）、推 PSH （1 时表示接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理）、重置连接标志 RST 、同步序列号标志 SYN (仅在三次握手建立 TCP 连接时有效，当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1)、完成发送数据标志 FIN (1 表示此报文段的发送方的数据已发送完毕，并要求释放连接)

- TCP 校验和会覆盖首部和数据

## TCP 三次握手

建立一个 TCP 连接时，需要客户端和服务端总共发送 3 个包以确认连接的建立，在 socket 编程中，这一过程由客户端执行 connect 来触发

{% asset_img 03.png %}

- 第一次：客户端 - - > 服务器。此时服务器知道了客户端要建立连接了  Client 将标志位 SYN 置为 1，随机产生一个值 seq = J，并将该数据包发送给 Server，Client 进入 SYN_SENT 状态，等待 Server 确认

- 第二次：客户端 < - - 服务器。此时客户端知道服务器收到连接请求了 Server 收到数据包后由标志位 SYN = 1 知道 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack = J + 1，随机产生一个值 seq=K ，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN_RCVD 状态

- 第三次：客户端 - - > 服务器。此时服务器知道客户端收到了自己的回应 Client 收到确认后，检查 ack 是否为 J + 1 ，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack = K + 1，并将该数据包发送给 Server，Server 检查 ack 是否为 K + 1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态

## 为什么不两次握手

### 避免历史连接

客户端发送的连接请求如果在网络中滞留，服务器则不会及时收到并响应连接请求

客户端等待一个超时重传时间之后就会重新请求连接，但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接

因为有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接

### 同步双方信息

确保双方的初始序列号、窗口大小和最大数据段能被可靠的同步，保证 TCP 的可靠性

## SYN 攻击

Server 发送 SYN-ACK 之后，收到 Client 的 ACK 之前的 TCP 连接称为半连接

SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 回复确认包，并等待 Client 的确认

由于源地址是不存在的，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将产时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪

目前 Linux 下默认会进行 5 次重发 SYN-ACK 包，重试的间隔时间从 1s 开始，下次的重试间隔时间是前一次的两倍

## 半连接队列和全连接队列

在 TCP 三次握手的时候，Linux 内核会维护两个队列：

- 半连接队列，也称 syn 队列

- 全连接队列，也称 accepet 队列

服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来

{% asset_img 04.png %}

syn 队列长度 = max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)

accept 队列长度 = min(backlog, /proc/sys/net/core/somaxconn)

syn 队列满时，会丢弃新的 SYN 报文

accept 队列满时，其行为取决于 /proc/sys/net/ipv4/tcp_abort_on_overflow 值

- 0，将该连接还原成 SYN_RECV 状态，造成 ACK 报文缺失的假象，等待客户端重发

- 1，向客户端发送 RST 复位报文，告诉客户端连接已经建立失败

## 初始 SYN 号是随机值

源 IP 可以伪造，所以序列号要随机，使得伪造的随机值不在合法范围内，而被接收方丢弃，增加安全性

## accept 与三次握手

客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后

## TCP 四次挥手

断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开

在 socket 编程中，这一过程由客户端或服务端任一方执行 `close` 来触发

由于 TCP 连接是全双工的，因此每个方向都必须要单独进行关闭：

- 发送一个 FIN 来终止这一方向的连接

- 收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN

{% asset_img 05.png %}

1. 客户端发出连接释放报文并且停止发送数据，客户端进入 FIN-WAIT-1 状态，此时客户端已经没有数据要发送了

2. 服务器收到连接释放报文后发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，服务端就进入了 CLOSE-WAIT 半关闭状态。此时服务器若发送数据，客户端依然要接受

3. 客户端收到服务器的确认请求后，客户端就进入 FIN-WAIT-2 状态，等待服务器发送连接释放报文

4. 服务器将最后的数据发送完毕后，向客户端发送连接释放报文，FIN = 1，ack = u + 1，服务器就进入了 LAST-ACK 状态，等待客户端的确认

5. 客户端收到服务器的连接释放报文后发出确认，ACK = 1，ack = w + 1，seq = u + 1，客户端进入 TIME-WAIT 状态。此时 TCP 连接还没有释放，客户端必须经过 2 * MSL 的时间后，才进入 CLOSED 状态

6. 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态

## 客户端最后需要等待 2 * MSL 的时间

- 保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失。站在服务器的角度看来，我已经发送了 FIN + ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2 MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2 MSL 计时器

- 客户端发送完最后一个确认报文后，在这个 2 * MSL 时间中，可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新的连接中不会出现旧连接的请求报文

## 为什么四次挥手

建立连接时，服务器在 LISTEN 状态下收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端

关闭连接时，服务器收到对方的 FIN 报文仅仅表示对方不再发送数据了，但服务器可能还有数据要发送给对方，所以需要等服务发送完全部数据后再发送 FIN 报文给对方来表示同意关闭连接

因此服务端的 ACK 和 FIN 一般会分开发送，从而导致多了一次挥手

## 建立连接后客户端突发故障

TCP 的连接实际上是一种纯软件层面的概念，在物理层面并没有连接这种概念

在软件层面上，连接的一方并不知道另一方的情况，它会一直维护这个连接

在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，这些连接得不到正常释放，从而造成端系统资源的消耗和浪费

## 系统中过多 TIME_WAIT 状态连接

高并发可以让服务器在短时间范围内同时占用大量端口，短连接处理完业务

服务处理完请求后会主动释放连接，所以用过的端口会停留在 TIME_WAIT 状态几分钟，而这几分钟，其他请求来临的时候是无法占用此端口的

解决方案：

- 使用长连接，如果是 http，可以使用 keepalive

- 修改内核参数，提高 TIME_WAIT 连接状态的上限

- 启动快速回收机制，但 NAT 网络下可能会出现问题

- 开启重用机制，允许将 TIME-WAIT socket 重新用于新的 TCP 连接

- 由客户端来发起关闭连接请求

现代 Linux 系统针对连接复用进行了一些优化：

- 新连接 SYN 告知的初始序列号，一定比 TIME_WAIT 老连接的序列号大，这样通过序列号就可以区别出新老连接

- 新连接的时间戳比老连接的时间戳大，这样通过时间戳也可以区别出新老连接

## TIME_WAIT 相关参数

- `tcp_tw_reuse` 的内核配置选项：主要用在连接的发起方，TIME_WAIT 状态的连接创建时间超过 1 秒后，新的连接才可以被复用；`tcp_tw_reuse` 是为了缩短 time_wait 的时间，避免出现大量的 time_wait 链接而占用系统资源，解决的是 `accept` 后的问题

- `SO_REUSEADDR` 是用户态的选项，`SO_REUSEADDR` 选项用来告诉操作系统内核，如果端口已被占用，但是 TCP 连接状态位于 TIME_WAIT ，可以重用端口，这里一般都是连接的服务方；`SO_REUSEADDR` 是为了解决 time_wait 状态带来的端口占用问题，以及支持同一个 port 对应多个 ip，解决的是 `bind` 时的问题

## KEEP-ALIVE

TCP 有一个保持活跃的机制叫做 Keep-Alive，它由一个计时器组成

- 对端程序是正常工作的，当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来

- 对端程序崩溃并重启，当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置

- 对端程序崩溃，或对端由于其他原因导致报文不可达，当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡

TCP 保活机制默认是关闭的，因为早期的网络带宽非常有限，如果提供一个频率很高的保活机制，对有限的带宽是一个比较严重的浪费

在 Linux 系统中，保活时间、保活时间间隔和保活探测次数分别对应 sysctl 变量 net.ipv4.tcp_keepalive_time、net.ipv4.tcp_keepalive_intvl、 net.ipv4.tcp_keepalve_probes，默认设置是 7200 秒、75 秒和 9 次探测

可以通过在应用程序中模拟 TCP Keep-Alive 机制，来完成在应用层的连接探活

## MSL

MSL 是任何 IP 数据报能够在因特网中存活的最长时间

每个数据报里都包含有一个被称为 TTL（time to live）的 8 位字段，它的最大值为 255

这个生存时间由源主机设置初始值，它表示的是一个 IP 数据报可以经过的最大跳跃数，每经过一个路由器，就相当于经过了一跳，它的值就减 1，当此值减为 0 时，则所在的路由器会将其丢弃，同时发送 ICMP 报文通知源主机

## 最大报文长度 MSS

MSS 与接收窗口无关

较小 MSS 对网络利用率较低，较大 MSS 则可能在 IP 层分解成多个数据报，这样不仅需要在接收端重新装配报文，而且如果出错还会重传使得增大开销，因此 MSS 要在 IP 层不分片的情况下尽可能大

TCP 在三次握手建立连接过程中，会在 SYN 报文中使用 MSS（Maximum Segment Size）选项功能，协商交互双方能够接收的最大段长 MSS 值，交互双方会以双方通告的 MSS 值中取最小值作为发送报文的最大段长

MSS = MTU - 20 字节 TCP 报头 - 20 字节 IP 报头，那么在以太网环境下 MSS 值一般就是 1500 - 20 - 20 = 1460 字节

## 延迟确认应答机制

TCP 在发送 ACK 的时候为了合并 ACK 从而降低网络流量，会有以下机制：

1. 内核会启动一个定时器每隔 200ms 检查一次是否应答

2. 当有数据发送的时候，ACK 会随着数据一块发送

3. 如果没有数据发送，ACK 会在定时器到期后进行应答

Nagle 算法和延时确认组合在一起，增大了处理时延

## 超时重传机制

为解决数据包丢失、确认应答丢失的问题，在发送数据时协议栈会创建一个定时器，当超过指定的时间后还没有收到对方的 ACK 确认应答报文，就会重发未确认的数据

超时时间需要根据网络延迟进行动态调整，延迟越大超时时间越长

RTT（Round Trip Time）：往返时延，也就是数据包从发出去到收到对应 ACK 的时间。RTT 是针对连接的，每一个连接都有各自独立的 RTT

RTO（Retransmission Time Out）：重传超时时间

RTO 根据网络中的 RTT 来自适应调整，往往大于两倍的 RTT

超时往往意味着拥塞，一旦发生超时 TCP 不仅会重传对应数据段，还会降低当前的数据发送速率

## 快速重传机制

快速重传不以时间为驱动，而是以数据驱动的重传机制

当连续收到三个相同的 ACK 报文时，说明网络状况较好，所以可以在超时重传定时器过期之前重传丢失的报文段

## SACK 选择确认机制

当只丢失了部分数据包时，协议栈难以决定是重传之前的部分还是重传全部，因为发送端不知道丢失了哪些包

接收端可以通过 SACK 告诉发送端缺失包的序列号

SACK 是TCP 的扩展选项，它在 TCP 里加一个 SACK 字段

SACK 需要双方都支持，在 Linux下，可以通过 tcp_sack 参数打开这个功能

D-SACK 是 SACK 的扩展，使用了 SACK 来告诉发送方有哪些数据被重复接收了

## 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流

发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小

{% asset_img 06.png %}

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收

如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态

接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口

{% asset_img 07.png %}

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收

{% asset_img 08.png %}

## 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据

## 拥塞控制

由于 TCP 看不到网络状况，所以拥塞控制是必须的并且需要采用试探性的方式来控制拥塞

如果网络出现拥塞，发送方的重传会导致网络拥塞程度更高，因此需要控制发送方的速率

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复

发送方维护一个叫做拥塞窗口 cwnd 的状态变量，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口

### 慢开始

发送时最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段

当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

### 拥塞避免

cwnd 加倍递增，导致增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高

协议栈设置了一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每次只将 cwnd 加 1，如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始

### 快重传

接收方在收到一个失序的报文段后就立即发出重复确认，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期

{% asset_img 09.png %}

### 快恢复

快重传是因为丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，直接进入拥塞避免

{% asset_img 10.png %}

慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh

## TCP 粘包和拆包

UDP 是基于报文发送的，并不对数据进行拆分合并，且 UDP 首部有指示 UDP 报文长度，所以没有粘包的问题

TCP 是基于字节流的，没有把数据块区分边界，仅仅是一连串没有结构的字节流，且 TCP 首部并没有指示数据长度，所以 TCP 有粘包问题

当 client 向 server 连续发送两个数据：

- 分别收到两个数据

- 只收到一个包含两个数据的数据包，server 不知道这两个数据包的界限，即粘包现象

- server 收到两个数据，但这两个数据要么不完整要么多出一部分，即发生了粘包和拆包

### 为什么会粘包

- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包

- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包

### 为什么会拆包

- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包

- 待发送数据大于最大报文长度，TCP 在传输前将进行拆包

### 粘包、拆包解决方案

由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决

- 消息定长：发送端将每个数据包封装为固定长度，这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来

- 设置消息边界：服务端从网络流中按消息边界分离出消息内容

- 将消息分为消息头和消息体：消息头中包含表示消息总长度的字段

## TCP 保证可靠性

TCP 发送的报文是交给 IP 层的，但 IP 层只能提供最大努力服务，所以 TCP 需要采用适当措施保证传输可靠

TCP 主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输

- 校验和：接收端通过对 TCP 首部、TCP 伪首部和 TCP 数据进行校验计算，可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃 TCP 段

- 序列号/确认应答：发送端发送信息给接收端，接收端会回应一个应答包；只要发送端有一个包传输，但没有收到应答包都会重发数据，这样保证了数据完整性

- 超时重传：发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传

- 最大消息长度：在建立 TCP 连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传

- 滑动窗口：发送方可连续发送多个分组，不必每发完一个包就停下来等待确认，提高信道利用率，通过滑动窗口机制，接收方对按序到达的最后一个包进行确认，表示最后一个包以前的都是正确收到

- 拥塞控制

## Nagle 算法

本质是限制大批量的小数据包同时发送，为此它提出在任何一个时刻未被确认的小数据包不能超过一个

这里的小数据包，指的是长度小于最大报文段长度 MSS 的 TCP 分组

发送端就可以把接下来连续的几个小数据包存储起来，等待接收到前一个小数据包的 ACK 分组之后，再将数据一次性发送出去

## TCP 故障排查

通过 TCP 各个状态，可以排除和定位网络或系统故障

### 常用命令

- `netstat -nat`：查看 TCP 各个状态的数量

- `lsof -i: port`：检测到打开套接字的状况

- `tcpdump -iany tcp port 9090`：对 tcp 端口为 9000 的进行抓包

### 常见状态

#### LISTENING

当提供的服务没有被连接时就处于 LISTENING 状态

#### SYN_SENT

发送连接请求后等待匹配的连接请求，客户端 tcp 发送一个 SYN 以请求建立一个连接，之后状态置为 SYN_SENT

连接成功了就变为 ESTABLISHED，正常情况下 SYN_SENT 状态非常短暂

如果发现有很多 SYN_SENT，一般是网络不好或服务器不存在

#### SYN_RECV

当服务器收到客户端发送的同步信号时，将标志位 ACK 和 SYN 置 1 发送给客户端，此时服务器端处于 SYN_RCVD 状态，如果连接成功了就变为 ESTABLISHED，正常情况下 SYN_RCVD 状态非常短暂

如果发现有很多 SYN_RECV，可能出现 SYN 攻击，服务器端一般会重试（再次发送 SYN + ACK 给客户端）并等待一段时间后丢弃这个未完成的连接

#### CLOSE_WAIT

客户端断开的时候发送了 FIN 包，则服务端将会处于 CLOSE_WAIT 状态

客户端断开的时候未发送 FIN 包，则服务端处还是显示 ESTABLISHED 状态