---
toc:
  enable: true
  number: false
  max_depth: 3
title: ssl
date: 2023-06-20 21:34:36
tags: 网络协议
categories: 网络协议
---

SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于会话层

在 1999 年它改名为 TLS（Transport Layer Security），目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的

## 数据机密性

SSL/TLS 通过加密（encrypt）得到密文（cipher text），从而保证数据传输的安全性

只有拥有密钥的人才能够通过解密（decrypt）获得明文（plain text），加密解密的操作过程就是加密算法

密钥是一长串的数字，约定俗成的度量单位是位。密钥长度是 128 就是 16 字节的二进制串，密钥长度 1024 就是 128 字节的二进制串

按照密钥的使用方式，加密可以分为两大类：对称加密和非对称加密

### 对称秘钥加密

加密和解密使用同一密钥，TLS 里目前常用的有 AES 和 ChaCha20

- 优点：运算速度快

- 缺点：无法安全地将密钥传输给通信方

### 非对称秘钥加密

加密和解密使用不同的密钥，公开密钥所有人都可以获得

公钥和私钥中的任一个均可用作加密，此时另一个则用作解密

在 TLS 里常用的有 DH、DSA、RSA、ECC 等

- 优点：可以更安全地将公开密钥传输给通信发送方

- 缺点：运算速度慢

### 混合加密

非对称加密运算速度太慢，所以 TLS 使用混合加密，既能高效加解密，又能安全传输数据

1. 客户端用随机数生成对称算法使用的会话密钥（session key）

2. 客户端用非对成算法的公钥将会话密钥加密，然后发送至服务端

3. 服务端拿到密文后用私钥解密，取出会话密钥

4. 双方实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密

## 数据完整性

实现完整性的手段主要是摘要算法

把摘要算法可以近似地理解成一种特殊的加密算法，它能够把任意长度的数据加密成固定长度、而且独一无二的摘要字符串，且不能从压缩后的密文中推导出原文

MD5、SHA-1 是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要，但这两个算法的安全强度比较低，在 TLS 里已经被禁止使用了

摘要算法保证了数字摘要和原文是完全等价的，所以只要在原文后附上它的摘要，就能够保证数据的完整性

摘要算法不具有机密性，所以真正的完整性还是需要建立在机密性之上

## 身份认证

### 数字签名

数字签名就是用私钥加密原文的摘要

### 数字证书和 CA

因为公钥是任何人都可以发布的，所以需要引入第三方来保证公钥的可信度，这个第三方就是常说的 CA（Certificate Authority，证书认证机构）

CA 对公钥的签名认证也是有格式的，要包含公钥的序列号、用途、颁发者、有效时间等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成数字证书（Certificate）

小一点的 CA 可以让大 CA 签名认证，但链条的最后 Root CA，就只能自己证明自己了，这个就叫自签名证书（Self-Signed Certificate）或者根证书（Root Certificate）

1. 服务器把自己的公钥等信息发布在数字证书认证机构

2. 数字证书认证机构用自己的私钥给服务器的公钥颁发数字证书

3. 浏览器内置一个受信任的 CA 机构列表

4. 浏览器访问服务器时，服务器会提供经 CA 机构认证颁发的数字证书，如果认证该数字证书的 CA 机构存在于浏览器的受信任 CA 机构列表中，并且数字证书中的信息与当前正在访问的网站一致，那么浏览器就认为服务端是可信的，并从数字证书中取得服务器公钥

## SSL 连接

{% asset_img 01.png %}

1. ClientHello：由客户端向服务器发起加密通信请求，主要向服务器发送信息包括：客户端支持的 SSL/TLS 协议版本；客户端生产的随机数（Client Random），后面用于生产对称加密的密钥；客户端支持的密码套件列表，如 RSA 加密算法

2. ServerHello：服务器收到客户端请求后，向客户端发出响应，回应的内容包括：确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信；服务器生产的随机数（Server Random），后面用于生产对称加密的密钥；确认的密码套件列表，如 RSA 加密算法

3. Server Certificate：服务器发送数字证书

4. 客户端验证签名和证书：客户端收到服务器的证书后，通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性

5. 客户端计算 pre-master key：如果证书没有问题，客户端会从数字证书中取出服务器的公钥，并使用它加密报文，向服务器发送以下信息：

- 一个随机数（pre-master key），并使用公钥进行非对称加密

- 加密通信算法改变通知，表示之后的信息都将用对称加密的密钥加密通信

- 客户端握手结束通知，表示客户端的握手阶段已经结束

4. 服务端计算对称加密密钥：服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的对称加密秘钥，向客户端发生最后的信息：

- 加密通信算法改变通知，表示随后的信息都将用对称加密秘钥加密通信

- 服务器握手结束通知，表示服务器的握手阶段已经结束

握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用会话密钥加密内容

客户端和服务器端都拥有三个随机数，双方使用事先商定的加密方法各自生成本次会话所用的同一把对称会话密钥

### 为什么需要随机数

- SSL 协议中证书是静态的，因此有必要引入一种随机因素来保证协商出来的会话密钥的随机性

- SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来