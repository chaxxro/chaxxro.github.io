---
toc:
  enable: true
  number: false
  max_depth: 3
title: 单机高并发设计
date: 2023-08-09 21:11:17
tags: 后端设计
categories: 后端设计
---

在微服务架构下，通常会选择通过水平扩展来提升系统的并发能力，即使用多服务器，通过分布式部署的方式来支持高并发的请求。但只有在单台机器处理能力达到更高水平的同时，再配合水平扩展，才能最大程度地利用服务器资源，避免资源浪费

服务器在处理网络请求时，主要可以分为接收网络请求和处理网络请求两个步骤。连接管理功能决定着是否可以接收高并发的网络连接，而请求处理功能则决定是否可以及时处理和响应用户的请求

## 连接管理高并发设计

一个合适的网络 IO 模式对于网络后台非常重要，它决定着网络后台能够管理的最大并发连接数

常用网络 IO 模式都是基于事件驱动的。服务端在接收到网络连接后不会立即分配线程处理连接，而是监听事件，在有事件时再分配进程或者线程进行处理

目前使用最广泛的两种事件驱动模式是 Reactor 和 Proactor

### 实践

Proactor 模式需要操作系统支持异步 IO 模型，目前只有 Windows 操作系统下的 IOCP 是完整的支持 socket 的异步编程接口，所以选择主从 Reactor 模式作为服务端的网络 IO 处理模式

使用 `epoll` 管理文件描述符，监听网络事件

- 更高效的处理大量的文件描述符，并且没有数量的限制

- 支持边缘触发，只有所监听的事件状态改变或者有事件发生时才会触发一次，可以有效的减少 IO 操作次数

使用多 Reactor 多线程方案

- 主线程中的 MainReactor 只负责通过 `epoll` 监听连接建立事件，收到事件后通过 Acceptor 对象中的 `accept`` 获取连接，将新的连接分配给子线程中的 Reactor 处理

- 子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入`epoll` 继续进行监听，并创建一个 Handler 用于处理连接的响应事件

- Handler 对象不负责业务处理，只负责数据的接收和发送，Handler 对象通过 `read` 读取到数据后，会将数据发给 Work 线程进行业务处理

## 请求处理高并发设计

使用多进程多线程时，针对不同的场景和任务类型，存在不同的并行处理模式，选择合适的模式可以更好的提高并行处理效率

- 生产者-消费者模式：生产者和消费者使用缓冲区进行解耦，多个任务在进程线程内串行执行，在不同的进程线程间并行执行，达到并行处理请求的目的

- Future 模式：一种异步调用模式，通过新建一个异步处理逻辑在后台处理耗时调用，而主流程不阻塞继续执行。当执行完所有流程后再获取异步调用的结果

- Master-Worker 模式：对子任务进行拆分，将一个大任务分成若干个小任务，分别在不同的进程线程中处理，最后将子任务结果进行合并

- 流水线模式：当处理请求的每个阶段存在依赖不适合拆分子任务时，可以按照流水线思想，将任务的不同阶段交给不同的进程线程执行

还需要注意进程间通信效率以及线程间的锁竞争导致的并发度下降问题，这样才能利用多核 CPU 的优势，实现任务的并行处理，达到高并发处理请求的目的

### 实践

#### 多进程划分

连接管理逻辑和业务处理逻辑相互之间比较独立，因此可以把整个服务划分为连接管理进程和业务处理进程。对于不同的服务，只需要修改业务处理进程实现各自的逻辑即可，完全不用改动连接管理进程

划分进程后需要实现进程间的高效通信来减少多进程对高并发请求处理的影响。进程间通信主要包括数据缓存和数据通知两方面，为此的网络框架可以封装统一的 MQ 通信结构用于进程间通信，该结构内部封装了共享内存和命名管道两种结构

在共享内存上构建了环形缓冲区结构，环形缓冲区适用于一方生产数据，另一方消费数据的场景。通过环形缓冲区可以实现在进程间有序传输非固定大小数据的目的。并且框架中只有一个生产者和一个消费者，所以只需要保证环形缓冲区的写入索引指针只允许生产者访问并修改，读取索引指针只允许消费者访问并修改，因此就不用对该结构进行额外加锁保护

可以通过命名管道传输数据的写入信号来实现通知目的。在通信时，进程首先把数据写入共享内存的环形缓冲区队列中，当队列中的数据达到一定长度时，通过管道传输一个字符，对端进程只要通过 `epoll` 监听管道句柄，就可以及时地获得读写信号，进行数据读写

#### 多线程并行处理

为了避免线程的频繁创建和销毁，需要使用线程池来管理多个线程。预先创建好线程放入线程池内，当任务到达时，任务可以不需要等待线程创建就能立即执行，通过线程池统一管理线程可以提高线程对任务处理的响应速度和减少性能消耗

在实现任务缓冲队列时，为了减少锁竞争对多线程并发访问的影响，可以通过无锁编程技术实现无锁的缓冲队列结构。无锁队列的实现机制是使用 CAS 操作，即在对数据执行写操作前，先比较下数据是否有变更，没有变更的情况下才去执行写操作，否则返回失败。由于 CAS 整体是一个原子操作，因此在 CAS 修改成功的情况下，能够保证是线程安全的

相对于加锁，使用无锁队列的优点是 CAS 不需要进行消耗繁重的上下文切换，因为上下文切换对于 CPU 来说消耗是比 CAS 轮询更大的

#### Future 模式应用

Future 模式适用于对单个耗时任务的加速处理，配合生产者-消费者模式，在消费者线程内部使用

使用 Future 模式最多的就是异步查询 MySQL 任务

#### 锁优化

- 降低锁范围，将一些不需要放到同步锁内执行的逻辑放到外面执行，降低锁内逻辑的处理时长，减少其他线程阻塞等待的时间

- 在对数组结构或者基于数组的 HashTable 结构加锁时，可以采用分段加锁的方式，把整个数组细分为多个段，每个段分别加锁

- 细化锁的使用场景，根据不同的场景使用不同类型的锁






