---
toc:
  enable: true
  number: false
  max_depth: 3
title: Feed 流设计
date: 2023-06-06 16:32:41
tags: 后端设计
categories: 后端设计
---

Feed 流是将用户主动订阅的若干消息源组合在一起形成内容聚合器，帮助用户持续地获取最新的订阅源内容

简而言之，Feed 流就是持续更新并呈现给用户内容的信息流

## 展现形式

- timeline 是最典型的 Feed 流展示方式，它按照内容更新的时间先后顺序将内容展示给用户，如朋友圈、微博关注页

- rank 即按照某些因素计算内容的权重，从而决定内容展示的先后顺序，如抖音推荐页

- aggregate 聚合类型，比如几个朋友看了一部电影，这就可以聚合为一条 Feed

- notice 通知类型，一般用于各种通知、私信等场景

## timeline 设计

### 获取数据

#### 读扩散

用户刷新时，服务先查询用户所有关注的 uid，根据 uid 查询发布的内容，再按照发布时间进行排序

- 读扩散不需要额外的存储，每次发布只需写入一条数据

- 用户增删关注只需操作关注列表，没有额外操作

- 头部发布者不需要特殊处理

- 因为每次拉取都需要大量读取数据和排序，关注数较多时耗时增加明显

#### 写扩散

内容发布者发布新内容时，对粉丝的 timeline 进行写入

- 写扩散的拉取操作简单高效

- 写扩散的发布操作逻辑复杂，不仅需要更新内容，在新增、取消关注的时候也需要额外逻辑处理

- 头部发布者的写入量巨大

#### 模型对比

||优点|缺点|
|-|-|-|
|读扩散|逻辑简单，节约存储空间|读取效率低下
|写扩散|读取操作快|逻辑复杂，消耗大量存储空间

由于 Feed 流是读多写少的场景，所以一般情况下采用写扩散，系统的性能会比读扩散要好

当有大 v 发布者出现时，每次发布消息可能消息需要同步给 1 亿用户，这样写扩散的性能会被严重影响到。所以在大 v 用户上，采用读写结合的方式进行处理。具体来说就是：大 v 用户发布消息，消息写扩散到活跃用户收件箱。而不活跃用户在登录的时候，会去主动拉取大 v 用户的发件箱，完成自身收件箱的更新

### 翻页设计

Feed 流是一个动态列表，每时每刻都可能在更新，所以传统的使用 page_size 和 page_num 来分页就不能满足使用了，因为但凡两页之间出现内容的添加或删除，都会导致错位问题

Feed 流的分页入参使用 last_id 来记录上一页最后一条内容的 id。但采用 last_id 方式要求数据不能被删除，否则可能找不到对应的记录。为此，删除都采用标志位表示删除

#### 写扩散

由于用户收件箱是提前排序准备好的，所以 last_id 直接往后读取即可

#### 读扩散

由于读扩散下，用户的收件箱是实时计算出来的，所以翻页时需要去所有关注人的发件箱中拉取一定量的数据

拉取后，需要记录当前拉取到了写信箱的 write_last_id1，多少个关注就要记录了多少个 write_last_id。之后翻页的时候，需要用这些 write_last_id 往后拉取新的一定量的数据

### 修改发布内容

写扩散模式下，用户发布消息可以慢慢扩散出去，但是删除，修改都要扩散出去，速度过慢会出现时效性问题

消息内容不进行实际删除，而是将消息置为删除状态即可，不扩散出去。如此一来，用户在自己的读取收件箱中消息的时候，是先获取了消息 Id 后，再去数据库查出消息内容，而后判断状态进行过滤，把已经删除的状态剔除
