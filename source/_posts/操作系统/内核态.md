---
toc:
  enable: true
  number: false
  max_depth: 3
title: 内核态
date: 2023-04-26 21:31:07
tags: 操作系统
categories: 操作系统
---

操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间

因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的系统资源，并且在 cpu 的一些指令如果用错，将会导致整个系统崩溃

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同

运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程

`malloc` 通过 `sbrk` 系统调用来分配内存，当 `malloc` 调用 `sbrk` 的时候就涉及一次从用户态到内核态的切换，类似的函数还有 `printf` 调用的是 `wirte`

内核态和用户态之间的转换方式主要包括：系统调用，异常和中断

- 系统调用：用户进程通过系统调用申请操作系统提供的服务程序完成工作

- 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，就会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

- 中断：当外围设备完成用户请求的操作之后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换