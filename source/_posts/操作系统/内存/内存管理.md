---
toc:
  enable: true
  number: false
  max_depth: 3
title: 内存管理
date: 2023-08-09 14:47:58
tags: 操作系统
categories: 内存管理
---

Linux 的内存管理系统自底向上大致可以被划分为内核层内存管理、用户层内存管理和应用程序内存管理

## 内核层内存管理

`kmalloc()`、`__get_free_pages()` 用于申请较小内存，申请的内存位于物理内存的映射区域，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移

- `kmalloc()` 以字节为单位

- `__get_free_pages()` 以页为单位

`vmalloc()` 用于申请较大内存，虚拟内存空间给出一块连续的内存区，但不保证物理内存连续，开销远大于 `__get_free_pages()`，需要建立新的页表

## 用户层内存管理

通过调用系统调用函数 `brk()`、`mmap()` 等实现的常用的内存管理接口 `malloc`、`free`、`realloc`、`calloc`

经典内存管理库 ptmalloc2、tcmalloc、jemalloc

## 应用程序内存管理

应用程序通过内存管理库或直接调用系统内存管理函数分配内存，根据应用程序本身的程序特性进行使用，如：单个变量内存申请和释放、内存池化复用等。

## malloc

glibc 库实现了 `malloc()`，它实现 linux 系统的堆管理

```cpp
 #include <stdlib.h>

void *malloc(size_t size);
void free(void *ptr);
```

`malloc()` 维护了多个不定长的内存块全局链表，每个链表负责一个大小范围。这种做法有效减少了分配大内存时的遍历开销，类似于哈希的方式将很大范围的数据散列到有限的几个小的范围内，虽然最终还是要在小的范围内查找，但还是可以省去很多的开销

glibc 另外的策略就是不止维护一类空闲链表，而是另外再维护一个缓冲链表和一个高速缓冲链表。在分配的时候首先在高速缓存中查找，失败之后再在空闲链表查找。如果找到的内存块比较大，那么将切割之后的剩余内存块插入到缓存链表。如果空闲链表查找失败那么就往缓存链表中查找，如果还是没有合适的空闲块，就向内存申请比请求数更大的内存块，然后把剩下的内存放入链表中

调用 `free()` 时，它将用户释放的内存块回收到空闲链表。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是 `malloc()` 会开始在空闲链上检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块

### 内存分配原理

`malloc()` 底层使用 `brk()` 和 `mmap()` 两个系统调用

`brk()` 用于申请和释放小内存。数据段的末尾，堆内存的开始，叫做 brk。`brk()` 将数据段的最高地址指针 _edata 向高或低移动实现堆内存的扩张或收缩。低地址堆内存必须在高地址堆内存的释放之后才能得到的释放。默认情况下，当最高地址空间的空闲内存超过 128K 时，执行内存紧缩操作

`mmap()` 用于申请大内存。大于 128 K 的内存申请使用系统调用 `mmap()` 分配内存，申请的内存在堆和栈中间。与 `brk()` 分配内存不同的是 `mmap()` 分配的内存可以单独释放

这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系

### malloc 头

`malloc()` 返回的地址前有一个 16 字节的地址头，用来表示分配的内存大小

前 8 个字节表示之前的空间有多少没有被分配的字节大小，后 8 个字节表示当前 `malloc()` 已经分配的字节大小，前 8 个字节通过加 1 来作为前一个数据块是否已经分配的标志，加1表示前一个数据块已经分配