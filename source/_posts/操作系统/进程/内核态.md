---
toc:
  enable: true
  number: false
  max_depth: 3
title: 内核态
date: 2023-04-26 21:31:07
tags: 操作系统
categories: 操作系统
---

操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间

因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的系统资源，并且在 cpu 的一些指令如果用错，将会导致整个系统崩溃

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同

运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程

内核态和用户态之间的转换方式主要包括：系统调用，异常和中断

## 系统调用

用户进程通过系统调用申请操作系统提供的服务程序完成工作

CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务

系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程

所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换

需要注意的是，系统调用过程中并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟通常所说的进程上下文切换是不一样的。进程上下文切换，是指从一个进程切换到另一个进程运行，而系统调用过程中一直是同一个进程在运行

进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来。而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈

Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程

## 异常
当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，就会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

## 中断

当外围设备完成用户请求的操作之后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换