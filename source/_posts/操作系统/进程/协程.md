---
toc:
  enable: true
  number: false
  max_depth: 3
title: 协程
date: 2023-04-28 20:41:25
tags: 操作系统
categories: 进程
---

## 为什么需要协程

移动互联网时代的到来，服务端对高并发的要求越来越高，也就是需要高性能的网络服务器

C10K 需要单机同时支持 1 万个并发连接，C10M 单机要支持 1 千万并发连接

如果要满足单机 1 千万的并发连接，有几种方案选择：

1. 多线程同步模型：预先创建出很多个处理线程，每个线程采用同步阻塞 IO 的方式串行处理请求，由操作系统通过线程切换来实现并发处理。这种方式编码简单，但由于线程堆栈占用空间大，内存消耗太快，同时线程切换代价高，导致系统整体性能较差

2. 基于事件驱动的异步网络模型：由应用框架来实现事件驱动和状态切换，该方案可以充分利用 CPU，性能较高，但因为逻辑处理都是基于回调，逻辑代码过于分散，导致代码开发效率不高，代码逻辑不易懂也容易出错

协程能够让开发人员很便捷地去开发业务逻辑代码，同时能够达到异步回调模型的性能

## 什么是协程

协程是一类程序组件，它是对子过程概念的泛化，并且是属于非抢占的多任务处理

- 泛化的子过程是说协程是泛化的函数，可以暂停和恢复执行

- 非抢占的多任务处理说明协程是协作式多任务处理，需主动让出 CPU

协程就是一个函数，只是它支持多次的暂停和恢复执行，需要自己手动维护调用栈和其他的一些信息

协作式多任务处理，协程主动让出 CPU，天然就支持协作式多任务

线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率

```cpp
void A() {
   cout << 1 << " ";
   cout << 2 << " ";
   cout << 3 << " ";
}

void B() {
   cout << "x" << " ";
   cout << "y" << " ";
   cout << "z" << " ";
}

int main(void) {
  A();
  B();
}
// 1 2 3 x y z

void A() {
   cout << 1 << " ";
   cout << 2 << " ";
   co_yield_ct();  // 切出到主协程
   cout << 3 << " ";
}

void B() {
   cout << "x" << " ";
   co_yield_ct();  // 切出到主协程
   cout << "y" << " ";
   cout << "z" << " ";
}

// 切出操作是由 co_yield_ct() 函数实现
// 启动和恢复是由 co_resume() 实现
int main(void) {
  ...  // 主协程
  co_resume(A);  // 启动协程 A
  co_resume(B);  // 启动协程 B
  co_resume(A);  // 从协程 A 切出处继续执行
  co_resume(B);  // 从协程 B 切出处继续执行
}
// 1 2 x 3 y z
```

## 协程特点

- 协程可以主动让出 CPU 时间片，不是当前线程让出 CPU 时间片，而是线程内的某个协程让出时间片供同线程内其他协程运行

- 协程可以恢复 CPU 上下文，当另一个协程继续执行时，需要恢复 CPU 上下文环境

- 协程有个管理者，管理者可以选择一个协程来运行，其他协程要么阻塞，要么 ready，或者 died

- 运行中的协程将占有当前线程的所有计算资源

- 协程天生有栈属性，而且是 lock free

## 保存上下文

上下文其实本质上就是寄存器，所以保存上下文实际上就是把寄存器的值保存下来

- `setjmp` 和 `longjmp`

- 汇编

- 第三方库，如 ucontext、Boost.Context

## 协程类别

### 栈

这里的栈指的是是否存在调用栈 callback stack

- stackful 有栈协程：实现类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核，例如 goroutine、libco

- stackless 无栈协程：上下文都会放到公共内存中，在协程切换时使用状态机来切换，而不用切换对应的上下文，因此相比有栈协程要轻量许多，例如：C++20、Rust、JavaScript

### 调度方式

根据调度方式的不同，协程可以分为对称协程和非对称协程

- 非对称协程：协程之间有明显的调用关系。协程让出执行权的目标只能是它的调用者，即协程之间存在调用和被调用关系，比如 A 协程调用了 B 协程后，B 协程当需要让出执行权时一定是将执行权给了 A 协程

- 对称协程：协程之间无明显的调用关系。任何一个协程都是相互独立且平等的，执行权可以在任意协程之间转移，比如 A 协程调用了 B 协程后，A 协程与 B 协程之后就没有任何关系了，B 协程让出执行权时，该执行权最终花落谁家都有可能

协程 A 调用了协程 B：如果只有 B 完成之后才能切回 A，那么此时 AB 是非对称协程；如果 AB 被调用的概率相同，那么此时 AB 是对称协程

### 线程关系

和线程绑定的协程只有在对应线程运行的时候才有被执行的可能，如果对应线程中的某一个协程完全占有了当前线程，那么当前线程中的其他所有协程都不会被执行

- N:1：所有的协程运行于一个系统线程中。由于不跨线程，协程之间的切换不需要系统调用，从而切换可以非常快，受 cache 一致性的影响也小。但代价是协程无法高效地利用多核，代码必须非阻塞，否则所有的协程都被卡住

- N:M：N 个协程会映射至 M 个线程