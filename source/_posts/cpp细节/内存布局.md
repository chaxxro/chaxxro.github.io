---
toc:
  enable: true
  number: false
  max_depth: 3
title: 内存布局
date: 2023-11-14 20:55:36
tags: cpp
categories: cpp
---

## 空类

对于完全空的类，为了使类的不同对象在内存中分配到独一无二的地址，通常编译器会隐式地为类添加 1 字节

## 普通类

如果没有 `virtual` 函数，也没有 `virtual base class`，那么在对象布局时，只需要考虑非静态数据成员。`static` 的方法和成员自然不会被放在对象中，而非静态的方法将被放置在代码区，与对象布局无关

对于同一个类中的非静态数据成员，C++ 标准规定同一个 access section（即一个 `private`、`public`、`protected` 区段）中的数据成员，其排列需遵循后声明的有更高的地址

对于不同区段，C++ 没有规定它们之间的位置关系，但绝大多数编译器都是把各个数据成员按照声明顺序连在一起排列

如果有继承关系，则子类的对象中，需要包含父类的一个 subobject，父类的 subobject 是一个完整的父类对象

C++ 标准未指定父类的 subobject 应该被放在子类对象的哪个位置，不过对于大部分编译器而言，父类的 subobejct 是放在子类对象的开头处

## 有虚函数的类

有虚函数的类，编译器会隐式添加一个 vptr 并 vptr 指向 vtable，vptr 被放在了对象的布局最顶端

```cpp
class A {
public:
  A() = default;
  int a;
  virtual void f(){};
};

/*
gcc的虚表里，前两项是固定的
一个是 offset_to_top，服务于 dynamic_cast
一个是 typeinfo，服务于 RTTI
Vtable for A
A::_ZTV1A: 3 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI1A)  // 指向 _ZTI1A 结构体
16    (int (*)(...))A::f

Class A
   size=16 align=8
   base size=12 base align=8
A (0x0x7f498e80c960) 0
    vptr=((& A::_ZTV1A) + 16)  // 指向 A::f，而非虚函数表的开头
*/
```

### 多重继承

在具备多重继承时，情况与单级继承时基本类似，但需要注意这种情况下的两个隐式地址加减机制

class C 多重继承了 class A 和 class B，其中 A 为其主要基类（primary base class），B 为非主要基类（non-primary base class），则 C 的对象布局中，会存在 A、B 类对象的 subobject

因为 A、B、C 中都存在 virtual functions，首先 C 中有一个 vptr 指向C类的 vtable，这个 vtable 又称为 primary vtable，其构成原理与单级继承时一样，在 C 类对象被当作 A 类指针、引用时，使用这个 vtable

与单级继承不同的是，此时 C 对象中还包含一个 vptr，指向一个 non-primary vtable，这个 vtable 的作用是处理当 C 类对象被当作 B 类时的 virtual function 调用，并非 B 类的 vtable

```cpp
class Base1 {
public:
  void f0() {}
  virtual void f1() {}
  int a;
};

class Base2 {
public:
  virtual void f2() {}
  int b;
};

class Derived : public Base1, public Base2 {
public:
  void d() {}
  void f2() {}  // override Base2::f1()
  int c;
};

/*
Vtable for Base1
Base1::_ZTV5Base1: 3 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base1)
16    (int (*)(...))Base1::f1

Class Base1
   size=16 align=8
   base size=12 base align=8
Base1 (0x0x7ff92845c960) 0
    vptr=((& Base1::_ZTV5Base1) + 16)

Vtable for Base2
Base2::_ZTV5Base2: 3 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI5Base2)
16    (int (*)(...))Base2::f2

Class Base2
   size=16 align=8
   base size=12 base align=8
Base2 (0x0x7ff92845ca80) 0
    vptr=((& Base2::_ZTV5Base2) + 16)

Vtable for Derived
Derived::_ZTV7Derived: 7 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI7Derived)
16    (int (*)(...))Base1::f1
24    (int (*)(...))Derived::f2
32    (int (*)(...))-16
40    (int (*)(...))(& _ZTI7Derived)
48    (int (*)(...))Derived::_ZThn16_N7Derived2f2Ev

Class Derived
   size=32 align=8
   base size=32 base align=8
Derived (0x0x7ff928472000) 0
    vptr=((& Derived::_ZTV7Derived) + 16)
  Base1 (0x0x7ff92845cb40) 0
      primary-for Derived (0x0x7ff928472000)
  Base2 (0x0x7ff92845cba0) 16
      vptr=((& Derived::_ZTV7Derived) + 48)
*/

int main() {
  Derived d;
  Base1* p1 = &d;
  Base2* p2 = &d;
  std::cout << &d << std::endl;
  std::cout << p1 << std::endl;
  std::cout << p2 << std::endl;
  return 0;
}
// 0x7ffea91b1ca0
// 0x7ffea91b1ca0
// 0x7ffea91b1cb0 进行了偏移
```