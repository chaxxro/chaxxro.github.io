---
toc:
  enable: true
  number: false
  max_depth: 3
title: 常见性能优化方法
date: 2023-07-13 10:34:41
tags: cpp
categories: cpp
---

## 栈内存偏见

堆是操作系统级别的概念，而栈是 cpu 级别的

`malloc` 堆区分配内存是很昂贵的，但栈内存的分配成本却很低

cpu 会提供两个寄存器 sp 和 bp，bp 和 sp 分别存取栈底和栈顶的地址。栈是从高地址向低地址增长的，所以减小 sp 代表增大栈空间，增大sp代表减少栈空间

而对于一个函数，该函数需要多少栈空间是编译期间决定的，不会对运行时造成任何开销。需要栈空间的大小，仅仅是改变了 sp 分配栈空间时操作数的变化而已

x64 下 linux 默认给线程分配的栈是 8MB，如果在能保证不爆栈的情况下，务必优先在栈上分配内存空间，它是零开销的

## 函数内联

函数调用的性能开销：

1. 函数参数的传递需要写内存或寄存器

2. 调用函数的汇编可以简化为 `push return address` 和 `jump`，`jump` 是 cache 不友好的

3. 为保证 caller 上下文不被覆盖，还需要对 caller 的寄存器进行入栈保存

函数內联的本质就是代码复制拷贝，它会直接将 callee 的代码内容复制到 caller 的上下文中

內联函数好处：

1. 省略函数调用开销

2. 将函数的代码拷贝到 caller 上下文，从而编译器能做更多优化

內联后是在任何调用者处对函数代码做了拷贝，因此可能会导致生成的二进制更大

## 内存对齐

编译器倾向于将每个结构体成员的地址放在其大小的整数倍上，如 `uint64_t` 存取的地址就是 8*n，`uint32_t` 存取的地址是 4*n

非内存对齐可能会导致两次内存 IO

## False Sharing

CPU 物理核心配有多级 sram cache，CPU 都是优先读写自己的 cache，然后才是访存，那么必然存在一致性问题

为了解决一致性问题就引入了 cache 间通信协议来解决。如果 P1 更改了变量 a，为了保证一致性 P1 需要向 cache bus 上发送一个 Invalid Message，保证变量 a 所处的 cache line 在其他处理器的 cache 中失效。其他处理器要再次访问变量 a 需要向 P1 发送 Read Miss 消息提交申请，然后 P1 负责将最新 cache line 同步到其他处理器或者写到内存

cache 之间沟通的最小单位是一个 cache line 大小，现代主流 CPU 都是 64 字节，所以 cache 之间失效的不会是单纯一个变量，而是整个变量所处的这个 cache line

## 无分支编程

在冯诺依曼架构计算机下，指令和数据都存在内存中。对于一条指令的执行肯定是分很多过程的，以最经典的五级流水线为例，一条指令分为如下阶段：

1. 取址(IF)：从内存中读取出指令

2. 译码(ID)：咱们得先知道取的是什么指令

3. 执行(EX)

4. 访存(MEM)：指令总有操作数嘛，访存获取它们或者将计算结果写入到内存

5. 写回(WB)：将执行结果写入到目标寄存器

每个阶段可以简单理解为有专门的一个 CPU 部件处理

为了更好的压榨每个部件的，CPU 引入了流水化技术，核心原理就是上一条指令立马发射就紧跟着发射下一条待执行的指令

遇到条件判断时 CPU 会面临一个问题，往后具有两个分支，流水线会停下来等到有结果了再继续执行

分支预测是基于分支的历史信息，分支的条件越具有规律性，那么 CPU 对分支预测的越准确