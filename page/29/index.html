<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chaxxro.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="好记性不如烂键盘">
<meta property="og:type" content="website">
<meta property="og:title" content="也无风雨也无晴">
<meta property="og:url" content="https://chaxxro.github.io/page/29/index.html">
<meta property="og:site_name" content="也无风雨也无晴">
<meta property="og:description" content="好记性不如烂键盘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chaxxro">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaxxro.github.io/page/29/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/29/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>也无风雨也无晴</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">也无风雨也无晴</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chaxxro</p>
  <div class="site-description" itemprop="description">好记性不如烂键盘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">368</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/Docker-Dockerfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/Docker-Dockerfile/" class="post-title-link" itemprop="url">Dockerfile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 14:59:54" itemprop="dateCreated datePublished" datetime="2023-04-02T14:59:54+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] &lt;上下文路径/URL/-&gt;</span><br><span class="line"><span class="comment"># OPTION说明：</span></span><br><span class="line"><span class="comment"># -f ：指定 Dockerfile 文件名字，默认为当前目录的 Dockerfile 文件；</span></span><br><span class="line"><span class="comment"># -m ：设置构建后内存使用最大值；</span></span><br><span class="line"><span class="comment"># --ulimit ：设置 ulimit；</span></span><br><span class="line"><span class="comment"># -t ：镜像名字和标签，通常使用 name:tag 或 name 格式；</span></span><br></pre></td></tr></table></figure>

<p>当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎</p>
<p><code>COPY</code> 这类指令中的源文件的路径都是相对路径，因为 docker 引擎无法获取超出上下文范围的文件</p>
<p>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore</p>
<p><code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建</p>
<p>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建</p>
<h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>定制镜像一定是以一个镜像为基础，在其上进行定制</p>
<p><code>FROM</code> 就是指定基础镜像，因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令</p>
<p>Docker 还存在一个特殊的镜像，名为 scratch，这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像</p>
<h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令，格式有两种：</p>
<ul>
<li><p>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样，Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式</p>
</li>
<li><p>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</p>
</li>
</ul>
<p>每一个 <code>RUN</code> 的行为，就和手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>

<p>上面的这种写法创建了 7 层镜像，很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等</p>
<p>正确的写法应该是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN set -x; buildDeps=&#x27;gcc libc6-dev make wget&#x27; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>

<h2 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [--from=&lt;阶段&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [--from=&lt;阶段&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,... <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br><span class="line"><span class="comment"># COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</span></span><br><span class="line"><span class="comment"># --from=&lt;阶段&gt;中的阶段是必须在 FROM 中定义的，它表示该 copy 操作是从镜像中某个阶段产生的结果中 copy，而不是从宿主机</span></span><br><span class="line"><span class="comment"># --chown=&lt;user&gt;:&lt;group&gt; 选项来改变文件的所属用户及所属组</span></span><br></pre></td></tr></table></figure>

<p>源路径可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <code>filepath.Match</code> 规则</p>
<p>目标路径可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）</p>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径</p>
<h2 id="ADD-添加文件"><a href="#ADD-添加文件" class="headerlink" title="ADD 添加文件"></a>ADD 添加文件</h2><p><code>ADD</code> 命令与 <code>COPY</code> 命令基本一致，只是在 <code>COPY</code> 命令的基础上增加了两个功能：</p>
<ol>
<li><p>支持源文件是一个 URL，此时 docker 引擎会试图去下载这个文件放到目的路径中，下载后的文件权限自动设置为 600</p>
</li>
<li><p>支持自动解压，如果源文件是一个 tar，则会自动进行解压</p>
</li>
</ol>
<h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><p>容器就是进程，那么在启动容器的时候，需要指定所运行的程序及参数</p>
<p><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的</p>
<ul>
<li><p>shell 格式：<code>CMD &lt;命令&gt;</code></p>
</li>
<li><p>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></p>
</li>
</ul>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令</p>
<p>使用 shell 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行</p>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号</p>
<h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数</p>
<p><code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令</p>
<h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><ul>
<li><p><code>ENV &lt;key&gt; &lt;value&gt;</code></p>
</li>
<li><p><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p>
</li>
</ul>
<h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><p><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量</p>
<p>所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的</p>
<p><code>ARG</code> 指令是定义参数名称，以及定义其默认值，该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</p>
<p><code>ARG</code> 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令前</p>
<h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><ul>
<li><p><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></p>
</li>
<li><p><code>VOLUME &lt;路径&gt;</code></p>
</li>
</ul>
<p>容器运行时应该尽量保持容器存储层不发生写操作</p>
<p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据</p>
<h2 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h2><p><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，在容器运行时并不会因为这个声明应用就会开启这个端口的服务</p>
<p>是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</p>
<p>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口</p>
<h2 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h2><p><code>WORKDIR &lt;工作目录路径&gt;</code> 指定工作目录，以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录</p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更，因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令</p>
<p>如果 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关</p>
<h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层</p>
<p><code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份</p>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p><code>ONBUILD &lt;其它指令&gt;</code></p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等在当前镜像构建时并不会被执行，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行</p>
<h2 id="LABEL-为镜像添加元数据"><a href="#LABEL-为镜像添加元数据" class="headerlink" title="LABEL 为镜像添加元数据"></a>LABEL 为镜像添加元数据</h2><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据</p>
<p><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/Docker-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/Docker-%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">Docker 网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 14:58:29" itemprop="dateCreated datePublished" datetime="2023-04-02T14:58:29+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>docker 在安装时会默认创建三个网络，可以使用 <code>docker network ls</code> 可以查看</p>
<p>docker 内部支持 4 种网络：</p>
<ul>
<li><p>bridge：桥接模式，它会为每一个容器分配、设置 IP，并把容器连接到 docker0 虚拟网桥，通过 docker0 网桥以及 iptables nat 表配置与宿主机通信；</p>
</li>
<li><p>host：容器和宿主机共享 Network namespace，也就是容器没有内部模式；</p>
</li>
<li><p>none：容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接、配置 IP 等；</p>
</li>
<li><p>container：容器和另外的容器共享 Network namespace，在 k8s 中的 pod 就是多个容器共享一个 Network namespace</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/Docker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/Docker-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">Docker 命令行</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 14:56:50" itemprop="dateCreated datePublished" datetime="2023-04-02T14:56:50+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker run --<span class="built_in">rm</span> hello-world</span><br></pre></td></tr></table></figure>

<h2 id="使用国内源"><a href="#使用国内源" class="headerlink" title="使用国内源"></a>使用国内源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否在 docker.service 文件中配置过镜像地址</span></span><br><span class="line">systemctl <span class="built_in">cat</span> docker | grep <span class="string">&#x27;\-\-registry\-mirror&#x27;</span></span><br><span class="line"><span class="comment"># 有配置镜像地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有配置镜像地址</span></span><br><span class="line"><span class="comment"># 在 /etc/docker/daemon.json 中写入</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 docker 服务</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># yum 移除 docker 相关组件</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 lib 目录下的 docker 内容</span></span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 lib 目录下的 contain 内容</span></span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h2 id="查看-docker-版本信息"><a href="#查看-docker-版本信息" class="headerlink" title="查看 docker 版本信息"></a>查看 docker 版本信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<h2 id="查看-docker-概要信息"><a href="#查看-docker-概要信息" class="headerlink" title="查看 docker 概要信息"></a>查看 docker 概要信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有本地主机上的镜像</span></span><br><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"><span class="comment"># OPTION主要有两个：</span></span><br><span class="line"><span class="comment"># -a：显示所有的本地镜像（含历史映像层）</span></span><br><span class="line"><span class="comment"># -q：仅显示镜像ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">docker search [OPTIONS] image-name</span><br><span class="line"><span class="comment">### 结果说明：</span></span><br><span class="line">NAME：镜像名称</span><br><span class="line">DESCRIPTION：镜像描述</span><br><span class="line">STARS：打星的数量</span><br><span class="line">OFFICIAL：是否官方，带有[OK]表示是官方镜像</span><br><span class="line">AUTOMATED：是否自动编译</span><br><span class="line"><span class="comment"># OPTION 主要使用一个</span></span><br><span class="line"><span class="comment"># --limit int : 限制显示多少个</span></span><br><span class="line"><span class="comment"># --stars=&#123;x&#125;：最少有x颗星</span></span><br><span class="line"><span class="comment"># --filter &lt;fitler&gt;：满足某种表达式条件，若有多个表达式，则使用多个--filter分割；</span></span><br><span class="line"><span class="comment"># 包含名称，自动构建，并且是&#123;x&#125;星以上，并且是官方版本：</span></span><br><span class="line">--filter <span class="string">&quot;stars=3&quot;</span> --filter <span class="string">&quot;is-automated=true&quot;</span>  --filter <span class="string">&quot;is-official=true&quot;</span> hello-world</span><br></pre></td></tr></table></figure>

<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"><span class="comment"># tag 默认是 lasest</span></span><br><span class="line"><span class="comment"># name 是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;</span></span><br><span class="line"><span class="comment"># 对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像</span></span><br><span class="line"><span class="comment"># OPTION 说明：</span></span><br><span class="line"><span class="comment"># -a : 下载所有的tag版本的镜像</span></span><br><span class="line"><span class="comment"># --disable-content-trust ：跳过镜像校验</span></span><br></pre></td></tr></table></figure>

<h2 id="查看镜像-x2F-容器-x2F-数据卷等所占空间"><a href="#查看镜像-x2F-容器-x2F-数据卷等所占空间" class="headerlink" title="查看镜像&#x2F;容器&#x2F;数据卷等所占空间"></a>查看镜像&#x2F;容器&#x2F;数据卷等所占空间</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br><span class="line"><span class="comment">### 执行结果</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          1         1         13.26kB   0B (0%)</span><br><span class="line">Containers      2         0         0B        0B</span><br><span class="line">Local Volumes   0         0         0B        0B</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure>

<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"><span class="comment"># OPTION参数说明</span></span><br><span class="line"><span class="comment"># -f ：强制删除某个镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有镜像</span></span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure>

<h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># OPTIONS说明</span></span><br><span class="line"><span class="comment"># -a :提交的镜像作者</span></span><br><span class="line"><span class="comment"># -c :使用 Dockerfile 指令来创建镜像</span></span><br><span class="line"><span class="comment"># -m :提交时的说明文字</span></span><br><span class="line"><span class="comment"># -p :在 commit 时将容器暂停</span></span><br></pre></td></tr></table></figure>

<h2 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a>设置标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &lt;镜像ID&gt; &lt;仓库名&gt;:&lt;版本号&gt;</span><br></pre></td></tr></table></figure>

<h2 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;镜像ID&gt; &gt; &lt;镜像文件名&gt;.tar</span><br></pre></td></tr></table></figure>

<h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; &lt;镜像文件名&gt;.tar</span><br></pre></td></tr></table></figure>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># option</span></span><br><span class="line">-a 登录后台运行的容器</span><br><span class="line">-d 指定容器运行于前台还是后台</span><br><span class="line">-c 设置容器CPU权重，在CPU共享场景使用</span><br><span class="line">-e, --<span class="built_in">env</span>=[] 指定环境变量，容器中可以使用该环境变量</span><br><span class="line">-h, --hostname=<span class="string">&quot;&quot;</span> 指定容器的主机名</span><br><span class="line">-i, --interactive=<span class="literal">false</span> 打开STDIN，用于控制台交互</span><br><span class="line">-t, --<span class="built_in">tty</span>=<span class="literal">false</span> 分配<span class="built_in">tty</span>设备，该可以支持终端登录</span><br><span class="line">-m, --memory=<span class="string">&quot;&quot;</span> 指定容器的内存上限</span><br><span class="line">-P, --publish-all=<span class="literal">false</span> 指定容器暴露的端口</span><br><span class="line">-p, --publish=[] 指定容器暴露的端口</span><br><span class="line">-u, --user=<span class="string">&quot;&quot;</span> 指定容器的用户</span><br><span class="line">-v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录</span><br><span class="line">-w, --workdir=<span class="string">&quot;&quot;</span> 指定容器的工作目录</span><br><span class="line">--name=<span class="string">&quot;&quot;</span> 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</span><br><span class="line">--cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">--cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</span><br><span class="line">--cidfile=<span class="string">&quot;&quot;</span> 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</span><br><span class="line">--cpuset=<span class="string">&quot;&quot;</span> 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</span><br><span class="line">--device=[] 添加主机设备给容器，相当于设备直通</span><br><span class="line">--dns=[] 指定容器的dns服务器</span><br><span class="line">--dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</span><br><span class="line">--entrypoint=<span class="string">&quot;&quot;</span> 覆盖image的入口点</span><br><span class="line">--env-file=[] 指定环境变量文件，文件格式为每行一个环境变量</span><br><span class="line">--expose=[] 指定容器暴露的端口，即修改镜像的暴露端口</span><br><span class="line">--<span class="built_in">link</span>=[] 指定容器间的关联，使用其他容器的IP、<span class="built_in">env</span>等信息</span><br><span class="line">--lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用</span><br><span class="line">--net=<span class="string">&quot;bridge&quot;</span> 容器网络设置</span><br><span class="line">--privileged=<span class="literal">false</span> 指定容器是否为特权容器，特权容器拥有所有的capabilities</span><br><span class="line">--restart=<span class="string">&quot;&quot;</span> 指定容器停止后的重启策略</span><br><span class="line">--<span class="built_in">rm</span>=<span class="literal">false</span> 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</span><br><span class="line">--sig-proxy=<span class="literal">true</span> 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span><br></pre></td></tr></table></figure>

<h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接退出，该退出会导致容器退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 后台退出，该退出仅仅是退出交互终端，不会导致容器退出</span></span><br><span class="line"><span class="comment"># 重新进入可使用：docker attach</span></span><br><span class="line">Ctrl + p + q</span><br></pre></td></tr></table></figure>

<h2 id="重新进入容器"><a href="#重新进入容器" class="headerlink" title="重新进入容器"></a>重新进入容器</h2><p><code>docker attach</code> 进入容器正在执行的终端，不会启动新的进程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到正在运行中的容器</span></span><br><span class="line">docker attach [OPTIONS] CONTAINER</span><br><span class="line"><span class="comment"># --sig-proxy=false 来确保 CTRL-D 或 CTRL-C 不会关闭容器</span></span><br></pre></td></tr></table></figure>

<p><code>docker exec</code> 进入容器后开启一个新的终端，可以在里面操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it container /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> container</span><br><span class="line"><span class="comment"># 不能删除正在运行的容器，如果强制删除 rm -f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部已停止的容器</span></span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -aq)</span><br><span class="line"><span class="comment"># 删除全部容器，不管是否已停止</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)</span><br><span class="line"><span class="comment"># 删除已经退出的容器</span></span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -a | grep Exited | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br><span class="line"><span class="comment"># 常用参数说明：</span></span><br><span class="line"><span class="comment"># -a：所有容器（不加的话表示默认，仅显示活着的容器）</span></span><br><span class="line"><span class="comment"># -n：显示最近的几个，使用方式：docker ps -n &lt;x&gt;</span></span><br><span class="line"><span class="comment"># -l：显示最新的容器</span></span><br><span class="line"><span class="comment"># -q：只显示容器ID</span></span><br></pre></td></tr></table></figure>

<h2 id="启动容器-1"><a href="#启动容器-1" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  启动一个或多个已经被停止的容器</span></span><br><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<h2 id="暂停容器"><a href="#暂停容器" class="headerlink" title="暂停容器"></a>暂停容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"><span class="comment"># 常用参数说明</span></span><br><span class="line"><span class="comment"># -t : 停止之前等待多少秒，-t 10 表示10s后再停止</span></span><br></pre></td></tr></table></figure>

<h2 id="查看容器占用情况"><a href="#查看容器占用情况" class="headerlink" title="查看容器占用情况"></a>查看容器占用情况</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats [OPTIONS] [CONTAINER...]</span><br></pre></td></tr></table></figure>

<h2 id="查看容器底层信息"><a href="#查看容器底层信息" class="headerlink" title="查看容器底层信息"></a>查看容器底层信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect CONTAINER</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">编码格式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 14:52:29" itemprop="dateCreated datePublished" datetime="2023-04-02T14:52:29+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">编码格式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>码表中只有英文大小写字母、数字、美式标点符号等</p>
<p>每个字符占用1个字节，所有字符映射的二进制都为正数，因此有128个字符映射关系</p>
<h2 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h2><p>兼容 ASCII 码表，并加入了中文字符，码表中包含英文大小写字母、数字、美式标点符号占一个字节，中文占两个字节，中文映射的二进制都是负数，因此有 128× 128 &#x3D; 16384 个字符映射关系</p>
<h2 id="GBK-x2F-GB18030："><a href="#GBK-x2F-GB18030：" class="headerlink" title="GBK&#x2F;GB18030："></a>GBK&#x2F;GB18030：</h2><p>兼容 GB2312 码表，英文大小写字母、数字、美式标点符号占一个字节，中文占两个字节，第一个字节为负数，第二个字节为正数和负数，因为有 128× 256 &#x3D; 32768 个字符映射关系</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定</p>
<p>Unicode 给每个字符提供了一个唯一的数字，唯一数字称为码点（code point），其范围介乎 <code>0x0</code> 至 <code>0x10FFFF</code> 之间</p>
<p>码点有多种编码方式，称为 Unicode 转换格式，包括：</p>
<ul>
<li><p>UTF-8：8 位可变长度编码。它把一个码点映射至 1 至 4 个字节</p>
</li>
<li><p>UTF-16：16 位可变长度编码。它把一个码点映射至 1 至 2 个 16 位编码单元（即 2 至 4 个字节）</p>
</li>
<li><p>UTF-32：32 位固定长度编码。它直接把码点映射至单个 32 位编码单元（即 4 字节）</p>
</li>
</ul>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度，编码规则如下：</p>
<ul>
<li><p>对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题</p>
</li>
<li><p>对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充</p>
</li>
</ul>
<p>UTF-8完全直接兼容ASCII码，而非不完全间接兼容</p>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>Unicode 的字符不是一次性定义的，而是分区定义</p>
<p>目前，一共有 17 个平面，每个平面可以存放 65536 个字符</p>
<p>UTF-16 编码规则：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节</p>
<p>UTF-16 的编码长度要么是 2 个字节（<code>U+0000</code> 到 <code>U+FFFF</code>），要么是 4 个字节（<code>U+010000</code> 到 <code>U+10FFFF</code>）</p>
<p>ASCII 字符经过 UTF-16 编码后得到的两个字节，高字节始终是 <code>0x00</code>，很多 C 语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本</p>
<h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>UTF-32 每个码点固定使用四个字节表示，字节内容一一对应码点</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>字节序就是字节之间的顺序，当传输或者存储时，如果数字超过 1 个字节，需要指定字节间的顺序</p>
<p>字节序一般分为大端字节序或小端字节序</p>
<p>UCS 规范建议我们在传输字节流前，先传输字符 <code>ZERO WIDTH NO-BREAK SPACE</code>，接收者收到 FEFF，就表明这个字节流是 Big-Endian 的，如果收到 FFFE ，就表明这个字节流是 Little-Endian 的</p>
<p>字符 <code>ZERO WIDTH NO-BREAK SPACE</code> 就是 byte order mark，简称 BOM</p>
<p>字节序问题仅存在于某种编码下计算机一次读取字符大小大于一个字节的时候</p>
<p>因为 UTF-8 是单字节码元，所以是字节顺序无关的，它的字节顺序在所有系统中都是一样的，其码元序列与字节序列(字节流)相同，因此它实际上并不需要字节顺序标记 BOM</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:35:40" itemprop="dateCreated datePublished" datetime="2023-04-01T16:35:40+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><p>排序算法的内存消耗：针对排序算法的空间复杂度，引入原地排序概念，即空间复杂度 O(1) 的排序算法</p>
</li>
<li><p>排序算法的稳定性：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变</p>
</li>
<li><p>有序度、逆序度：对于包含n个数据的数组，有 n! 种排列方式；有序度：数组中具有有序关系的元素对的个数(逆序数)；我们把完全有序的数组称为满有序度</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 有序元素对：a[i] &lt;= a[j]  i &lt; j</span><br><span class="line">// 完全有序的数组：有序度 n * (n - 1) / 2</span><br><span class="line">// 逆序元素对：a[i] &gt; a[j]  i &lt; j</span><br><span class="line">// 逆序度 = 满有序度 - 有序度</span><br></pre></td></tr></table></figure>
<p>排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/10.png" class="">

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据；每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它们交换；</p>
<p>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作</p>
<p>当某次冒泡操作没有进行数据交互时，说明已经排序完成了，可以不再继续冒泡操作了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubblesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j] &gt; v[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[j], v[j + <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>冒泡排序只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度为 O(1)，故是原地排序</p>
</li>
<li><p>冒泡排序在相邻两个元素大小相等时不做交换，所以相同大小的数据在排序前后不会改变顺序，故冒泡排序是稳定的排序算法</p>
</li>
<li><p>时间复杂度：平均时间复杂度 O(n^2)；要排序的数据是反序，则需要进行 n 次冒泡操作，所以最坏复杂度 O(n^2)；要排序的数据已经有序，则只需要进行一次冒泡操作，所以最好复杂度 O(n)</p>
</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/01.jpg" class="">

<p>我们将数组中的数据分为两个区间，已排序区间和未排序区间</p>
<p>插入排序的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序；重复这个过程，直到未排序区间中元素为空</p>
<p>初始已排序区间只有一个元素</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/02.jpg" class="">

<p>插入排序包含两种操作，元素的比较和元素的移动；对于一个给定的初始序列，移动操作的次数总是固定的，即逆序度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> tmp = v[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j + <span class="number">1</span>] &lt; v[j]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[j + <span class="number">1</span>], v[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>插入排序是原地排序</p>
</li>
<li><p>插入排序是稳定排序</p>
</li>
<li><p>复杂度：平均时间复杂度 O(n^2)；要排序的数据是反序，则最坏复杂度 O(n^2)；要排序的数据已经有序，则最好复杂度 O(n)</p>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序也分已排序区间和未排序区间，但选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾;每次操作确定一个元素的正确位置</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/03.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> pos = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; size; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j] &lt; v[pos]) &#123;</span><br><span class="line">				pos = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[i], v[pos]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>选择排序是原地排序</p>
</li>
<li><p>选择排序是稳定排序</p>
</li>
<li><p>复杂度：平均时间复杂度 O(n^2)，最好最坏复杂度都是 O(n^2)</p>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>核心思想就是分治，将一个大问题分解成小的子问题；使用递归来实现</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/04.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">merge</span>(v, start, mid);</span><br><span class="line">	<span class="built_in">merge</span>(v, mid + <span class="number">1</span>, end);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(end - start + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (k &lt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; mid + <span class="number">1</span> &amp;&amp; j &lt; end + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[i] &lt; v[j]) &#123;</span><br><span class="line">				tmp[k++] = v[i++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				tmp[k++] = v[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i &lt; mid + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (i &lt; mid + <span class="number">1</span>) &#123;</span><br><span class="line">				tmp[k++] = v[i++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; end + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; end + <span class="number">1</span>) &#123;</span><br><span class="line">				tmp[k++] = v[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> p = start; p &lt;= end; ++p) &#123;</span><br><span class="line">		v[p] = tmp[p - start];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">merge</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>归并排序是稳定排序</p>
</li>
<li><p>时间复杂度：递归时，把一个问题分解成多个子问题，那时间复杂度等于多个子问题的时间复杂度加上将多个子问题合并的时间复杂度；归并排序最好、最坏和平均时间复杂度都是 O(nlogn)</p>
</li>
<li><p>空间复杂度：归并排序的合并函数需要借助额外的存储空间，空间复杂度为 O(n)</p>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择中间任意一个数组作为 pivot（分区点）；遍历 p 到 r 之间的数据，将小于 pivot 的放左边，大于 pivot 的放右边，将 pivot 放中间</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/05.jpg" class="">

<p>原地分区过程：</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/06.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/07.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pos = start;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[i] &lt; v[end]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[pos++], v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(v[pos], v[end]);</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> p = <span class="built_in">partition</span>(v, start, end);</span><br><span class="line">	<span class="built_in">quicksort</span>(v, start, p - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quicksort</span>(v, p + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">quicksort</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>快排原地不稳定排序</p>
</li>
<li><p>空间复杂度 O(1)</p>
</li>
<li><p>当 pivot 选择合适，每次将区间分为大小相近的两个小区间，则快排最好时间复杂度是 O(nlogn)；当 pivot 选择不合适，每次分区得到的两个区间都不均等，需要进行 n 次分区操作，则最坏时间复杂度 O(n^2)，快排时间复杂度退化到 O(n^2)的概率非常小，可以通过合理的选择 pivot 来避免这种情况；平均时间复杂度是 O(nlogn)</p>
</li>
</ul>
<p>这种 O(n^2) 时间复杂度出现的主要原因还是因为我们分区点选得不够合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。改进方法：</p>
<ol>
<li><p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。但是，如果要排序的数组比较大，那三数取中可能就不够了，可能要五数取中或者十数取中</p>
</li>
<li><p>每次从要排序的区间中随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的</p>
</li>
</ol>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序时间复杂度非常稳定，是 O(nlogn)，并且还是原地排序算法</p>
<p>堆排序的过程大致分解成两个大的步骤，建堆和排序</p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>将数组原地建成一个堆，不借助另一个数组，在原数组上操作</p>
<ul>
<li><p>第一种方法：借助堆插入思路，假设堆中只包含一个数据，就是下标为 1 的数据；然后调用插入操作，将下标从 2 到 n 的数据依次插入到堆中；每个数据插入堆中，都是从下往上堆化</p>
</li>
<li><p>第二种方法：从后往前处理数组，每个数据都是从上往下堆化；因为叶子节点往下堆化只能跟自己比较，所以从第一个非叶子节点开始，即下标从 n&#x2F;2 开始到 1 的数据进行堆化，下标 n&#x2F;2+1 到 n 的节点都是叶子节点，不需要堆化；</p>
</li>
</ul>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/11.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/12.jpg" class="">

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>建堆结束之后，数组中的数据已经按照大顶堆的特性组织的；把数组中第一个元素跟最后一个元素交换，最大元素就放到了下标为 n 的位置，类似于删除堆顶元素操作；堆顶元素移除后把下标为 n 的元素放到堆顶，然后再堆化，以此类推完成排序</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/13.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1 从下往上</span></span><br><span class="line">	<span class="comment">//for (int i = 1; i &lt; n; ++i) &#123;</span></span><br><span class="line">	<span class="comment">//	int j = i;</span></span><br><span class="line">	<span class="comment">//	while (j &gt; 0) &#123;</span></span><br><span class="line">	<span class="comment">//		int p = (j - 1) / 2;</span></span><br><span class="line">	<span class="comment">//		if (v[p] &lt; v[j]) &#123;</span></span><br><span class="line">	<span class="comment">//			swap(v[p], v[j]);</span></span><br><span class="line">	<span class="comment">//			j = p;</span></span><br><span class="line">	<span class="comment">//		&#125;</span></span><br><span class="line">	<span class="comment">//		else break;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2 从上往下</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="type">int</span> j = i;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l = <span class="number">2</span> * j + <span class="number">1</span>, r = <span class="number">2</span> * j + <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (r &lt; n) &#123;</span><br><span class="line">				<span class="type">int</span> tmp;</span><br><span class="line">				<span class="keyword">if</span> (v[l] &lt; v[r]) tmp = r;</span><br><span class="line">				<span class="keyword">else</span> tmp = l;</span><br><span class="line">				<span class="keyword">if</span> (v[j] &lt; v[tmp]) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(v[j], v[tmp]);</span><br><span class="line">					j = tmp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (l &lt; n) &#123;</span><br><span class="line">				<span class="keyword">if</span> (v[j] &lt; v[l]) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(v[j], v[l]);</span><br><span class="line">					j = l;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="built_in">buildsort</span>(v, v.<span class="built_in">size</span>() - i);</span><br><span class="line">		<span class="built_in">swap</span>(v[size - <span class="number">1</span> - i], v[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与快排比较"><a href="#与快排比较" class="headerlink" title="与快排比较"></a>与快排比较</h3><ol>
<li><p>堆排序数据访问方式没有快排友好：堆排跳着访问数据，快排顺序访问数据，对CPU缓存不友好</p>
</li>
<li><p>对于同样的数据，在排序过程中，堆排数据交换次数多于快排</p>
</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>优先级队列</li>
</ul>
<p>优先级队列首先是一个队列，但出队的顺序不是先进先出，而是按照优先级，优先级最高的最先出队</p>
<p>一个堆可以看做一个优先级队列，往优先级队列中插入元素相当于往堆中插入一个元素，从优先级队列中取出有优先级最高的元素相当于取出堆顶元素</p>
<ul>
<li><p>求Top K</p>
</li>
<li><p>求中位数</p>
</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据在单独进行排序；桶内排完序之后再把每个桶里的数据按照顺序依次去除，组成的序列就是有序的了</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/08.jpg" class="">

<ul>
<li><p>在每个桶里进行快速排序</p>
</li>
<li><p>桶排序的时间复杂度接近 O(n)</p>
</li>
<li><p>桶排序对排序数据的要求非常苛刻：要排序的数据需要很容易地划分成 m 个桶，并且桶与桶之间有着天然的大小顺序，这样每个桶内的数据排序完后桶与桶之间的数据不需要再进行排序；数据在各个桶之间的分布是比较均匀的，在低端情况下会退化为 O(nlogn) 的排序</p>
</li>
<li><p>桶排序比较适合用于外部排序中，即数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中</p>
</li>
</ul>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><ul>
<li><p>当要排序 n 个数据，所处的范围并不大的时候，比如最大值为 k，我们就可以把数据划分 k 个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间</p>
</li>
<li><p>因为只涉及扫描遍历操作，所有时间复杂度是 O(n)</p>
</li>
<li><p>计数排序只能对非负整数排序；如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数</p>
</li>
</ul>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/09.jpg" class="">
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序对要排序的数据是有要求的，需要能分割出独立的位来比较，而且位之间有递进关系，如果高位的数据大则剩下地位则不需要比较；而且，每位的数据范围不能大，能采用线性排序算法来排序</p>
<h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><p>线性排序算法的时间复杂度底但适用场景比较特殊，不适合用于通用的排序算法；</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；但如果对大规模数据进行排序，时间复杂度为 O(nlogn) 的算法更加高效；所以一般首选时间复杂度为 O(nlogn) 的排序算法来实现排序函数</p>
<p>因为归并排序的控件复杂度为 O(n^2)，不是原地排序，所以一般采用快速排序算法</p>
<h3 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h3><p>快速排序在最坏情况下的时间复杂度为 O(n^2)，这种情况的出现原因主要是因为分区点的选择不够合理</p>
<p>最理想的分区点是：被区分点分开的两个分区中，数据的数据量差不多；为了提高地让每次分区都比较平均</p>
<ol>
<li><p>三数取中法，从区间的首、尾、中间分别取数，对比大小后取 3 个数的中间值作为分区点</p>
</li>
<li><p>随机法</p>
</li>
</ol>
<p>每次从要排序的区间中，随机选择一个元素作为分区点；虽然不能保证每次分区点都选的比较好，但是从概率的角度，平均情况下分区点事比较好的</p>
<h3 id="递归注意事项"><a href="#递归注意事项" class="headerlink" title="递归注意事项"></a>递归注意事项</h3><p>递归要警惕堆栈溢出，递归过深而堆栈过小，导致堆栈溢出</p>
<ol>
<li><p>限制递归深度</p>
</li>
<li><p>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/" class="post-title-link" itemprop="url">贪心算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:34:39" itemprop="dateCreated datePublished" datetime="2023-04-01T16:34:39+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下期望值最大；这类问题首先联想到贪心算法</p>
<p>大部分情况下，能用贪心解决的问题，得出结果的正确性是显而易见的；但实际上，贪心并不总能给出全局最优解</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="分糖果："><a href="#分糖果：" class="headerlink" title="分糖果："></a>分糖果：</h3><p>m 个糖果和 n 个孩子，m &lt; n，把糖果分给这些孩子吃，所以糖果只能分配给一部分孩子</p>
<p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm</p>
<p>每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足，小孩需求分别是 g1，g2，g3，……，gn</p>
<p>如何分配糖果，能尽可能满足最多数量的孩子？可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的</p>
<p>这个问题的限制值就是糖果个数 m，对于一个孩子来说，如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子</p>
<p>所以可以从需求小的孩子开始分配糖果，满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p>
<h3 id="钱币找零"><a href="#钱币找零" class="headerlink" title="钱币找零"></a>钱币找零</h3><p>假设有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。用这些钱来支付 K 元，最少要用多少张纸币呢？</p>
<p>肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐</p>
<p>在贡献相同期望值（纸币数目）的情况下，希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路</p>
<ol start="3">
<li>区间覆盖</li>
</ol>
<p>假设有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]</p>
<p>从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？     </p>
<p>这个问题的解决思路是这样的：假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上</p>
<p>按照起始端点从小到大的顺序对这 n 个区间排序；每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:29:19" itemprop="dateCreated datePublished" datetime="2023-04-01T16:29:19+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>动态规划适合用来求解最优问题，比如最大值、最小值等，它可以显著地降低时间复杂度，提高代码的执行效率</p>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><h3 id="回溯算法实现"><a href="#回溯算法实现" class="headerlink" title="回溯算法实现"></a>回溯算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxW = INT_MIN;  <span class="comment">// 结果放到 maxW 中</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">5</span>] &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;  <span class="comment">// 物品重量</span></span><br><span class="line"><span class="type">int</span> w = <span class="number">9</span>;  <span class="comment">// 背包承受最大重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cw)</span>  <span class="comment">// 现考察是否装入第 i(0-4) 个物品，目前背包重量 cw</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == <span class="number">5</span>)  <span class="comment">// cw == w 表示装满了  i == 5 表示物品都考擦完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW)   maxW = cw;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f</span>(i + <span class="number">1</span>, cw);  <span class="comment">// 选择不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + weight[i] &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(i + <span class="number">1</span>, cw + weight[i]);  <span class="comment">// 装第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01.jpg" class="">

<p>递归树中的每个节点表示一种状态，用 (i, cw) 表示</p>
<p>从递归树中可以发现有些子问题是重复的，比如 f(2, 2) 和 f(3, 4) 都被重复计算了两次，通过记录 f(i, cw) 的值避免冗余计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxW = INT_MIN;  <span class="comment">// 结果放到 maxW 中</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">5</span>] &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;  <span class="comment">// 物品重量</span></span><br><span class="line"><span class="type">int</span> w = <span class="number">9</span>;  <span class="comment">// 背包承受最大重量</span></span><br><span class="line"><span class="type">bool</span> mem[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cw)</span>  <span class="comment">// 现考察是否装入第 i(0-4) 个物品，目前背包重量 cw</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == <span class="number">5</span>)  <span class="comment">// cw == w 表示装满了  i == 5 表示物品都考擦完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW)   maxW = cw;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mem[i][cw])  <span class="keyword">return</span>;  <span class="comment">// 重复状态</span></span><br><span class="line">    mem[i][cw] = <span class="literal">true</span>;  <span class="comment">// 记录 (i, cw) 这个状态</span></span><br><span class="line">    <span class="built_in">f</span>(i + <span class="number">1</span>, cw);  <span class="comment">// 选择不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + weight[i] &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(i + <span class="number">1</span>, cw + weight[i]);  <span class="comment">// 装第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; e : mem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; l : e)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划实现"><a href="#动态规划实现" class="headerlink" title="动态规划实现"></a>动态规划实现</h3><p>把整个求解过程分为 n 个阶段，每个阶段决策一个物品是否放入背包中，每个物品决策（放入或不放入）完之后，背包的物品重量会有多种情况</p>
<p>把每一层重复的状态合并，只记录不同的状态，然后基于上一层的状态集合来推导一下层的状态集合；通过合并每一层重复的状态，就保证了每一层不同状态的个数都不会冲过 w 个（w 表示背包的承载重量）</p>
<p>用二维数组 <code>bool states[n][w + 1]</code> 来记录每层可以达到的不同状态</p>
<p>第 0 个（下标从 0 开始编号）物品重量是 2，要么装入要么不装入，对应背包两种状态，用 <code>states[0][0] = true, states[0][2] = true</code> 来表示这两种状态</p>
<p>第 1 个物品重量是 2，基于之前的背包状态，在决策完这个物品之后会有 3 个不同的状态，分别是 0(0 + 0), 2(0 + 2, 2 + 0), 4(2 + 2)，用 <code>states[1][0] = true, states[1][2] = true, states[0][4] = true</code></p>
<p>以此类推，考察完所有物品后，整个状态数组都计算好了，只需要在最后一层找一个值为 true 的最接近 w 的值，就是背包中物品重量的最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">bool</span> ** states, <span class="type">int</span> n, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    states = <span class="keyword">new</span> <span class="type">bool</span>* [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        states[i] = <span class="keyword">new</span> <span class="type">bool</span> [w + <span class="number">1</span>];  <span class="comment">// w + 1 个状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行的数据要特殊处理，可利用哨兵优化</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w)    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不把第 i 个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j])    states[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把第 i 个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w - weight[i]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j])    states[i][j + weight[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = w; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n - <span class="number">1</span>][i] == <span class="literal">true</span>)    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/02.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/03.jpg" class="">

<p>动态规划思想：把问题分解为多个阶段，每个阶段对应一个决策，记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合去推导下一个阶段的状态集合，动态地往前推进</p>
<p>尽管动态规划的执行效率比较高，但上面的代码需要额外申请一个 n * (w + 1) 的二维数组，空间消耗比较大（空间换时间）</p>
<p>实际上只需要一个大小为 w + 1的一维数组，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">bool</span> * states, <span class="type">int</span> n, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    states = <span class="keyword">new</span> <span class="type">bool</span> [w + <span class="number">1</span>];  <span class="comment">// w + 1 个状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行的数据要特殊处理，可利用哨兵优化</span></span><br><span class="line">    states[<span class="number">0</span>] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w)    states[weight[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一维数组只需要考虑放入背包的情况</span></span><br><span class="line">        <span class="comment">// 把第 i 个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = w - weight[i]; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里是从大到小来处理的</span></span><br><span class="line">            <span class="comment">// 如果换成 j 从小到大，会出现 for 循环里重复计算</span></span><br><span class="line">            <span class="keyword">if</span>(states[j])    states[j + weight[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = w; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[i] == <span class="literal">true</span>)    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包问题升级"><a href="#0-1-背包问题升级" class="headerlink" title="0-1 背包问题升级"></a>0-1 背包问题升级</h2><p>引入物品价值，对于一组不同重量、不同价值、不可分割的物品，如何选择物品在满足重量限制的前提下装入物品总价值最大</p>
<h3 id="回溯实现"><a href="#回溯实现" class="headerlink" title="回溯实现"></a>回溯实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxV = INT_MIN;  <span class="comment">// 最大价值</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">5</span>] &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;  <span class="comment">// 物品重量</span></span><br><span class="line"><span class="type">int</span> value[<span class="number">5</span>] &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> w = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cw, <span class="type">int</span> cv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv &gt; maxV)   maxV = cv;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f</span>(i + <span class="number">1</span>, cw, cv);  <span class="comment">// 不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + weight[i] &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(i + <span class="number">1</span>, cw + weight[i], cv + value[i]);  <span class="comment">// 选择第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/04.jpg" class="">

<p>对于 f(2, 2, 4) 和 f(2, 2, 3)，在背包物品重量一样的情况下 f(2, 2, 4) 的物品总价值更大，故可以舍弃 f(2, 2, 3)，只需要沿着 f(2, 2, 4) 的决策路线继续往下决策</p>
<p>也就是说对于 (i, cw) 相同的不同状态只保留 cv 最大的，继续递归处理，但回溯的办法就没办法适应了</p>
<h3 id="动态规划实现-1"><a href="#动态规划实现-1" class="headerlink" title="动态规划实现"></a>动态规划实现</h3><p>把整个求解过程分为 n 个阶段，每个阶段决策一个物品是否放入到背包中，每个阶段决策完之后，背包中的物品的总重量以及总价值会有多种情况，即会达到多种不同状态</p>
<p>用二维数组 <code>states[n][w + 1]</code> 来记录每层可达到的不同状态，数组存储的值是当前状态对应的最大总价值，把每层 (i, cw) 重复状态合并，只记录 cv 值最大的状态，然后基于这些状态来推导下一层的状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> * <span class="title">knapsack</span><span class="params">(<span class="type">int</span> ** states, <span class="type">int</span> n, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 states 数组</span></span><br><span class="line">    <span class="type">int</span> * states = <span class="keyword">new</span> <span class="type">int</span> * [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        states[i] = <span class="keyword">new</span> <span class="type">int</span> [w + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            states[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊处理第一行</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w)    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不选择第 i 个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>)   states[i][j] = states[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择第 i 个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w - weight[i]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = states[i - <span class="number">1</span>][j] + value[i];</span><br><span class="line">                <span class="keyword">if</span>(v &gt; states[i][j + weight[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    states[i][j + weight[i]] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> maxv = <span class="number">-1</span>;  <span class="comment">// 计算的最大价值</span></span><br><span class="line">    <span class="type">int</span> minm = <span class="number">0</span>;  <span class="comment">// 最大价值对应的最大质量</span></span><br><span class="line">    <span class="keyword">for</span>(; minm &lt;= w; ++minm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n - <span class="number">1</span>][minm] &gt; maxv)    maxv = states[n - <span class="number">1</span>][minm];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反推组合情况</span></span><br><span class="line">    <span class="comment">// 在满足重量的情况下，价值都是 -1</span></span><br><span class="line">    <span class="keyword">if</span>(minm == w + <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line">    <span class="comment">// 在满足重量情况下，最大价值为 maxv，质量为 maxm</span></span><br><span class="line">    <span class="type">bool</span> * ans = <span class="keyword">new</span> <span class="type">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i&gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要选择第 i 个物品，必须重量不超标</span></span><br><span class="line">        <span class="comment">// 并且在决策第 i - 1 个物品后质量为 maxm - weight[i]</span></span><br><span class="line">        <span class="keyword">if</span>(maxm - weight[i] &gt;= <span class="number">0</span> &amp;&amp; states[i - <span class="number">1</span>][maxm- weight[i]] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxm = maxm - weight[i];</span><br><span class="line">            ans[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 states 数组倒推组合情况；由于状态 (i, j) 只能从 (i - 1, j) 或 (i - 1, j - value[i]) 两个状态推导过来，所以只需检查者两个状态是否可达</p>
<h2 id="什么问题适合用动态规划"><a href="#什么问题适合用动态规划" class="headerlink" title="什么问题适合用动态规划"></a>什么问题适合用动态规划</h2><h3 id="一个模型三个特征"><a href="#一个模型三个特征" class="headerlink" title="一个模型三个特征"></a>一个模型三个特征</h3><ul>
<li><p>多阶段决策最优解模型：解决问题的过程中需要经历多个决策阶段，每个决策阶段都对应一组状态；然后寻找一组决策序列，经过这组序列能够产生最终期望求解的最优解</p>
</li>
<li><p>最优子结构特征：问题最优解包含子问题的最优解，即可以通过子问题的最优解推导出问题的最优解，即后面阶段的状态可以通过前面阶段的状态推导出来</p>
</li>
<li><p>无后效性特征：一是在推导后面阶段状态时只关心前面阶段的状态值，而不关心这个状态时怎么一步一步推导出来的；二是某阶段一旦确定，就不受后面阶段的决策影响</p>
</li>
<li><p>重复子问题特征：不同决策序列，到达某个相同的阶段时，可能会产生重复的状态</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假设有个 n * n 的矩阵 w[n][n]，矩阵存储的都是正整数，棋子从起始位置运动到终止位置，每次只能向下移动一格或向右移动一格，把经过的格子的数字加起来作为路径的长度，求最短路径</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/05.jpg" class="">

<ul>
<li><p>一个模型：从 (0, 0) 到 (n - 1, n - 1) 总共要走 2 * (n - 1) 步，也就对应了 2 * (n - 1) 个阶段，并且每个阶段对应一个状态集合；状态定义为 min_dist(i, j)，i 表示行，j 表示列，min_dist(i, j) 的值表示从 (0, 0) 到 (i, j) 的最短路径长度</p>
</li>
<li><p>用回溯算法求解的递归树中有重复节点。即存在重复子问题特征</p>
</li>
<li><p>走到 (i, j) 时只能通过 (i - 1, j) 或 (i, j - 1) 这两个位置移动过来，所以计算 (i, j) 状态时只需要关心 (i - 1, j) 和 (i, j - 1) 两个位置对应的状态，并不关心是通过怎么样的路线到达这两个位置的，所以前面阶段的状态确定之后不会被后面阶段的决策改变。即存在无后效性特征</p>
</li>
<li><p>min_dist(i ,j) 可以通过 min_dist(i, j - 1) 和 min_dist(i - 1, j) 推导出来。即存在最优子结构特征</p>
</li>
</ul>
<h2 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h2><h3 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h3><p>一般能用动态规划解决的问题，都能通过回溯算法的暴力搜索解决，所以可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点然后对应画出递归树</p>
<p>第一种思路：找到重复子问题后，可以直接用回溯加记录的方法避免重复子问题，在执行效率上跟动态规划没有区别</p>
<p>第二种思路：状态转移表法，先画出一个状态表，一般是二维的，可以把它想象成二维数组，包括行、列、值三个变量；根据决策的先后过程从前往后，根据递推关系，分阶段填入状态表中的每个状态；最后将递推填表的过程翻译成代码；如果问题的状态比较复杂需要很多变量表示，可以将状态表写成高维的</p>
<p>回溯算法解决最短路径问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mindist = INT_MAX;  <span class="comment">// 最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// w[n][n] 数组表示格子的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minDist</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> dist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里已经到达了 n - 1, n - 1 这个位置</span></span><br><span class="line">    <span class="comment">// 与 mindist 比较的值是传入的 dist</span></span><br><span class="line">    <span class="keyword">if</span>(i == n &amp;&amp; j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist &gt; mindist)    mindist = dist;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往下走</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; n)   <span class="built_in">minDist</span>(i + <span class="number">1</span>, j, dist + w[i][j]);</span><br><span class="line">    <span class="comment">// 往右走</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; n)   <span class="built_in">minDist</span>(i, j + <span class="number">1</span>, dist + w[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/06.jpg" class="">

<p>虽然递归树中没有重复的 (i, j, dist), 但 (i, j) 有重复的，对于重复的 (i, j) 只保存 dist 最小的</p>
<p>画出二维状态表，行、列表示棋子所在的位置，值表示最短路径</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/07.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/08.jpg" class="">

<p>根据填表过程，翻译成代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义状态矩阵</span></span><br><span class="line">    <span class="type">int</span> ** states = <span class="keyword">new</span> <span class="type">int</span> * [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        states[i] = <span class="keyword">new</span> <span class="type">int</span> [n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化第一行第一列</span></span><br><span class="line">    <span class="type">int</span> sum_row = <span class="number">0</span>, sum_col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum_row += w[<span class="number">0</span>][i];</span><br><span class="line">        sum_col += w[i][<span class="number">0</span>];</span><br><span class="line">        states[<span class="number">0</span>][i] = sum_row;</span><br><span class="line">        states[i][<span class="number">0</span>] = sum_col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            states[i][j] = <span class="built_in">min</span>(states[i - <span class="number">1</span>][j], states[i][j - <span class="number">1</span>]) + w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> states[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h3><p>状态转移方程法类似递归，需要分析某个问题如果通过子问题来递归求解，也就是最优子结构，根据最优子结构写出递归公式，即状态转移方程</p>
<p>有两种代码实现方法，一种是递归加记录，一种是迭代递推</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line"><span class="built_in">min_dist</span>(i, j) = w[i][j] + <span class="built_in">min</span>(<span class="built_in">min_dist</span>(i, j - <span class="number">1</span>), <span class="built_in">min_dist</span>(i - <span class="number">1</span>, j))</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归加记录实现</span></span><br><span class="line"><span class="type">int</span> mem[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDist</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)    <span class="keyword">return</span> w[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(mem[i][j] &gt; <span class="number">0</span>)   <span class="keyword">return</span> mem[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minLeft = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)  minLeft =<span class="built_in">minDist</span>(i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> minUp = INT_MAX;</span><br><span class="line">    <span class="built_in">IF</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>)  minUp = <span class="built_in">minDist</span>(i - <span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line">    mem[i][j] = w[i][j] + <span class="built_in">min</span>(minLeft, minUp);</span><br><span class="line">    <span class="keyword">return</span> mem[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/" class="post-title-link" itemprop="url">分治算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:28:38" itemprop="dateCreated datePublished" datetime="2023-04-01T16:28:38+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>分治算法的核心思想其实就是四个字，分而治之，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解</p>
<p>分治算法一般都比较适合用递归来实现</p>
<p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>
<ol>
<li><p>分解：将原问题分解成一系列子问题</p>
</li>
<li><p>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</p>
</li>
<li><p>合并：将子问题的结果合并成原问题</p>
</li>
</ol>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ul>
<li><p>原问题与分解成的小问题具有相同的模式</p>
</li>
<li><p>原问题分解成的子问题可以独立求解，子问题之间没有相关性</p>
</li>
<li><p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解</p>
</li>
<li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BD%8D%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BD%8D%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">位操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:27:34" itemprop="dateCreated datePublished" datetime="2023-04-01T16:27:34+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="英文字符转小写"><a href="#英文字符转小写" class="headerlink" title="英文字符转小写"></a>英文字符转小写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">(<span class="string">&#x27;A&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="英文字符转大写"><a href="#英文字符转大写" class="headerlink" title="英文字符转大写"></a>英文字符转大写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;b&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">(<span class="string">&#x27;B&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;d&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">(<span class="string">&#x27;D&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="消除数字的二进制最后一个-1"><a href="#消除数字的二进制最后一个-1" class="headerlink" title="消除数字的二进制最后一个 1"></a>消除数字的二进制最后一个 1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t = n &amp; (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入一个无符号整数，返回二进制中 1 的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>(<span class="type">unsigned</span> <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断一个数是不是 2 的指数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/" class="post-title-link" itemprop="url">二分搜索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:24:16" itemprop="dateCreated datePublished" datetime="2023-04-01T16:24:16+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-05 17:48:30" itemprop="dateModified" datetime="2023-06-05T17:48:30+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>每次通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到查找的元素，或者区间被缩小为 0</p>
<p>时间复杂度 O(logn)</p>
<ul>
<li>二分查找依赖的是顺序表，简单说是数组</li>
</ul>
<p>其他数据结构比如链表，是不能进行二分查找的，主要原因是二分查找需要按照下标随机访问元素，数组按下标随机访问数据的时间复杂度是O(1)，而链表随机访问时间复杂度是O(n)，所以如果数据使用链表存储，二分查找的时间复杂度就会变得很高</p>
<ul>
<li><p>二分查找针对的是有序数据</p>
</li>
<li><p>数据量太小不适合二分查找</p>
</li>
</ul>
<p>如果数据量很小，顺序遍历就足够了；只有数据量比较大的时候，二分查找的优势才会比较明显</p>
<p>但如果数据之前的比较操作耗时，不管数据量大小，都推荐适用二分查找</p>
<ul>
<li>数据量太大也不适合二分查找</li>
</ul>
<p>二分查找的底层依赖数组这种数据结构，而数组为了支持随机访问的特性，需要内存空间的连续，对内存的要求比较苛刻</p>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [left, right) 左闭右开区间</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最小的一个 l 使得 g(x) 为 true</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 写成 （left + right) / 2 有可能溢出，故写成这个形式</span></span><br><span class="line">      <span class="comment">// 可选</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">f</span>(mid))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">g</span>(mid))  <span class="comment">//  g(x) 在序列上右边全是 true，左边全是 false </span></span><br><span class="line">      &#123;</span><br><span class="line">          right = mid;  <span class="comment">// [left, mid)</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          left = mid + <span class="number">1</span>;  <span class="comment">// [mid + 1, right)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;  <span class="comment">// 这里的 left 有数组越界的可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/28/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/30/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chaxxro</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
