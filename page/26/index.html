<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chaxxro.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="好记性不如烂键盘">
<meta property="og:type" content="website">
<meta property="og:title" content="也无风雨也无晴">
<meta property="og:url" content="https://chaxxro.github.io/page/26/index.html">
<meta property="og:site_name" content="也无风雨也无晴">
<meta property="og:description" content="好记性不如烂键盘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chaxxro">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaxxro.github.io/page/26/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/26/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>也无风雨也无晴</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">也无风雨也无晴</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chaxxro</p>
  <div class="site-description" itemprop="description">好记性不如烂键盘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">378</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E8%A1%A8%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E8%A1%A8%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">表数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:16:54" itemprop="dateCreated datePublished" datetime="2023-04-09T15:16:54+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一个 InnoDB 表包含表结构定义和数据</p>
<p>每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中</p>
<p>一个表单独存储为一个文件更容易管理，在不需要这个表时通过 drop table 命令，系统就会直接删除这个文件</p>
<h2 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h2><p>删除某行数据时，InnoDB 引擎只会把记录标记为删除，之后要再插入一个记录时，可能会复用这个位置，磁盘文件的大小并不会因为删除而缩小</p>
<p>同理，删掉一个数据页上的所有记录，整个数据页都可以被复用</p>
<p>但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据，而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置</p>
<p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用</p>
<p>如果用 delete 命令把整个表的数据删除，所有的数据页都会被标记为可复用，但是磁盘上文件不会变小</p>
<p>不止是删除数据会造成空洞，插入数据也会；如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂</p>
<img src="/2023/04/09/MySql-%E8%A1%A8%E6%95%B0%E6%8D%AE/01.png" class="">

<p>更新索引上的值，可以理解为删除一个旧的值，再插入一个新值</p>
<h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的</p>
<p>可以使用 alter table A engine&#x3D;InnoDB 命令来重建表，该命令执行流程为新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中；这个临时表 B 不需要手动创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作；数据搬运过程中，有新的数据要写入到表 A 的话，就会造成数据丢失</p>
<p>MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化</p>
<ol>
<li><p>建立一个临时文件，扫描表 A 主键的所有数据页</p>
</li>
<li><p>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中</p>
</li>
<li><p>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态</p>
</li>
<li><p>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件</p>
</li>
<li><p>用临时文件替换表 A 的数据文件</p>
</li>
</ol>
<p>由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表 A 做增删改操作</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:16:18" itemprop="dateCreated datePublished" datetime="2023-04-09T15:16:18+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer，对 sort_buffer 中的数据按照 <code>order by</code> 字段做快速排序</p>
<p>按字段排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size</p>
<p>sort_buffer_size 就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序</p>
<p>内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法，将需要排序的数据分成 number_of_tmp_files 份，每一份单独排序后存在这些临时文件中，然后把这 nnumber_of_tmp_files 个有序文件再合并成一个有序的大文件</p>
<p>sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大</p>
<h2 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h2><p>如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差</p>
<p>如果排序的单行长度太大，放入 sort_buffer 的字段就只有要排序的列和主键 id，但此时排序的结果就因为少了字段的值，不能直接返回，而是排序后再根据主键 id 从原表中取出所有字段并返回</p>
<p>MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到相应字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-mvcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-mvcc/" class="post-title-link" itemprop="url">mvcc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:14:20" itemprop="dateCreated datePublished" datetime="2023-04-09T15:14:20+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>MVCC 是一种多版本读写并发控制机制，是 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 READ COMMIITTED 和 REPEATABLE READ 这两种隔离级别</p>
<p>MVCC 通过保存数据在某个时间点的快照来实现的；每行数据都存在一个版本，对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以不加锁（除非使用 <code>SELECT ... FOR UPDATE</code> 强行加锁）</p>
<ul>
<li><p>通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力</p>
</li>
<li><p>降低了死锁的概率，因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行</p>
</li>
<li><p>解决了一致性读的问题，MVCC 都是快照读，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果</p>
</li>
</ul>
<h2 id="事务版本号"><a href="#事务版本号" class="headerlink" title="事务版本号"></a>事务版本号</h2><p>每次事务开启前都会从数据库获得一个自增长的事务 ID，可以从事务 ID 判断事务的执行先后顺序</p>
<h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到 Undo log 里，当事务进行回滚时可以通过 Undo log 里的日志进行数据还原</p>
<ul>
<li><p>保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 Undo log 的数据进行恢复</p>
</li>
<li><p>通过读取 Undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本</p>
</li>
</ul>
<p>存储数据表的 B+ 树节点总是只保留最新的数据，而老版本的数据被放在 Undo log 里，并且以指针的形式关联起来，形成一个链表；查询时会在 B+ 树查找后多引入一个链表查询，但是清理废弃数据时会比较简单，只要把 Undo log 找到一个合适的位置一刀切了即可</p>
<h2 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h2><p>MySQL 会为每一行真实数据记录添加两三个隐藏的字段，分别为 row_id、transaction_id 和 roll_pointer</p>
<ul>
<li><p>row_id：非必需隐藏字段；如果表中有自定义的主键或者有 Unique 键，就不会添加 row_id 字段，如果两者都没有，MySQL 会自动添加 row_id 字段</p>
</li>
<li><p>transaction_id：必需隐藏字段；代表这一行数据由哪个事务 id 创建</p>
</li>
<li><p>roll_pointer：必需隐藏字段；回滚指针，指向这行数据上一个版本在 Undo log 的地址</p>
</li>
</ul>
<img src="/2023/04/09/MySql-mvcc/01.png" class="">

<p>对于事务 id，只有执行 insert&#x2F;update&#x2F;delete 才会产生事务 id，只执行 select 则没有事务 id</p>
<img src="/2023/04/09/MySql-mvcc/02.png" class="">

<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>READ COMMITTED 和 REPEATABLE READ 这两个事务隔离级别都要保证读到的数据是其他事务已经提交的，但是还是有一定的区别，最核心的问题就在于到底可以读取这个数据的哪个版本</p>
<p>ReadView 机制只在 Read Committed 和 Repeatable Read 隔离级别下生效，所以只有这两种隔离级别才有 MVCC</p>
<h3 id="ReadView-组成"><a href="#ReadView-组成" class="headerlink" title="ReadView 组成"></a>ReadView 组成</h3><p>ReadView 包含四个比较重要的内容：</p>
<ul>
<li><p>m_ids：表示在生成 ReadView 时，系统中活跃的事务 id 集合</p>
</li>
<li><p>min_trx_id：表示在生成 ReadView 时，系统中活跃的最小事务 id，也就是 m_ids 中的最小值</p>
</li>
<li><p>max_trx_id：表示在生成 ReadView 时，系统应该分配给下一个事务的 id</p>
</li>
<li><p>creator_trx_id：表示生成该 ReadView 的事务 id</p>
</li>
</ul>
<h3 id="ReadView-用法"><a href="#ReadView-用法" class="headerlink" title="ReadView 用法"></a>ReadView 用法</h3><p>有了 ReadView，根据相关信息则可以判断版本信息：</p>
<ul>
<li><p>如果被访问的版本的 trx_id 和 ReadView 中的 creator_trx_id 相同，就意味着当前版本就是由当前事务创建的，可以读出来</p>
</li>
<li><p>如果被访问的版本的 trx_id 小于 ReadView 中的 min_trx_id，表示生成该版本的事务在创建 ReadView 的时候已经提交了，所以该版本可以读出来</p>
</li>
<li><p>如果被访问版本的 trx_id 大于或等于 ReadView 中的 max_trx_id 值，说明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被读出来</p>
</li>
<li><p>如果生成被访问版本的 trx_id 在 min_trx_id 和 max_trx_id 之间，那就需要判断下 trx_id 在不在 m_ids 中；如果在，说明创建 ReadView 的时候，生成该版本的事务还是活跃的（没有被提交），该版本不可以被读出来；如果不在，说明创建 ReadView 的时候，生成该版本的事务已经被提交了，该版本可以被读出来</p>
</li>
<li><p>如果某个数据的最新版本不可以被读出来，就顺着 roll_pointer 找到该数据的上一个版本，继续做如上的判断</p>
</li>
</ul>
<h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p>更新数据都是先读后写的，且只能读当前的值，称为当前读</p>
<p>除了 <code>update</code> 语句外，<code>select</code> 语句如果加锁，也是当前读</p>
<h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h3><p>每次读取数据都会创建 ReadView</p>
<h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>事务启动时创建 ReadView，整个事务期间都使用同一个 ReadView</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` ( </span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    `k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<img src="/2023/04/09/MySql-mvcc/03.png" class="">

<h3 id="事务启动时机"><a href="#事务启动时机" class="headerlink" title="事务启动时机"></a>事务启动时机</h3><p><code>begin/start transaction</code> 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动</p>
<p>如果想要马上启动一个事务，可以使用 <code>start transaction with consistent snapshot</code> 这个命令</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>事务 C 没有显式地使用 <code>begin/commit</code>，表示这个 <code>update</code> 语句本身就是一个事务，语句完成的时候会自动提交</p>
<p>事务 B 在更新了行之后查询</p>
<p>事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后</p>
<p>事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>做如下假设：</p>
<ul>
<li><p>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99</p>
</li>
<li><p>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务</p>
</li>
<li><p>三个事务开始前，(1,1）这一行数据的 transaction_id 是 90</p>
</li>
</ul>
<p>事务 A 的 m_ids 是[99,100]，事务 B 的 m_ids 是[99,100,101], 事务 C 的 m_ids 是[99,100,101,102]</p>
<img src="/2023/04/09/MySql-mvcc/04.png" class="">

<p>第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候这个数据的最新版本的 transaction_id 是 102，而 90 这个版本已经成为了历史版本</p>
<p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候这个数据的最新版本 transaction_id 是 101，而 102 又成为了历史版本</p>
<p>事务 A 读数据时，它的 m_ids 是 [99,100]，它的读数据流程：</p>
<ol>
<li><p>找到 (1,3) 的时候，判断出 transaction_id &#x3D; 101，比 100 大，不可见</p>
</li>
<li><p>接着，找到上一个历史版本，transaction_id &#x3D; 102，比 100 大，不可见</p>
</li>
<li><p>接着，找到上一个历史版本，一看 transaction_id &#x3D; 90，比99小，可见</p>
</li>
</ol>
<p>当事务 B 要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了，因此，事务 B 此时的 <code>set k=k+1</code> 是在（1,2）的基础上进行的操作</p>
<p>在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 transaction_id 是 101；在执行事务 B 查询语句的时候，一看自己的版本号是 101 和最新数据的版本号相同，可以直接使用，所以查询得到的 k 的值是 3</p>
<p>如果把事务 A 的查询语句 select * from t where id&#x3D;1 修改一下，加上 lock in share mode 或 for update，也都可以读到版本号是 101 的数据，返回的 k 的值是 3</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>假设事务 C 不是马上提交的，而是变成了下面的事务 C’</p>
<img src="/2023/04/09/MySql-mvcc/05.png" class="">

<p>事务 C’ 的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了</p>
<p>虽然事务 C’ 还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本</p>
<p>事务 C’ 没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’ 释放这个锁，才能继续它的当前读</p>
<img src="/2023/04/09/MySql-mvcc/06.png" class="">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">日志系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:12:20" itemprop="dateCreated datePublished" datetime="2023-04-09T15:12:20+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>更新流程涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）</p>
<p>redo log 是 InnoDB 引擎特有的日志，Server 层的日志称为 binlog</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log，并更新内存，这个时候更新就算完成了</p>
<p>InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</p>
<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么redo log 总共就可以记录 4GB 的操作，从头开始写，写到末尾就又回到开头循环写</p>
<img src="/2023/04/09/MySql-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/01.png" class="">

<p>write pos 是当前记录的位置，一边写一边后移；checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件</p>
<p>write pos 和 checkpoint 之间的部分是可以用来记录新的操作；如果 write pos 追上 checkpoint，这时候不能再执行新的更新，需要把 checkpoint 推进一下</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失</p>
<p>redo log 的写入拆成了两个步骤：prepare 和 commit，这就是两阶段提交，是为了让 redo log 和 binlog 之间的逻辑一致</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，会出现一定问题</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>与 redo log 区别：</p>
<ol>
<li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</p>
</li>
<li><p>redo log 是物理日志，记录的是在某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑</p>
</li>
<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的</p>
</li>
</ol>
<p>对于 SQL 语句 <code>update T set c=c+1 where ID=2</code>：</p>
<ol>
<li><p>执行器先找引擎取 <code>ID=2</code> 这一行</p>
</li>
<li><p>如果 <code>ID=2</code> 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上 1，再调用引擎接口写入这行新数据</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，然后告知执行器执行完成，此时 redo log 处于 prepare 状态</p>
</li>
<li><p>执行器生成这个操作的 binlog，并把 binlog 写入磁盘</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成</p>
</li>
</ol>
<img src="/2023/04/09/MySql-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/01.jpg" class="">

<p>MySQL 以 binlog 的写入与否作为事务是否成功的标记</p>
<h2 id="奔溃恢复规则"><a href="#奔溃恢复规则" class="headerlink" title="奔溃恢复规则"></a>奔溃恢复规则</h2><p>redo log 和 binlog 有一个共同的数据字段，叫 XID</p>
<p>崩溃恢复的时候，会按顺序扫描 redo log：</p>
<ol>
<li><p>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交</p>
</li>
<li><p>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务；binlog 无记录，回滚事务；binlog 有记录，提交事务</p>
</li>
</ol>
<p>先写 redo log 后写 binlog：假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启；由于 bin log 日志没有修改记录，使用 redo log + bin log 恢复的数据就是数据库旧的数据</p>
<p>先写 bin log 后写 redo log：假设在 bin log 写完，redo log 还没有完成的时候，MySQL 进程异常重启</p>
<p>binlog 写入后会被从库（或者用这个 binlog 恢复出来的库）使用，保证主库和备库的数据就一致性</p>
<h2 id="binlog-完整性"><a href="#binlog-完整性" class="headerlink" title="binlog 完整性"></a>binlog 完整性</h2><p>MySQL 引入 binlog-checksum 参数，用来验证 binlog 内容的正确性</p>
<h2 id="binlog-相比-redo-log-优越性"><a href="#binlog-相比-redo-log-优越性" class="headerlink" title="binlog 相比 redo log 优越性"></a>binlog 相比 redo log 优越性</h2><ol>
<li><p>redo log 是循环写，写到末尾是要回到开头继续写的，这样历史日志没法保留，redo log 也就起不到归档的作用</p>
</li>
<li><p>MySQL 系统依赖于 binlog，系统高可用的基础，就是 binlog 复制</p>
</li>
</ol>
<h2 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h2><p>redo log buffer 就是一块内存，用来先存 redo 日志的</p>
<p>真正把日志写到 redo log 文件，是在执行 commit 语句的时候做的</p>
<p>事务执行过程中不会主动去刷盘，以减少不必要的 IO 消耗，但是可能会出现被动写入磁盘，比如内存不够、其他事务提交等情况</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E9%94%81/" class="post-title-link" itemprop="url">锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:10:29" itemprop="dateCreated datePublished" datetime="2023-04-09T15:10:29+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁，MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock，让整个库处于只读状态，修改表的线程全部阻塞</p>
<p>全局锁的典型使用场景是，做全库逻辑备份，也就是把整库每个表都 select 出来存成文本</p>
<p>让整个库只可读，有一些隐患：</p>
<ul>
<li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</p>
</li>
<li><p>如果在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟</p>
</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁 MDL</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁的语法是 lock tables … read&#x2F;write，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放</p>
<p>lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</p>
<h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><p>MDL(meta data lock) 不需要显式使用，在访问一个表的时候会被自动加上</p>
<p>MDL 的作用是，保证读写的正确性；如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的</p>
<p>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁</p>
<ul>
<li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查</p>
</li>
<li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性</p>
</li>
</ul>
<p>申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁；一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作</p>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放</p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁就是针对数据表中行记录的锁</p>
<p>两阶段锁协议：InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放</p>
<p>尽量将并发度高的行，放在事务的最后进行执行</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态</p>
<p>InnoDB 能检测到死锁的循环依赖并立即返回一个错误，主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的；每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁；每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作</p>
<p>解决方法：</p>
<ul>
<li><p>尽量使用较低的隔离级别</p>
</li>
<li><p>设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会</p>
</li>
<li><p>显示加锁时，一次性请求足够级别的锁</p>
</li>
<li><p>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表</p>
</li>
<li><p>尽量用相等条件访问数据</p>
</li>
<li><p>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率</p>
</li>
<li><p>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率</p>
</li>
<li><p>用分布式事务锁或者使用乐观锁</p>
</li>
</ul>
<h2 id="InnoDB-的行锁与表锁"><a href="#InnoDB-的行锁与表锁" class="headerlink" title="InnoDB 的行锁与表锁"></a>InnoDB 的行锁与表锁</h2><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的；只有通过索引条件检索数据，InnoDB 才使用行级锁，否则将使用表锁</p>
<p>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，因此虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的(查询非唯一索引时，非唯一索引可能对应多条聚簇索引，因此会锁住多行)；当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行</p>
<p>即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同的执行计划的代价来决定的。如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁</p>
<h2 id="InnoDB-锁算法"><a href="#InnoDB-锁算法" class="headerlink" title="InnoDB 锁算法"></a>InnoDB 锁算法</h2><h3 id="Record-lock"><a href="#Record-lock" class="headerlink" title="Record lock"></a>Record lock</h3><p>单个行记录上的锁；当查询的索引含有唯一属性时，使用 record lock；RC 级别使用该方式加锁</p>
<ul>
<li>使用聚簇索引等值查询</li>
</ul>
<img src="/2023/04/09/MySql-%E9%94%81/01.png" class="">

<ul>
<li>使用唯一索引等值查询</li>
</ul>
<img src="/2023/04/09/MySql-%E9%94%81/02.png" class="">

<h3 id="Gap-lock"><a href="#Gap-lock" class="headerlink" title="Gap lock"></a>Gap lock</h3><p>间隙锁，锁定一个索引范围（左开右开），不包括记录本身；设计的目的是为了阻止多个事务将记录插入到同一范围内，防止幻读的产生</p>
<ul>
<li>使用一般索引等值查询：不仅给相应索引和聚簇索引加 record lock，还要给索引间隙加 gap lock</li>
</ul>
<img src="/2023/04/09/MySql-%E9%94%81/03.png" class="">

<img src="/2023/04/09/MySql-%E9%94%81/04.png" class="">

<ul>
<li>无索引查询：将聚簇索引中的所有行以及间隙都锁起来，等于锁表了</li>
</ul>
<img src="/2023/04/09/MySql-%E9%94%81/05.png" class="">

<h3 id="Next-key-lock"><a href="#Next-key-lock" class="headerlink" title="Next-key lock"></a>Next-key lock</h3><p>record+gap 锁定一个范围，并包含记录本身；对于行的查询使用 next-key lock，解决幻读问题；把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住；当使用唯一索引且得到的结果只有 1 条则降级为 Record lock；RR 级别使用该方式加锁</p>
<img src="/2023/04/09/MySql-%E9%94%81/06.png" class="">

<h2 id="锁机制划分"><a href="#锁机制划分" class="headerlink" title="锁机制划分"></a>锁机制划分</h2><p>三种锁都分为共享读锁和排他写锁</p>
<h3 id="共享读锁"><a href="#共享读锁" class="headerlink" title="共享读锁"></a>共享读锁</h3><ul>
<li><p>持有读锁的会话可以读表，但不能写表</p>
</li>
<li><p>允许多个会话同时持有读锁</p>
</li>
<li><p>其他会话就算没有给表加读锁，也是可以读表的，但是不能写表</p>
</li>
<li><p>其他会话申请该表写锁时会阻塞，直到锁释放</p>
</li>
</ul>
<h3 id="排他写锁"><a href="#排他写锁" class="headerlink" title="排他写锁"></a>排他写锁</h3><ul>
<li><p>持有写锁的会话既可以读表，也可以写表</p>
</li>
<li><p>只有持有写锁的会话才可以访问该表，其他会话访问该表会被阻塞，直到锁释放</p>
</li>
<li><p>其他会话无论申请该表的读锁或写锁，都会阻塞，直到锁释放</p>
</li>
</ul>
<h2 id="隔离级别与锁"><a href="#隔离级别与锁" class="headerlink" title="隔离级别与锁"></a>隔离级别与锁</h2><ul>
<li><p>未提交读 READ UNCOMMITTED：读取数据不加共享锁</p>
</li>
<li><p>提交读 READ COMMITTED：读取数据加共享锁，操作结束后释放共享锁</p>
</li>
<li><p>可重复读 REPEATABLE READ：读取数据加共享锁，事务提交前不释放锁</p>
</li>
<li><p>可串行化 SERIALIZABLE：锁定整个范围的键并一直有锁，直到事务完成</p>
</li>
</ul>
<h2 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h2><ul>
<li><p>乐观锁：假设不会发生并发冲突不会上锁，只在提交操作时检查是否违反数据完整性；适用于多读的应用类型，这样可以提高吞吐量</p>
</li>
<li><p>悲观锁：假定会发生并发冲突，每次在拿数据的时候都会上锁，屏蔽一切可能违反数据完整性的操作；</p>
</li>
</ul>
<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><p>当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去；进程 A 等待进程 B 释放他的资源，B 又等待 A 释放他的资源，这样就互相等待就形成死锁</p>
<h2 id="表锁行锁与死锁"><a href="#表锁行锁与死锁" class="headerlink" title="表锁行锁与死锁"></a>表锁行锁与死锁</h2><p>MyISAM 中是不会产生死锁的，因为 MyISAM 总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在 InnoDB 中，锁是逐步获得的，就造成了死锁的可能</p>
<p>InnoDB 行锁并不是直接锁数据而是锁索引；索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条 SQL 语句操作了非主键索引，MySQL 就会先锁定该非主键索引，再锁定相关的主键索引</p>
<p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引；另一个锁定了非主键索引，在等待主键索引，这样就会发生死锁</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" class="post-title-link" itemprop="url">事务隔离</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:09:39" itemprop="dateCreated datePublished" datetime="2023-04-09T15:09:39+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一个不可分割的数据库操作序列，要么完全地执行，要么完全地不执行，是数据库并发控制得基本单位</p>
<p>通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠</p>
<p>一个逻辑工作单元要成为事务，必须满足所谓的 ACID 属性</p>
<ul>
<li><p>原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</p>
</li>
<li><p>一致性（Consistency）：一致性规定了事务提交前后，永远只可能存在事务提交前的状态和事务提交后的状态，从一个一致性的状态到另一个一致性状态，而不可能出现中间的过程态；事务的执行结果是量子化状态，而不是线性状态</p>
</li>
<li><p>隔离性（Isolation）：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离；多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果；当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间</p>
</li>
<li><p>持久性（Durability）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</p>
</li>
</ul>
<p>在 MySQL 中，事务支持是在引擎层实现的</p>
<h2 id="数据库并发操作带来的一致性问题"><a href="#数据库并发操作带来的一致性问题" class="headerlink" title="数据库并发操作带来的一致性问题"></a>数据库并发操作带来的一致性问题</h2><p>数据库事物无非两种：读取事物、修改事物</p>
<p>在没有事务隔离控制的时候，多个事务在同一时刻对同一数据的操作可能就会影响到最终期望的结果，通常有四种情况：</p>
<ul>
<li><p>脏写：一个事务的更新覆盖了另一个事务还没提交的更新（事务 A和 B 读入同一数据并修改，B 提交的结果破坏了 A 提交的结果，导致 A 的修改被丢失）</p>
</li>
<li><p>脏读：一个事务读取了另一个事物未提交的数据（事务 A 修改某一数据，并将其写回磁盘，事务 B 读取同一数据后，A 由于某种原因被撤销，这时 A 已修改过的数据恢复原值，B 读到的数据就与数据库中的数据不一致，则 B 读到的数据为脏数据）</p>
</li>
<li><p>不可重复读：一个事务两次读取同一个数据，两次读取的数据不一致（事务 A 读取某一数据后，事务 B 对其作了修改，当事务 A 再次读取数据时，得到与前一次不同的值；事务 A 按一定的条件从数据库中读取了某些数据后，事务 B 删除了其中部分记录，当 A 再次以相同条件读取时，发现某些记录消失了）</p>
</li>
<li><p>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据</p>
</li>
</ul>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点和脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰</p>
<ul>
<li><p>未提交读 READ UNCOMMITTED：最低的隔离级别，一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据；存在脏读（读到了脏数据）问题</p>
</li>
<li><p>提交读 READ COMMITTED：事务在提交之前，对其它事务是不可见的；解决了脏读的问题，但存在不可重复读（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题</p>
</li>
<li><p>可重复读 REPEATABLE READ：默认隔离等级，在同一事务中多次读取的数据是一致的；解决了脏读和不可重复读问题，存在幻读（在事务两次查询间隙，有其他事务又插入或删除了新的记录）问题</p>
</li>
<li><p>可串行化 SERIALIZABLE：通过对每个读的数据行加上共享锁，强制事务串行化执行，即一个事务一个事务挨个来执行，可以解决上述所有问题，隔离级别最高，牺牲了系统的并发性；可以解决并发事务的所有问题</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">基础结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:08:22" itemprop="dateCreated datePublished" datetime="2023-04-09T15:08:22+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="/2023/04/09/MySql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/01.png" class="">

<p>MySQL 可以分为 Server 层和存储引擎层两部分</p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</p>
<p>存储引擎层负责数据的存储和提取，其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h $ip -P $port -u $user -p</span><br></pre></td></tr></table></figure>

<p>客户端跟服务端通过 TCP 建立连接</p>
<p>如果用户名密码认证通过，连接器会到权限表里面查出客户端拥有的权限，之后这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</p>
<p>一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限；修改完成后，只有再新建的连接才会使用新的权限设置</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开，这个时间是由参数 wait_timeout 控制的，默认值是 8 小时</p>
<p>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p>
<p>全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了</p>
<p>解决方案：</p>
<ul>
<li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连</p>
</li>
<li><p>在 MySQL 5.7 之后的版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</p>
</li>
</ul>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL 查询缓存是用来缓存特定 Query 的整个结果集信息，且共享给所有客户端</p>
<p>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中</p>
<p>key 是查询的语句，value 是查询的结果，如果查询能够直接在这个缓存中找到 key，那么这个 value 通过权限验证后就可以直接返回给客户端</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段，执行完成后执行结果会被存入查询缓存中</p>
<p>只要有对一个表的更新，这个表上所有的查询缓存都会被清空，对于频繁更新的表，查询缓存是不适合的，而对于一些不常改变数据且有大量相同 SQL 查询的表，查询缓存会节约很大的性能</p>
<h3 id="命中条件"><a href="#命中条件" class="headerlink" title="命中条件"></a>命中条件</h3><ul>
<li><p>两个 SQL 语句，只要相差哪怕一个字符，那么这两个 SQL 将使用不同的 Cache 地址</p>
</li>
<li><p>如果表中任何数据或是结构发生改变更改了，那么使用这个表的所有缓存查询将不再有效</p>
</li>
<li><p>当某个表正在写入数据，则这个表的缓存将会处于失效状态；在 Innodb 中，如果某个事务修改了这张表，则这个表的缓存在事务提交前都会处于失效状态，在这个事务提交前，这个表的相关查询都无法被缓存</p>
</li>
<li><p><code>where</code> 条件中如包含任何一个不确定的函数将永远不会被 cache, 比如 <code>current_date</code>, <code>now</code> 等</p>
</li>
<li><p>太大的 result set 不会被 cache</p>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>MySQL Query Cache 使用内存池技术，自己管理内存释放和分配，而不是通过操作系统</p>
<p>query_cache_limit：可以缓存的单条查询的最大结果集的大小，默认值为 1MB</p>
<p>query_cache_min_res_unit：每次分配内存的最小空间大小，也就是用于缓存查询结果的最小内存空间的大小，默认值为 4KB</p>
<p>query_cache_size：可以使用的最大内存空间的大小，必须是 1024 的整数倍</p>
<ol>
<li><p>数据库启动时需要初始化查询缓存需要的内存，这时内存池是一个完整的空闲块，而这个空闲块的大小是 query_cache_size 的值减去用于维护元数据的数据结构所消耗的空间（约 40KB）</p>
</li>
<li><p>当有查询结果需要缓存的时候，MySQL 先从大的空闲块中申请 query_cache_min_res_unit 大小的内存用于存储结果</p>
</li>
<li><p>MySQL 逐步向数据块写入数据，若数据块全部使用完成后仍然有剩余的数据需要存储，那么将再次向空闲空间申请一个数据块，直到数据全部存储完成</p>
</li>
<li><p>当存储完成后申请的数据块还有部分剩余空间，那么这部分将被释放，并入到空闲内存部分</p>
</li>
</ol>
<p>并发插入和缓存失效都会导致内存碎片</p>
<h3 id="额外消耗"><a href="#额外消耗" class="headerlink" title="额外消耗"></a>额外消耗</h3><ul>
<li><p>读查询开始之前必须检查是否命中缓存</p>
</li>
<li><p>如果读查询可以缓存，那么执行完查询操作后，会把查询结果和查询语句写入缓存</p>
</li>
<li><p>当向某个表写入数据的时候，必须将这个表所有的缓存设置为失效，如果缓存空间很大，则消耗也会很大</p>
</li>
<li><p>对 InnoDB 表，当修改一个表时，设置了缓存失效，但是多版本特性会暂时将这修改对其他事务屏蔽，在这个事务提交之前，所有查询都无法使用缓存，直到这个事务被提交，所以长时间的事务，会大大降低查询缓存的命中</p>
</li>
</ul>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>对 SQL 语句做解析</p>
<p>词法分析 —&gt; 语法分析</p>
<p>词法分析：将 SQL 语句的字符串识别出来</p>
<p>语法分析：根据语法规则判断 SQL 语句是否满足语法</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p>
<p>对于查询不在表里的字段，在优化器时就会报错，优化器在做优化时会拿到表的信息，从而不需要后续打开表</p>
<p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句；在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少；扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断</p>
<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数；这个统计信息就是索引的区分度，一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数，称之为基数；基数越大，索引的区分度越好</p>
<p>MySQL 通过采样统计获得索引的基数；InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数；当变更的数据行数超过 1&#x2F;M 的时候，会自动触发重新做一次索引统计</p>
<p>对于由于索引统计信息不准确导致的慢查询问题，可以用 analyze table 来解决</p>
<p>优化器还会考虑非主键索引的回表查询代价</p>
<p>当使用排序时，选择排序字段可避免排序，因此优化器也会优先选择该字段</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>开始执行的时候，要先判断一下客户端对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误</p>
<p>如果查询没有命中索引：</p>
<ol>
<li><p>调用引擎接口取这个表的第一行，满足条件则放入结果集合中</p>
</li>
<li><p>调用引擎接口取下一行，重复相同逻辑，直到取到这个表的最后一行</p>
</li>
<li><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</p>
</li>
</ol>
<p>如果查询命中索引：</p>
<ol>
<li><p>调用引擎满足条件第一行的接口</p>
</li>
<li><p>循环调用满足条件下一行的接口</p>
</li>
</ol>
<h2 id="更新语句执行"><a href="#更新语句执行" class="headerlink" title="更新语句执行"></a>更新语句执行</h2><p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高</p>
<p>MySQL 使用 WAL 技术，其全称是 Write-Ahead Logging，它的关键点就是先写日志再写磁盘</p>
<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面并更新内存，这个时候更新就算完成了；InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:06:53" itemprop="dateCreated datePublished" datetime="2023-04-09T15:06:53+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="磁盘-IO-与索引"><a href="#磁盘-IO-与索引" class="headerlink" title="磁盘 IO 与索引"></a>磁盘 IO 与索引</h2><h3 id="磁盘-IO"><a href="#磁盘-IO" class="headerlink" title="磁盘 IO"></a>磁盘 IO</h3><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分</p>
<p>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，旋转延迟就是 1 &#x2F; 120 &#x2F; 2 &#x3D; 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5 + 4.17 &#x3D; 9ms左右</p>
<h3 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h3><p>当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内；当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到</p>
<p>每一次 IO 读取的数据我们称之为一页，一般为 4k 或 8k，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，B+ 树的一个节点存储在一页内</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>添加索引使得每次查找数据时的磁盘 IO 次数控制在一个很小的数量级，最好是常数数量级</p>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</p>
<p>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录 ID 的辅助数据结构</p>
<p>DB 在执行一条 Sql 语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度</p>
<p>优点：</p>
<ul>
<li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</p>
</li>
<li><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因</p>
</li>
<li><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</p>
</li>
<li><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</p>
</li>
<li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p>
</li>
<li><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间</p>
</li>
</ul>
<p>原则：</p>
<ul>
<li><p>在查询中很少使用或者参考的列不应该创建索引</p>
</li>
<li><p>只有很少数据值的列也不应该增加索引</p>
</li>
<li><p>定义为 text、image 和 bit 数据类型的列不应该增加索引</p>
</li>
<li><p>当修改性能远远大于检索性能时，不应该创建索引</p>
</li>
<li><p>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省索引空间</p>
</li>
<li><p>尽量的扩展索引，不要新建索引</p>
</li>
<li><p>定义有外键的数据列一定要建立索引</p>
</li>
</ul>
<p>实现：一般分为 B+ 树索引和哈希索引</p>
<ul>
<li><p>B+ 树是非线性结构，它的节点是天然有序的；hash 桶是线性结构，哈希表中多个数据在存储关系上是没有任务顺序关系的</p>
</li>
<li><p>哈希索引适合等值查询，无法进行范围查询和模糊查询；B+ 树索引可以进行等值、部分前缀、范围查询</p>
</li>
<li><p>B+ 树索引其非叶子节点均为 key 值，叶子节点是 key-data 键值对，叶子节点前后相连且有序</p>
</li>
<li><p>哈希索引 O(1) 在速度上毋庸置疑要快于 B+ 树近似 O(logn)，但哈希索引速度不稳定，当某个键值存在大量重复时效率极差</p>
</li>
<li><p>哈希索引无法利用索引完成排序</p>
</li>
<li><p>哈希索引不支持多列联合索引的最左匹配规则</p>
</li>
<li><p>哈希索引存储行指针，并通过开链的方式解决冲突</p>
</li>
<li><p>哈希索引没办法避免回表查询，B+ 树在聚簇索引和索引覆盖的情况下可以只通过索引查询</p>
</li>
</ul>
<h3 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h3><p>数据库索引都是存储在磁盘上的，当数据量比较大的时候，索引也会很大；当我们利用索引查询的时候，不能把索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页即对应着索引树的节点</p>
<p>磁盘 IO 次数由树的高度决定，因此不适合使用 BST 存储索引，因此需要使用更加矮胖的树结构</p>
<p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样</p>
<h2 id="AVL-树、RB-树、B-树和-B-树"><a href="#AVL-树、RB-树、B-树和-B-树" class="headerlink" title="AVL 树、RB 树、B 树和 B+ 树"></a>AVL 树、RB 树、B 树和 B+ 树</h2><p>大多数自平衡搜索树（如 AVL 树和 RB 树）都会假定所有数据都在主内存中，但我们必须考虑无法容纳在主内存中的大量数据。当键的数量很大时，将以块形式从磁盘读取数据，与主存储器访问时间相比，磁盘访问时间非常高。</p>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><p>自平衡二叉搜索树，树中任一节点的两个子树的高度差最大为 1，其查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(log n)</p>
<ul>
<li><p>具有二叉查找树的特点(左子树任一节点小于父节点，右子树任一节点大于父节点)，任何一个节点的左子树与右子树都是平衡二叉树</p>
</li>
<li><p>任一节点的左右子树高度差小于 1</p>
</li>
</ul>
<p>AVL 树通过旋转来调整平衡</p>
<h3 id="RB-树"><a href="#RB-树" class="headerlink" title="RB 树"></a>RB 树</h3><p>AVL 树比红黑树更加平衡，但 AVL 树可能在插入和删除过程中引起更多旋转；如果频繁的插入和删除，应首选 RB 树；如果插入和删除操作的频率较低，而搜索操作的频率较高，则 AVL 树应优先于红黑树</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>B 树叫平衡多路查找树，设计的主要思想是减少磁盘访问次数，大多数树操作(增、删、查、最大值、最小值等)都需要都需要 O(h) 磁盘访问，h 为树的高度。</p>
<p>通常，B 树节点的大小保持与磁盘块大小相等，由于 B 树的高度较低，因此与平衡的二叉搜索树（如AVL 树、RB 树等）相比，大多数操作的磁盘访问次数显著减少。</p>
<p>先定义一条数据记录为一个二元组 [key, data]，key 为记录的键值，对于不同数据记录，key 是互不相同的；data 为数据记录除 key 外的数据</p>
<ul>
<li><p>M 阶 B 树表示每个节点最多 M 个子树</p>
</li>
<li><p>每个非叶子节点由 n-1 个 key 和 n 个指针组成，其中 M&#x2F;2 &lt;&#x3D; n &lt;&#x3D; M，其中 M&#x2F;2 向上取整</p>
</li>
<li><p>每个叶子节点最少包含一个 key 和两个指针，最多包含 M-1 个 key 和 M 个指针，叶节点的指针均为 null</p>
</li>
<li><p>所有叶子节点都在同一层</p>
</li>
<li><p>key 和指针互相间隔，节点两端是指针</p>
</li>
<li><p>一个节点中的 key 从左到右非递减排列</p>
</li>
<li><p>每个指针要么为 null，要么指向另外一个节点</p>
</li>
<li><p>如果某个指针在节点 node 最左边且不为 null，则其指向节点的所有 key 小于 v_key1，其中 v_key1 为 node 的第一个 key 的值</p>
</li>
<li><p>如果某个指针在节点 node 最右边且不为 null，则其指向节点的所有 key 大于 v_key2，其中 v_key2 为 node 的最后一个 key 的值</p>
</li>
<li><p>如果某个指针在节点 node 的左右相邻 key 分别是 key_i 和 key_i+1 且不为 null，则其指向节点的所有 key 小于 v_key_i+1 且大于 v_key_i</p>
</li>
<li><p>每个节点都存储数据</p>
</li>
</ul>
<p>一颗 4 阶的 B 树，每个节点最多有 4 个子树、3 个 key，最少有 2 个子树、1 个 key</p>
<img src="/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/01.png" class="">

<h4 id="插入保持平衡"><a href="#插入保持平衡" class="headerlink" title="插入保持平衡"></a>插入保持平衡</h4><ul>
<li><p>首先考虑要插入的子树是否已经超出了关键字数的限制</p>
</li>
<li><p>超出的话，如果要插入的位置是叶子节点，就只能拆一个关键字添加到要插入位置的父节点</p>
</li>
<li><p>如果非叶子节点，就得从其他子树拆子树给新插入的元素做孩子</p>
</li>
</ul>
<h4 id="删除保持平衡"><a href="#删除保持平衡" class="headerlink" title="删除保持平衡"></a>删除保持平衡</h4><p>删除孩子后，父节点是否还满足子树 k 介于 M&#x2F;2 和 M 的条件，不满足就得从别的节点拆子树甚至修改相关子树结构来保持平衡</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>由于 B-Tree 的特性，在 B-Tree 中按 key 检索数据流程：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败</p>
<p>B 树的树内存储数据，因此查询单条数据的时候，B 树的查询效率不固定，最好的情况是 O(1)，所以做单一数据查询的时候，使用 B 树平均性能更好，在特定数据重复多次查询的场景中更加高效</p>
<p>由于 B 树中各节点之间没有指针相邻，因此 B 树不适合做一些数据遍历操作</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>与 B-Tree 相比，B+Tree 有以下不同点：</p>
<ul>
<li><p>n 个 key 对应 n 个指针 n 颗树，M&#x2F;2 &lt;&#x3D; n &lt;&#x3D; M</p>
</li>
<li><p>非叶子节点不存储 data，只存储 key；叶子节点不存储指针</p>
</li>
<li><p>所有叶子节点增加了一个链指针</p>
</li>
</ul>
<img src="/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/02.png" class="">

<p>B+ 树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定，所以在做单一数据的查询上，其平均性能并不如 B 树</p>
<p>B+ 树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得 B+ 树非常适合做范围查询</p>
<h3 id="选择-B-树"><a href="#选择-B-树" class="headerlink" title="选择 B+ 树"></a>选择 B+ 树</h3><ul>
<li><p>B 树只适合随机检索，而 B+ 树同时支持随机检索和顺序检索</p>
</li>
<li><p>B+ 树空间利用率更高，可减少 IO 次数，磁盘读写代价更低：B+ 树内部结点比 B 树小，一次性读入内存中可以查找的关键字也就越多，从而 IO 次数降低了</p>
</li>
<li><p>B+ 树的查询效率更加稳定</p>
</li>
<li><p>增删节点时，效率更高</p>
</li>
</ul>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul>
<li><p>主键索引：数据列不允许重复，不允许为 NULL，一个表只能有一个主键</p>
</li>
<li><p>唯一索引：数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引</p>
</li>
<li><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值</p>
</li>
<li><p>全文索引：基于相似度的查询，而不是原来的精确数值比较；<code>like + %</code> 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的；全文索引可能存在精度问题</p>
</li>
</ul>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>InnoDB 的 B+ Tree 可能存储的是整行数据，也有可能是主键的值</p>
<p>聚簇索引：在 InnoDB 里，索引 B+ Tree 的叶子节点存储了整行数据的是主键索引</p>
<p>非聚簇索引：索引 B+ Tree 的叶子节点存储了主键的值的是非主键索引</p>
<p>聚簇索引查询会更快，因为主键索引树的叶子节点直接就是我们要查询的整行数据了，而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值回表查询</p>
<h2 id="非主键索引存储的是主键索引值"><a href="#非主键索引存储的是主键索引值" class="headerlink" title="非主键索引存储的是主键索引值"></a>非主键索引存储的是主键索引值</h2><p>非主键索引直接存储数据的地址，会带来一些问题：</p>
<ol>
<li><p>数据库备份、迁移困难</p>
</li>
<li><p>插入、删除数据时，B+ 树可能发生分裂，导致物理地址变化</p>
</li>
<li><p>无法给物理地址加行级锁</p>
</li>
</ol>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>非主键索引并不一定都会回表查询</p>
<p>索引覆盖：当一个查询语句的执行只用从索引中就能够取得，则不必从数据表中读取</p>
<p>常见方法：对被查询的字段建立联合索引</p>
<h2 id="联合索引和最左前缀匹配"><a href="#联合索引和最左前缀匹配" class="headerlink" title="联合索引和最左前缀匹配"></a>联合索引和最左前缀匹配</h2><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>在创建多列索引时，根据业务需求，where 子句中使用最频繁的一列放在最左边，因为 MySQL 索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>当创建一个联合索引的时候，如 (key1,key2,key3)，相当于创建了 (key1)、(key1,key2) 和 (key1,key2,key3) 三个索引</p>
<p>&#x3D; 和 in 可以乱序，查询优化器会帮你优化成索引可以识别的形式</p>
<h3 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h3><p>匹配时会一直向右匹配直到遇到范围查询，范围列可以用到索引，但是范围列后面的列无法用到索引，即索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引</p>
<p>like 语句中通配符出现在开头则不能使用索引</p>
<p>如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描</p>
<p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>使用联合索引时，索引下推优化可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p>
<h2 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h2><p>当某个字段较大时，不适合做主键，会浪费大量磁盘空间，因此可以考虑在该字段设置唯一索引或普通索引</p>
<p>假设在 id 字段建立索引，执行 <code>select id from T where k=5</code></p>
<h3 id="查询区别"><a href="#查询区别" class="headerlink" title="查询区别"></a>查询区别</h3><p>先通过 B+ 树从树根开始，按层搜索到叶子节点，找到相应的数据页，然后可以认为在数据页内部通过二分法来定位记录</p>
<ul>
<li><p>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录</p>
</li>
<li><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索</p>
</li>
</ul>
<p>这两个的不同带来的性能差距是微乎其微</p>
<p>InnoDB 的数据是按数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB</p>
<p>因为引擎是按页读写的，当找到第一个的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的查找和判断下一条记录的操作，就只需要一次指针寻找和一次计算</p>
<p>如果第一个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，但这种情况概率很低</p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了</p>
<p>在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作</p>
<p>change buffer 是可以持久化的数据，在内存中有拷贝，也会被写入到磁盘上</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge</p>
<p>除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge；在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作</p>
<p>将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升；数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率</p>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束，必须要将数据页读入内存才能判断；如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了</p>
<p>因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用</p>
<p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大</p>
<p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大</p>
<p>对于更新的目标页在内存中：</p>
<ul>
<li><p>对于唯一索引来说，判断到没有冲突，插入这个值，语句执行结束</p>
</li>
<li><p>对于普通索引来说，插入这个值，语句执行结束</p>
</li>
</ul>
<p>此情况下，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间</p>
<p>对于更新的目标页不再内存中：</p>
<ul>
<li><p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束</p>
</li>
<li><p>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了</p>
</li>
</ul>
<p>change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的</p>
<p>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好</p>
<p>对于写完马上做查询的业务，即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程，这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价，change buffer 反而起到了副作用</p>
<h2 id="redo-log-和-change-buffer"><a href="#redo-log-和-change-buffer" class="headerlink" title="redo log 和 change buffer"></a>redo log 和 change buffer</h2><p>change buffer 和 redo log 颗粒度不一样</p>
<p>change buffer 只是针对如果更改的数据所在页不在内存中才暂时储存在 change buffer 中</p>
<p>redo log 会记录一个事务内进行数据更改的所有操作，即使修改的数据已经在内存中了，那也会记录下来</p>
<p>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）</p>
<p>change buffer 主要节省的则是随机读磁盘的 IO 消耗</p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>可以定义字符串的一部分作为索引</p>
<p>如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串</p>
<p>使用前缀索引后，可能会导致查询语句回表查询的次数变多</p>
<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</p>
<p>使用前缀索引用不上覆盖索引对查询性能的优化</p>
<p>在建立前缀索引时，区分度越高越好，可以通过 <code>select count(distinct key(n)) from T</code> 查看前缀长度的区分度</p>
<h2 id="索引使用场景"><a href="#索引使用场景" class="headerlink" title="索引使用场景"></a>索引使用场景</h2><ul>
<li><p>查询时，加速 SQL 执行效率</p>
</li>
<li><p>如果没有创建索引，排序时将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），非常影响性能；建立索引后，数据本身有序，可直接按照索引的顺序和映射关系逐条取出数据</p>
</li>
<li><p>提高 join 效率</p>
</li>
<li><p>索引覆盖</p>
</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul>
<li><p>如果查询条件用 or，必须 or 条件中的每个列都加上索引，否则无效</p>
</li>
<li><p>违反最左匹配原则，则不适用索引</p>
</li>
<li><p>like 语句中通配符出现在开头则不能使用索引</p>
</li>
<li><p>存在索引列的数据类型隐形转换，则不使用索引</p>
</li>
<li><p>where 字句里对索引列有数学运算或者使用函数，则不使用索引</p>
</li>
<li><p>mysql 优化器觉得全表扫描更快时，则不适用索引</p>
</li>
</ul>
<h2 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h2><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护</p>
<ul>
<li><p>页分裂：插入情况下，如果所在数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去；页分裂除了影响分类，还影响数据页利用率</p>
</li>
<li><p>页合并：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并</p>
</li>
</ul>
<p>自增主键是指自增列上定义的主键，在建表语句中一般这么定义 <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code></p>
<p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值</p>
<p>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂，而业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高</p>
<p>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p>
<p>从性能和存储空间方面考量，自增主键往往是更合理的选择</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%96%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%96%E5%8A%A8/" class="post-title-link" itemprop="url">数据库抖动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:04:51" itemprop="dateCreated datePublished" datetime="2023-04-09T15:04:51+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>InnoDB 在处理更新语句的时候，只做了写 redo log 一个磁盘操作，在更新内存写完 redo log 后，就返回给客户端，本次更新成功</p>
<p>把内存里的数据写入磁盘的过程称为 flush</p>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为脏页；内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为干净页；不论是脏页还是干净页，都在内存中</p>
<ul>
<li>当 InnoDB 的 redo log 写满了，这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写；checkpoint 推进需将对应的脏页 flush 进磁盘</li>
</ul>
<img src="/2023/04/09/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%96%E5%8A%A8/01.jpg" class="">

<ul>
<li><p>当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用；如果淘汰的是脏页，就要先将脏页写到磁盘；如果脏页没刷，直接淘汰，虽然可以依靠 redo log 恢复到最新状态，但是 redo Log 就成了唯一的依靠了，唯一的依靠就不能随便擦除，会制约 redo log 的擦除</p>
</li>
<li><p>系统要合理地安排时间，见缝插针地找时间，只要有机会就刷一点脏页</p>
</li>
<li><p>MySQL 正常关闭，会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快</p>
</li>
</ul>
<h2 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>redo log 写满了，要 flush 脏页，这种情况是 InnoDB 要尽量避免的；整个系统就不能再接受更新了，所有的更新都必须堵住</p>
<p>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</p>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>内存不够用了，要先将脏页写到磁盘</p>
<p>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：还没有使用的、使用了并且是干净页、使用了并且是脏页</p>
<p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少</p>
<p>当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页，这时候只能把最久不使用的数据页从内存中淘汰掉</p>
<p>如果要淘汰的是一个干净页，就直接释放出来复用</p>
<p>如果是脏页就必须先刷到磁盘，变成干净页后才能复用</p>
<p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长</p>
<h2 id="刷脏页的控制策略"><a href="#刷脏页的控制策略" class="headerlink" title="刷脏页的控制策略"></a>刷脏页的控制策略</h2><p>要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快</p>
<p>在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个邻居也带着一起刷掉；而且这个把邻居拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-count%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-count%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">count 函数分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:02:27" itemprop="dateCreated datePublished" datetime="2023-04-09T15:02:27+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-16 20:41:49" itemprop="dateModified" datetime="2023-06-16T20:41:49+08:00">2023-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在不同的 MySQL 引擎中，<code>count(*)</code> 有不同的实现方式</p>
<ol>
<li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 <code>count(*)</code> 的时候会直接返回这个数，效率很高</p>
</li>
<li><p>InnoDB 执行 <code>count(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</p>
</li>
</ol>
<p>InnoDB 中即使是在同一个时刻的多个查询，由于多版本并发控制 MVCC 的原因，InnoDB 表应该返回多少行也是不确定的</p>
<p>假设表 t 中现在有 10000 条记录，设计三个用户并行的会话：</p>
<ul>
<li><p>会话 A 先启动事务并查询一次表的总行数</p>
</li>
<li><p>会话 B 启动事务，插入一行后记录后，查询表的总行数</p>
</li>
<li><p>会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数</p>
</li>
</ul>
<img src="/2023/04/09/MySql-count%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/01.png" class="">

<p>因此对于 <code>count(*)</code> 请求来说，InnoDB 只能把数据一行一行地读出依次判断，可见的行才能够用于计算表的总行数</p>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值，所以普通索引树比主键索引树小很多；对于 <code>count(*)</code> 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此 MySQL 优化器会找到最小的那棵树来遍历</p>
<h2 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h2><p><code>count()</code> 是一个聚合函数，对于返回的结果集，一行行地判断，如果 <code>count</code> 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值</p>
<p>对于 <code>count(主键 id)</code> 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加</p>
<p>对于 <code>count(1)</code> 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加</p>
<p><code>count(1)</code> 执行得要比 <code>count(主键 id)</code> 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作</p>
<p>按照效率排序的话，<code>count(字段)</code> &lt; <code>count(主键 id)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code>，所以建议尽量使用 <code>count(*)</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/25/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/38/">38</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/27/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chaxxro</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
