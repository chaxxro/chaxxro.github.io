<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chaxxro.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="好记性不如烂键盘">
<meta property="og:type" content="website">
<meta property="og:title" content="也无风雨也无晴">
<meta property="og:url" content="https://chaxxro.github.io/page/27/index.html">
<meta property="og:site_name" content="也无风雨也无晴">
<meta property="og:description" content="好记性不如烂键盘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chaxxro">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaxxro.github.io/page/27/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/27/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>也无风雨也无晴</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">也无风雨也无晴</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chaxxro</p>
  <div class="site-description" itemprop="description">好记性不如烂键盘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">383</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" class="post-title-link" itemprop="url">事务隔离</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:09:39" itemprop="dateCreated datePublished" datetime="2023-04-09T15:09:39+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一个不可分割的数据库操作序列，要么完全地执行，要么完全地不执行，是数据库并发控制得基本单位</p>
<p>通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠</p>
<p>一个逻辑工作单元要成为事务，必须满足所谓的 ACID 属性</p>
<ul>
<li><p>原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</p>
</li>
<li><p>一致性（Consistency）：一致性规定了事务提交前后，永远只可能存在事务提交前的状态和事务提交后的状态，从一个一致性的状态到另一个一致性状态，而不可能出现中间的过程态；事务的执行结果是量子化状态，而不是线性状态</p>
</li>
<li><p>隔离性（Isolation）：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离；多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果；当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间</p>
</li>
<li><p>持久性（Durability）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</p>
</li>
</ul>
<p>在 MySQL 中，事务支持是在引擎层实现的</p>
<h2 id="数据库并发操作带来的一致性问题"><a href="#数据库并发操作带来的一致性问题" class="headerlink" title="数据库并发操作带来的一致性问题"></a>数据库并发操作带来的一致性问题</h2><p>数据库事物无非两种：读取事物、修改事物</p>
<p>在没有事务隔离控制的时候，多个事务在同一时刻对同一数据的操作可能就会影响到最终期望的结果，通常有四种情况：</p>
<ul>
<li><p>脏写：一个事务的更新覆盖了另一个事务还没提交的更新（事务 A和 B 读入同一数据并修改，B 提交的结果破坏了 A 提交的结果，导致 A 的修改被丢失）</p>
</li>
<li><p>脏读：一个事务读取了另一个事物未提交的数据（事务 A 修改某一数据，并将其写回磁盘，事务 B 读取同一数据后，A 由于某种原因被撤销，这时 A 已修改过的数据恢复原值，B 读到的数据就与数据库中的数据不一致，则 B 读到的数据为脏数据）</p>
</li>
<li><p>不可重复读：一个事务两次读取同一个数据，两次读取的数据不一致（事务 A 读取某一数据后，事务 B 对其作了修改，当事务 A 再次读取数据时，得到与前一次不同的值；事务 A 按一定的条件从数据库中读取了某些数据后，事务 B 删除了其中部分记录，当 A 再次以相同条件读取时，发现某些记录消失了）</p>
</li>
<li><p>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据</p>
</li>
</ul>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点和脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰</p>
<ul>
<li><p>未提交读 READ UNCOMMITTED：最低的隔离级别，一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据；存在脏读（读到了脏数据）问题</p>
</li>
<li><p>提交读 READ COMMITTED：事务在提交之前，对其它事务是不可见的；解决了脏读的问题，但存在不可重复读（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题</p>
</li>
<li><p>可重复读 REPEATABLE READ：默认隔离等级，在同一事务中多次读取的数据是一致的；解决了脏读和不可重复读问题，存在幻读（在事务两次查询间隙，有其他事务又插入或删除了新的记录）问题</p>
</li>
<li><p>可串行化 SERIALIZABLE：通过对每个读的数据行加上共享锁，强制事务串行化执行，即一个事务一个事务挨个来执行，可以解决上述所有问题，隔离级别最高，牺牲了系统的并发性；可以解决并发事务的所有问题</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">基础结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:08:22" itemprop="dateCreated datePublished" datetime="2023-04-09T15:08:22+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="/2023/04/09/MySql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/01.png" class="">

<p>MySQL 可以分为 Server 层和存储引擎层两部分</p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</p>
<p>存储引擎层负责数据的存储和提取，其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h $ip -P $port -u $user -p</span><br></pre></td></tr></table></figure>

<p>客户端跟服务端通过 TCP 建立连接</p>
<p>如果用户名密码认证通过，连接器会到权限表里面查出客户端拥有的权限，之后这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</p>
<p>一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限；修改完成后，只有再新建的连接才会使用新的权限设置</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开，这个时间是由参数 wait_timeout 控制的，默认值是 8 小时</p>
<p>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p>
<p>全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了</p>
<p>解决方案：</p>
<ul>
<li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连</p>
</li>
<li><p>在 MySQL 5.7 之后的版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</p>
</li>
</ul>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL 查询缓存是用来缓存特定 Query 的整个结果集信息，且共享给所有客户端</p>
<p>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中</p>
<p>key 是查询的语句，value 是查询的结果，如果查询能够直接在这个缓存中找到 key，那么这个 value 通过权限验证后就可以直接返回给客户端</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段，执行完成后执行结果会被存入查询缓存中</p>
<p>只要有对一个表的更新，这个表上所有的查询缓存都会被清空，对于频繁更新的表，查询缓存是不适合的，而对于一些不常改变数据且有大量相同 SQL 查询的表，查询缓存会节约很大的性能</p>
<h3 id="命中条件"><a href="#命中条件" class="headerlink" title="命中条件"></a>命中条件</h3><ul>
<li><p>两个 SQL 语句，只要相差哪怕一个字符，那么这两个 SQL 将使用不同的 Cache 地址</p>
</li>
<li><p>如果表中任何数据或是结构发生改变更改了，那么使用这个表的所有缓存查询将不再有效</p>
</li>
<li><p>当某个表正在写入数据，则这个表的缓存将会处于失效状态；在 Innodb 中，如果某个事务修改了这张表，则这个表的缓存在事务提交前都会处于失效状态，在这个事务提交前，这个表的相关查询都无法被缓存</p>
</li>
<li><p><code>where</code> 条件中如包含任何一个不确定的函数将永远不会被 cache, 比如 <code>current_date</code>, <code>now</code> 等</p>
</li>
<li><p>太大的 result set 不会被 cache</p>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>MySQL Query Cache 使用内存池技术，自己管理内存释放和分配，而不是通过操作系统</p>
<p>query_cache_limit：可以缓存的单条查询的最大结果集的大小，默认值为 1MB</p>
<p>query_cache_min_res_unit：每次分配内存的最小空间大小，也就是用于缓存查询结果的最小内存空间的大小，默认值为 4KB</p>
<p>query_cache_size：可以使用的最大内存空间的大小，必须是 1024 的整数倍</p>
<ol>
<li><p>数据库启动时需要初始化查询缓存需要的内存，这时内存池是一个完整的空闲块，而这个空闲块的大小是 query_cache_size 的值减去用于维护元数据的数据结构所消耗的空间（约 40KB）</p>
</li>
<li><p>当有查询结果需要缓存的时候，MySQL 先从大的空闲块中申请 query_cache_min_res_unit 大小的内存用于存储结果</p>
</li>
<li><p>MySQL 逐步向数据块写入数据，若数据块全部使用完成后仍然有剩余的数据需要存储，那么将再次向空闲空间申请一个数据块，直到数据全部存储完成</p>
</li>
<li><p>当存储完成后申请的数据块还有部分剩余空间，那么这部分将被释放，并入到空闲内存部分</p>
</li>
</ol>
<p>并发插入和缓存失效都会导致内存碎片</p>
<h3 id="额外消耗"><a href="#额外消耗" class="headerlink" title="额外消耗"></a>额外消耗</h3><ul>
<li><p>读查询开始之前必须检查是否命中缓存</p>
</li>
<li><p>如果读查询可以缓存，那么执行完查询操作后，会把查询结果和查询语句写入缓存</p>
</li>
<li><p>当向某个表写入数据的时候，必须将这个表所有的缓存设置为失效，如果缓存空间很大，则消耗也会很大</p>
</li>
<li><p>对 InnoDB 表，当修改一个表时，设置了缓存失效，但是多版本特性会暂时将这修改对其他事务屏蔽，在这个事务提交之前，所有查询都无法使用缓存，直到这个事务被提交，所以长时间的事务，会大大降低查询缓存的命中</p>
</li>
</ul>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>对 SQL 语句做解析</p>
<p>词法分析 —&gt; 语法分析</p>
<p>词法分析：将 SQL 语句的字符串识别出来</p>
<p>语法分析：根据语法规则判断 SQL 语句是否满足语法</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p>
<p>对于查询不在表里的字段，在优化器时就会报错，优化器在做优化时会拿到表的信息，从而不需要后续打开表</p>
<p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句；在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少；扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断</p>
<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数；这个统计信息就是索引的区分度，一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数，称之为基数；基数越大，索引的区分度越好</p>
<p>MySQL 通过采样统计获得索引的基数；InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数；当变更的数据行数超过 1&#x2F;M 的时候，会自动触发重新做一次索引统计</p>
<p>对于由于索引统计信息不准确导致的慢查询问题，可以用 analyze table 来解决</p>
<p>优化器还会考虑非主键索引的回表查询代价</p>
<p>当使用排序时，选择排序字段可避免排序，因此优化器也会优先选择该字段</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>开始执行的时候，要先判断一下客户端对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误</p>
<p>如果查询没有命中索引：</p>
<ol>
<li><p>调用引擎接口取这个表的第一行，满足条件则放入结果集合中</p>
</li>
<li><p>调用引擎接口取下一行，重复相同逻辑，直到取到这个表的最后一行</p>
</li>
<li><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</p>
</li>
</ol>
<p>如果查询命中索引：</p>
<ol>
<li><p>调用引擎满足条件第一行的接口</p>
</li>
<li><p>循环调用满足条件下一行的接口</p>
</li>
</ol>
<h2 id="更新语句执行"><a href="#更新语句执行" class="headerlink" title="更新语句执行"></a>更新语句执行</h2><p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高</p>
<p>MySQL 使用 WAL 技术，其全称是 Write-Ahead Logging，它的关键点就是先写日志再写磁盘</p>
<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面并更新内存，这个时候更新就算完成了；InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:06:53" itemprop="dateCreated datePublished" datetime="2023-04-09T15:06:53+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="磁盘-IO-与索引"><a href="#磁盘-IO-与索引" class="headerlink" title="磁盘 IO 与索引"></a>磁盘 IO 与索引</h2><h3 id="磁盘-IO"><a href="#磁盘-IO" class="headerlink" title="磁盘 IO"></a>磁盘 IO</h3><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分</p>
<p>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，旋转延迟就是 1 &#x2F; 120 &#x2F; 2 &#x3D; 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5 + 4.17 &#x3D; 9ms左右</p>
<h3 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h3><p>当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内；当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到</p>
<p>每一次 IO 读取的数据我们称之为一页，一般为 4k 或 8k，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，B+ 树的一个节点存储在一页内</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>添加索引使得每次查找数据时的磁盘 IO 次数控制在一个很小的数量级，最好是常数数量级</p>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</p>
<p>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录 ID 的辅助数据结构</p>
<p>DB 在执行一条 Sql 语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度</p>
<p>优点：</p>
<ul>
<li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</p>
</li>
<li><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因</p>
</li>
<li><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</p>
</li>
<li><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</p>
</li>
<li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p>
</li>
<li><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间</p>
</li>
</ul>
<p>原则：</p>
<ul>
<li><p>在查询中很少使用或者参考的列不应该创建索引</p>
</li>
<li><p>只有很少数据值的列也不应该增加索引</p>
</li>
<li><p>定义为 text、image 和 bit 数据类型的列不应该增加索引</p>
</li>
<li><p>当修改性能远远大于检索性能时，不应该创建索引</p>
</li>
<li><p>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省索引空间</p>
</li>
<li><p>尽量的扩展索引，不要新建索引</p>
</li>
<li><p>定义有外键的数据列一定要建立索引</p>
</li>
</ul>
<p>实现：一般分为 B+ 树索引和哈希索引</p>
<ul>
<li><p>B+ 树是非线性结构，它的节点是天然有序的；hash 桶是线性结构，哈希表中多个数据在存储关系上是没有任务顺序关系的</p>
</li>
<li><p>哈希索引适合等值查询，无法进行范围查询和模糊查询；B+ 树索引可以进行等值、部分前缀、范围查询</p>
</li>
<li><p>B+ 树索引其非叶子节点均为 key 值，叶子节点是 key-data 键值对，叶子节点前后相连且有序</p>
</li>
<li><p>哈希索引 O(1) 在速度上毋庸置疑要快于 B+ 树近似 O(logn)，但哈希索引速度不稳定，当某个键值存在大量重复时效率极差</p>
</li>
<li><p>哈希索引无法利用索引完成排序</p>
</li>
<li><p>哈希索引不支持多列联合索引的最左匹配规则</p>
</li>
<li><p>哈希索引存储行指针，并通过开链的方式解决冲突</p>
</li>
<li><p>哈希索引没办法避免回表查询，B+ 树在聚簇索引和索引覆盖的情况下可以只通过索引查询</p>
</li>
</ul>
<h3 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h3><p>数据库索引都是存储在磁盘上的，当数据量比较大的时候，索引也会很大；当我们利用索引查询的时候，不能把索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页即对应着索引树的节点</p>
<p>磁盘 IO 次数由树的高度决定，因此不适合使用 BST 存储索引，因此需要使用更加矮胖的树结构</p>
<p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样</p>
<h2 id="AVL-树、RB-树、B-树和-B-树"><a href="#AVL-树、RB-树、B-树和-B-树" class="headerlink" title="AVL 树、RB 树、B 树和 B+ 树"></a>AVL 树、RB 树、B 树和 B+ 树</h2><p>大多数自平衡搜索树（如 AVL 树和 RB 树）都会假定所有数据都在主内存中，但我们必须考虑无法容纳在主内存中的大量数据。当键的数量很大时，将以块形式从磁盘读取数据，与主存储器访问时间相比，磁盘访问时间非常高。</p>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><p>自平衡二叉搜索树，树中任一节点的两个子树的高度差最大为 1，其查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(log n)</p>
<ul>
<li><p>具有二叉查找树的特点(左子树任一节点小于父节点，右子树任一节点大于父节点)，任何一个节点的左子树与右子树都是平衡二叉树</p>
</li>
<li><p>任一节点的左右子树高度差小于 1</p>
</li>
</ul>
<p>AVL 树通过旋转来调整平衡</p>
<h3 id="RB-树"><a href="#RB-树" class="headerlink" title="RB 树"></a>RB 树</h3><p>AVL 树比红黑树更加平衡，但 AVL 树可能在插入和删除过程中引起更多旋转；如果频繁的插入和删除，应首选 RB 树；如果插入和删除操作的频率较低，而搜索操作的频率较高，则 AVL 树应优先于红黑树</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>B 树叫平衡多路查找树，设计的主要思想是减少磁盘访问次数，大多数树操作(增、删、查、最大值、最小值等)都需要都需要 O(h) 磁盘访问，h 为树的高度。</p>
<p>通常，B 树节点的大小保持与磁盘块大小相等，由于 B 树的高度较低，因此与平衡的二叉搜索树（如AVL 树、RB 树等）相比，大多数操作的磁盘访问次数显著减少。</p>
<p>先定义一条数据记录为一个二元组 [key, data]，key 为记录的键值，对于不同数据记录，key 是互不相同的；data 为数据记录除 key 外的数据</p>
<ul>
<li><p>M 阶 B 树表示每个节点最多 M 个子树</p>
</li>
<li><p>每个非叶子节点由 n-1 个 key 和 n 个指针组成，其中 M&#x2F;2 &lt;&#x3D; n &lt;&#x3D; M，其中 M&#x2F;2 向上取整</p>
</li>
<li><p>每个叶子节点最少包含一个 key 和两个指针，最多包含 M-1 个 key 和 M 个指针，叶节点的指针均为 null</p>
</li>
<li><p>所有叶子节点都在同一层</p>
</li>
<li><p>key 和指针互相间隔，节点两端是指针</p>
</li>
<li><p>一个节点中的 key 从左到右非递减排列</p>
</li>
<li><p>每个指针要么为 null，要么指向另外一个节点</p>
</li>
<li><p>如果某个指针在节点 node 最左边且不为 null，则其指向节点的所有 key 小于 v_key1，其中 v_key1 为 node 的第一个 key 的值</p>
</li>
<li><p>如果某个指针在节点 node 最右边且不为 null，则其指向节点的所有 key 大于 v_key2，其中 v_key2 为 node 的最后一个 key 的值</p>
</li>
<li><p>如果某个指针在节点 node 的左右相邻 key 分别是 key_i 和 key_i+1 且不为 null，则其指向节点的所有 key 小于 v_key_i+1 且大于 v_key_i</p>
</li>
<li><p>每个节点都存储数据</p>
</li>
</ul>
<p>一颗 4 阶的 B 树，每个节点最多有 4 个子树、3 个 key，最少有 2 个子树、1 个 key</p>
<img src="/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/01.png" class="">

<h4 id="插入保持平衡"><a href="#插入保持平衡" class="headerlink" title="插入保持平衡"></a>插入保持平衡</h4><ul>
<li><p>首先考虑要插入的子树是否已经超出了关键字数的限制</p>
</li>
<li><p>超出的话，如果要插入的位置是叶子节点，就只能拆一个关键字添加到要插入位置的父节点</p>
</li>
<li><p>如果非叶子节点，就得从其他子树拆子树给新插入的元素做孩子</p>
</li>
</ul>
<h4 id="删除保持平衡"><a href="#删除保持平衡" class="headerlink" title="删除保持平衡"></a>删除保持平衡</h4><p>删除孩子后，父节点是否还满足子树 k 介于 M&#x2F;2 和 M 的条件，不满足就得从别的节点拆子树甚至修改相关子树结构来保持平衡</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>由于 B-Tree 的特性，在 B-Tree 中按 key 检索数据流程：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败</p>
<p>B 树的树内存储数据，因此查询单条数据的时候，B 树的查询效率不固定，最好的情况是 O(1)，所以做单一数据查询的时候，使用 B 树平均性能更好，在特定数据重复多次查询的场景中更加高效</p>
<p>由于 B 树中各节点之间没有指针相邻，因此 B 树不适合做一些数据遍历操作</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>与 B-Tree 相比，B+Tree 有以下不同点：</p>
<ul>
<li><p>n 个 key 对应 n 个指针 n 颗树，M&#x2F;2 &lt;&#x3D; n &lt;&#x3D; M</p>
</li>
<li><p>非叶子节点不存储 data，只存储 key；叶子节点不存储指针</p>
</li>
<li><p>所有叶子节点增加了一个链指针</p>
</li>
</ul>
<img src="/2023/04/09/MySql-%E7%B4%A2%E5%BC%95/02.png" class="">

<p>B+ 树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定，所以在做单一数据的查询上，其平均性能并不如 B 树</p>
<p>B+ 树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得 B+ 树非常适合做范围查询</p>
<h3 id="选择-B-树"><a href="#选择-B-树" class="headerlink" title="选择 B+ 树"></a>选择 B+ 树</h3><ul>
<li><p>B 树只适合随机检索，而 B+ 树同时支持随机检索和顺序检索</p>
</li>
<li><p>B+ 树空间利用率更高，可减少 IO 次数，磁盘读写代价更低：B+ 树内部结点比 B 树小，一次性读入内存中可以查找的关键字也就越多，从而 IO 次数降低了</p>
</li>
<li><p>B+ 树的查询效率更加稳定</p>
</li>
<li><p>增删节点时，效率更高</p>
</li>
</ul>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul>
<li><p>主键索引：数据列不允许重复，不允许为 NULL，一个表只能有一个主键</p>
</li>
<li><p>唯一索引：数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引</p>
</li>
<li><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值</p>
</li>
<li><p>全文索引：基于相似度的查询，而不是原来的精确数值比较；<code>like + %</code> 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的；全文索引可能存在精度问题</p>
</li>
</ul>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>InnoDB 的 B+ Tree 可能存储的是整行数据，也有可能是主键的值</p>
<p>聚簇索引：在 InnoDB 里，索引 B+ Tree 的叶子节点存储了整行数据的是主键索引</p>
<p>非聚簇索引：索引 B+ Tree 的叶子节点存储了主键的值的是非主键索引</p>
<p>聚簇索引查询会更快，因为主键索引树的叶子节点直接就是我们要查询的整行数据了，而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值回表查询</p>
<h2 id="非主键索引存储的是主键索引值"><a href="#非主键索引存储的是主键索引值" class="headerlink" title="非主键索引存储的是主键索引值"></a>非主键索引存储的是主键索引值</h2><p>非主键索引直接存储数据的地址，会带来一些问题：</p>
<ol>
<li><p>数据库备份、迁移困难</p>
</li>
<li><p>插入、删除数据时，B+ 树可能发生分裂，导致物理地址变化</p>
</li>
<li><p>无法给物理地址加行级锁</p>
</li>
</ol>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>非主键索引并不一定都会回表查询</p>
<p>索引覆盖：当一个查询语句的执行只用从索引中就能够取得，则不必从数据表中读取</p>
<p>常见方法：对被查询的字段建立联合索引</p>
<h2 id="联合索引和最左前缀匹配"><a href="#联合索引和最左前缀匹配" class="headerlink" title="联合索引和最左前缀匹配"></a>联合索引和最左前缀匹配</h2><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>在创建多列索引时，根据业务需求，where 子句中使用最频繁的一列放在最左边，因为 MySQL 索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>当创建一个联合索引的时候，如 (key1,key2,key3)，相当于创建了 (key1)、(key1,key2) 和 (key1,key2,key3) 三个索引</p>
<p>&#x3D; 和 in 可以乱序，查询优化器会帮你优化成索引可以识别的形式</p>
<h3 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h3><p>匹配时会一直向右匹配直到遇到范围查询，范围列可以用到索引，但是范围列后面的列无法用到索引，即索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引</p>
<p>like 语句中通配符出现在开头则不能使用索引</p>
<p>如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描</p>
<p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>使用联合索引时，索引下推优化可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p>
<h2 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h2><p>当某个字段较大时，不适合做主键，会浪费大量磁盘空间，因此可以考虑在该字段设置唯一索引或普通索引</p>
<p>假设在 id 字段建立索引，执行 <code>select id from T where k=5</code></p>
<h3 id="查询区别"><a href="#查询区别" class="headerlink" title="查询区别"></a>查询区别</h3><p>先通过 B+ 树从树根开始，按层搜索到叶子节点，找到相应的数据页，然后可以认为在数据页内部通过二分法来定位记录</p>
<ul>
<li><p>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录</p>
</li>
<li><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索</p>
</li>
</ul>
<p>这两个的不同带来的性能差距是微乎其微</p>
<p>InnoDB 的数据是按数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB</p>
<p>因为引擎是按页读写的，当找到第一个的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的查找和判断下一条记录的操作，就只需要一次指针寻找和一次计算</p>
<p>如果第一个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，但这种情况概率很低</p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了</p>
<p>在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作</p>
<p>change buffer 是可以持久化的数据，在内存中有拷贝，也会被写入到磁盘上</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge</p>
<p>除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge；在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作</p>
<p>将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升；数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率</p>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束，必须要将数据页读入内存才能判断；如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了</p>
<p>因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用</p>
<p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大</p>
<p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大</p>
<p>对于更新的目标页在内存中：</p>
<ul>
<li><p>对于唯一索引来说，判断到没有冲突，插入这个值，语句执行结束</p>
</li>
<li><p>对于普通索引来说，插入这个值，语句执行结束</p>
</li>
</ul>
<p>此情况下，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间</p>
<p>对于更新的目标页不再内存中：</p>
<ul>
<li><p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束</p>
</li>
<li><p>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了</p>
</li>
</ul>
<p>change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的</p>
<p>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好</p>
<p>对于写完马上做查询的业务，即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程，这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价，change buffer 反而起到了副作用</p>
<h2 id="redo-log-和-change-buffer"><a href="#redo-log-和-change-buffer" class="headerlink" title="redo log 和 change buffer"></a>redo log 和 change buffer</h2><p>change buffer 和 redo log 颗粒度不一样</p>
<p>change buffer 只是针对如果更改的数据所在页不在内存中才暂时储存在 change buffer 中</p>
<p>redo log 会记录一个事务内进行数据更改的所有操作，即使修改的数据已经在内存中了，那也会记录下来</p>
<p>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）</p>
<p>change buffer 主要节省的则是随机读磁盘的 IO 消耗</p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>可以定义字符串的一部分作为索引</p>
<p>如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串</p>
<p>使用前缀索引后，可能会导致查询语句回表查询的次数变多</p>
<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</p>
<p>使用前缀索引用不上覆盖索引对查询性能的优化</p>
<p>在建立前缀索引时，区分度越高越好，可以通过 <code>select count(distinct key(n)) from T</code> 查看前缀长度的区分度</p>
<h2 id="索引使用场景"><a href="#索引使用场景" class="headerlink" title="索引使用场景"></a>索引使用场景</h2><ul>
<li><p>查询时，加速 SQL 执行效率</p>
</li>
<li><p>如果没有创建索引，排序时将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），非常影响性能；建立索引后，数据本身有序，可直接按照索引的顺序和映射关系逐条取出数据</p>
</li>
<li><p>提高 join 效率</p>
</li>
<li><p>索引覆盖</p>
</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul>
<li><p>如果查询条件用 or，必须 or 条件中的每个列都加上索引，否则无效</p>
</li>
<li><p>违反最左匹配原则，则不适用索引</p>
</li>
<li><p>like 语句中通配符出现在开头则不能使用索引</p>
</li>
<li><p>存在索引列的数据类型隐形转换，则不使用索引</p>
</li>
<li><p>where 字句里对索引列有数学运算或者使用函数，则不使用索引</p>
</li>
<li><p>mysql 优化器觉得全表扫描更快时，则不适用索引</p>
</li>
</ul>
<h2 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h2><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护</p>
<ul>
<li><p>页分裂：插入情况下，如果所在数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去；页分裂除了影响分类，还影响数据页利用率</p>
</li>
<li><p>页合并：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并</p>
</li>
</ul>
<p>自增主键是指自增列上定义的主键，在建表语句中一般这么定义 <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code></p>
<p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值</p>
<p>每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂，而业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高</p>
<p>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p>
<p>从性能和存储空间方面考量，自增主键往往是更合理的选择</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%96%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%96%E5%8A%A8/" class="post-title-link" itemprop="url">数据库抖动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:04:51" itemprop="dateCreated datePublished" datetime="2023-04-09T15:04:51+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>InnoDB 在处理更新语句的时候，只做了写 redo log 一个磁盘操作，在更新内存写完 redo log 后，就返回给客户端，本次更新成功</p>
<p>把内存里的数据写入磁盘的过程称为 flush</p>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为脏页；内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为干净页；不论是脏页还是干净页，都在内存中</p>
<ul>
<li>当 InnoDB 的 redo log 写满了，这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写；checkpoint 推进需将对应的脏页 flush 进磁盘</li>
</ul>
<img src="/2023/04/09/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%96%E5%8A%A8/01.jpg" class="">

<ul>
<li><p>当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用；如果淘汰的是脏页，就要先将脏页写到磁盘；如果脏页没刷，直接淘汰，虽然可以依靠 redo log 恢复到最新状态，但是 redo Log 就成了唯一的依靠了，唯一的依靠就不能随便擦除，会制约 redo log 的擦除</p>
</li>
<li><p>系统要合理地安排时间，见缝插针地找时间，只要有机会就刷一点脏页</p>
</li>
<li><p>MySQL 正常关闭，会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快</p>
</li>
</ul>
<h2 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>redo log 写满了，要 flush 脏页，这种情况是 InnoDB 要尽量避免的；整个系统就不能再接受更新了，所有的更新都必须堵住</p>
<p>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</p>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>内存不够用了，要先将脏页写到磁盘</p>
<p>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：还没有使用的、使用了并且是干净页、使用了并且是脏页</p>
<p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少</p>
<p>当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页，这时候只能把最久不使用的数据页从内存中淘汰掉</p>
<p>如果要淘汰的是一个干净页，就直接释放出来复用</p>
<p>如果是脏页就必须先刷到磁盘，变成干净页后才能复用</p>
<p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长</p>
<h2 id="刷脏页的控制策略"><a href="#刷脏页的控制策略" class="headerlink" title="刷脏页的控制策略"></a>刷脏页的控制策略</h2><p>要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快</p>
<p>在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个邻居也带着一起刷掉；而且这个把邻居拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/09/MySql-count%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/MySql-count%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">count 函数分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-09 15:02:27" itemprop="dateCreated datePublished" datetime="2023-04-09T15:02:27+08:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在不同的 MySQL 引擎中，<code>count(*)</code> 有不同的实现方式</p>
<ol>
<li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 <code>count(*)</code> 的时候会直接返回这个数，效率很高</p>
</li>
<li><p>InnoDB 执行 <code>count(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</p>
</li>
</ol>
<p>InnoDB 中即使是在同一个时刻的多个查询，由于多版本并发控制 MVCC 的原因，InnoDB 表应该返回多少行也是不确定的</p>
<p>假设表 t 中现在有 10000 条记录，设计三个用户并行的会话：</p>
<ul>
<li><p>会话 A 先启动事务并查询一次表的总行数</p>
</li>
<li><p>会话 B 启动事务，插入一行后记录后，查询表的总行数</p>
</li>
<li><p>会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数</p>
</li>
</ul>
<img src="/2023/04/09/MySql-count%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/01.png" class="">

<p>因此对于 <code>count(*)</code> 请求来说，InnoDB 只能把数据一行一行地读出依次判断，可见的行才能够用于计算表的总行数</p>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值，所以普通索引树比主键索引树小很多；对于 <code>count(*)</code> 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此 MySQL 优化器会找到最小的那棵树来遍历</p>
<h2 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h2><p><code>count()</code> 是一个聚合函数，对于返回的结果集，一行行地判断，如果 <code>count</code> 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值</p>
<p>对于 <code>count(主键 id)</code> 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加</p>
<p>对于 <code>count(1)</code> 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加</p>
<p><code>count(1)</code> 执行得要比 <code>count(主键 id)</code> 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作</p>
<p>按照效率排序的话，<code>count(字段)</code> &lt; <code>count(主键 id)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code>，所以建议尽量使用 <code>count(*)</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/gcc-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/gcc-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE/" class="post-title-link" itemprop="url">属性设置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 23:17:37" itemprop="dateCreated datePublished" datetime="2023-04-02T23:17:37+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/gcc/" itemprop="url" rel="index"><span itemprop="name">gcc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>__attribute__</code> 可以设置函数属性、变量属性和类型属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((attribute-<span class="built_in">list</span>))</span><br></pre></td></tr></table></figure>
<h2 id="aligned"><a href="#aligned" class="headerlink" title="aligned"></a>aligned</h2><p>设定一个指定大小的对齐格式，以字节为单位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定以 8 字节对齐</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> b[<span class="number">3</span>];</span><br><span class="line">&#125; __attribute__ ((aligned (<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定以最优方式对齐</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> b[<span class="number">3</span>];</span><br><span class="line">&#125; __attribute__ ((aligned));</span><br></pre></td></tr></table></figure>

<p><code>aligned</code> 属性使被设置的对象占用更多的空间</p>
<h2 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h2><p>取消内存对齐，采用紧密分布方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">p</span> <span class="title">px</span>;</span></span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125; __attribute__ ((packed))</span><br></pre></td></tr></table></figure>

<p><code>packed</code> 可以减小对象占用的空间</p>
<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>指定一个函数比如 <code>printf</code> 或 <code>scanf</code>作为参数，使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">format (archetype, <span class="built_in">string</span>-index, first-to-check)</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">my_printf</span> <span class="params">(<span class="type">void</span> *my_object, <span class="type">const</span> <span class="type">char</span> *my_format, ...)</span> __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span>;</span><br></pre></td></tr></table></figure>

<p><code>string-index</code> 指定传入函数的第几个参数是格式化字符串</p>
<p><code>first-to-check</code> 指定从函数的第几个参数开始按上述规则进行检查</p>
<p>当函数是成员函数时，由于编译器会添加 <code>this</code> 指针，所以 <code>first-to-check</code> 需要后移一位</p>
<h2 id="noreturn"><a href="#noreturn" class="headerlink" title="noreturn"></a>noreturn</h2><p>通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/gcc-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/gcc-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">内置函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 23:16:36" itemprop="dateCreated datePublished" datetime="2023-04-02T23:16:36+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/gcc/" itemprop="url" rel="index"><span itemprop="name">gcc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="builtin-ctz"><a href="#builtin-ctz" class="headerlink" title="__builtin_ctz"></a>__builtin_ctz</h2><p>返回输入数二进制表示从最低位开始(右起)的连续的 0 的个数</p>
<p>如果传入 0 则行为未定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_ctz (<span class="type">unsigned</span> <span class="type">int</span> x)</span><br><span class="line"><span class="type">int</span> __builtin_ctzl (<span class="type">unsigned</span> <span class="type">long</span>)</span><br><span class="line"><span class="type">int</span> __builtin_ctzll (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span><br></pre></td></tr></table></figure>

<h2 id="builtin-clz"><a href="#builtin-clz" class="headerlink" title="__builtin_clz"></a>__builtin_clz</h2><p>返回输入数二进制表示从最高位开始(左起)的连续的 0 的个数</p>
<p>如果传入 0 则行为未定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_clz (<span class="type">unsigned</span> <span class="type">int</span> x)</span><br><span class="line"><span class="type">int</span> __builtin_clzl (<span class="type">unsigned</span> <span class="type">long</span>)</span><br><span class="line"><span class="type">int</span> __builtin_clzll (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span><br></pre></td></tr></table></figure>

<h2 id="builtin-ffs"><a href="#builtin-ffs" class="headerlink" title="__builtin_ffs"></a>__builtin_ffs</h2><p>返回输入数二进制表示的最低非 0 位的下标，下标从 1 开始计数</p>
<p>传入 0 则返回 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_ffs (<span class="type">unsigned</span> <span class="type">int</span> x)</span><br><span class="line"><span class="type">int</span> __builtin_ffsl (<span class="type">unsigned</span> <span class="type">long</span>)</span><br><span class="line"><span class="type">int</span> __builtin_ffsll (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span><br></pre></td></tr></table></figure>

<h2 id="bulitin-popcount"><a href="#bulitin-popcount" class="headerlink" title="__bulitin_popcount"></a>__bulitin_popcount</h2><p>返回输入的二进制表示中 1 的个数</p>
<p>如果传入 0 则返回 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_popcount (<span class="type">unsigned</span> <span class="type">int</span> x)</span><br><span class="line"><span class="type">int</span> __builtin_popcountl (<span class="type">unsigned</span> <span class="type">long</span>)</span><br><span class="line"><span class="type">int</span> __builtin_popcountll (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span><br></pre></td></tr></table></figure>

<h2 id="bulitin-parity"><a href="#bulitin-parity" class="headerlink" title="__bulitin_parity"></a>__bulitin_parity</h2><p>返回输入的二进制表示中 1 的个数的奇偶，也就是输入的二进制中 1 的个数对 2 取模的结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_parity (<span class="type">unsigned</span> <span class="type">int</span> x)</span><br><span class="line"><span class="type">int</span> __builtin_parityl (<span class="type">unsigned</span> <span class="type">long</span>)</span><br><span class="line"><span class="type">int</span> __builtin_parityll (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span><br></pre></td></tr></table></figure>

<h2 id="buitin-expect"><a href="#buitin-expect" class="headerlink" title="__buitin_expect"></a>__buitin_expect</h2><p>GCC 在编译过程中，会将可能性更大的代码紧跟着前面的代码，从而减少指令跳转带来的性能上的下降, 达到优化程序的目的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> __builtin_expect(<span class="type">long</span> exp, <span class="type">long</span> c);</span><br><span class="line"><span class="comment">// exp 为一个整型表达式</span></span><br><span class="line"><span class="comment">// c 必须是一个编译期常量, 不能使用变量，表示期望 exp 表达式的值等于常量 c</span></span><br><span class="line"><span class="comment">// 返回值就是 exp 的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 __builtin_expect 构建两个宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)      __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)    __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/gcc-%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/gcc-%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">编译指令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 23:13:55" itemprop="dateCreated datePublished" datetime="2023-04-02T23:13:55+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:07:59" itemprop="dateModified" datetime="2023-06-30T17:07:59+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/gcc/" itemprop="url" rel="index"><span itemprop="name">gcc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>-o &lt;file&gt;</code>：输出编译后的结果到指定的文件 file 中</p>
<p><code>-E</code>：对源文件进行预处理，预处理后生成 .i 或者是 .ii 文件，生成的是文本文件</p>
<p><code>-S</code>：只进行预处理和编译</p>
<p><code>-c</code>：只进行预处理，编译，汇编操作，生成 .o(.obj) 文件，不进行链接</p>
<p><code>-g</code>：产生调试信息</p>
<p><code>-gn</code>：生成调试信息,同时用 n 指出需要多少信息，默认值是 2</p>
<p><code>-Dmacro</code>：添加宏 <code>macro</code></p>
<p><code>-Dmacro=defn</code>：定义宏 <code>macro</code> 的内容为 <code>defn</code></p>
<p><code>-Umacro</code>：取消宏</p>
<p><code>-u</code>：移除所有预定义宏</p>
<p><code>-std=</code>：选择语言标准，<code>-std=c++11</code></p>
<p><code>-IDIRECTORY</code>：指定额外的头文件搜索路径</p>
<p><code>-LDIRECTORY</code>：指定额外的函数库搜索路径</p>
<p><code>-lLIBRARY</code>：连接时搜索指定的函数库</p>
<p><code>-v</code>：打印所有执行的命令</p>
<p><code>-w</code>：编译时，不显示任何警告消息</p>
<p><code>-Wall</code>：编译时，显示所有出现的警告消息</p>
<p><code>-Werror</code>：将警告升级为错误</p>
<p><code>-Wextra</code>：打印额外告警消息</p>
<p><code>-Wconversion</code>：隐式转换可能会改变值时告警</p>
<p><code>-Wold-style-cast</code>：使用 c 风格类型转换时报警</p>
<p><code>-Wno-unused-parameter</code>：未使用变量报警</p>
<p><code>-Woverloaded-virtual</code>：重写虚函数时应使用 <code>virtual</code></p>
<p><code>-Woverflow</code>：算术计算溢出时报警</p>
<p><code>-Wpointer-arith</code>：算术表达式中使用指针时报警</p>
<p><code>-Wshadow</code>：当一个局部变量覆盖另一个局部变量时报警</p>
<p><code>-Wwrite_strings</code>：将字面字符串转换为 <code>char*</code> 报警</p>
<p><code>-pedantic</code>：允许发出ANSI&#x2F;ISO C标准所列出的所有警告</p>
<p><code>-fpic</code>、<code>-fPIC</code>：生成与位置无关的代码，用于动态链接库</p>
<p><code>-funsigned-char</code>、<code>-fno-signed-char</code>、<code>-fsigned-char</code>、<code>-fno-unsigned-char</code>：这四个参数是对 <code>char</code> 类型进行设置,决定将 <code>char</code> 类型设置成 <code>unsigned char</code> 或者 <code>signed char</code></p>
<p><code>-fsanitize=address</code>：开启内存地址检查</p>
<p><code>-fno-elide-constructors</code>：关闭 RVO 优化</p>
<p><code>-fdump-lang-class</code>：打印内存布局</p>
<p><code>-O0</code> 关闭所有优化选项，默认等级</p>
<p><code>-O1/O2/03</code> 优化</p>
<p><code>-Og</code> 在 <code>-O1</code> 的基础上，取消了影响调试的优化，但这个参数只是告诉编译器不要影响调试，但调试信息的生成还是依赖 <code>-g</code></p>
<p><code>-Os</code> 以 <code>-O2</code> 为基础，取消了可能导致程序变大的优化</p>
<p><code>-Ofast</code> 以 <code>-O3</code> 为基础，添加非常规优化</p>
<h2 id="pic-x2F-PIC"><a href="#pic-x2F-PIC" class="headerlink" title="pic&#x2F;PIC"></a>pic&#x2F;PIC</h2><p>共享库被加载时，在内存的位置是不固定的</p>
<p><code>-fpic</code> 和 <code>-fPIC</code> 作用于编译阶段，告诉编译器生成与位置无关的代码，Position-Independent Code</p>
<p>使用 <code>-fpic</code> 和 <code>-fPIC</code> 产生的代码中，没有绝对地址，全部使用相对地址，故而代码被加载器加载到内存的任意位置都可以正确的执行</p>
<p>如果不加 <code>-fpic</code> 和 <code>-fPIC</code>，则加载动态库的代码段时，代码段引用的数据对象需要重定位，重定位会修改代码段的内容，这就造成每个使用这个动态库代码段的进程在内核里都会拷贝一份动态库的代码段，如果动态库被多个应用程序共同使用，那么它们必须每个程序维护一份代码段</p>
<p><code>-fpic</code> 和 <code>-fPIC</code> 的区别是 <code>-fpic</code> 会限制链接它进程的 GOT 大小，该大小限制跟平台有关，而 <code>-fPIC</code> 则没有该限制</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">字符串匹配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 17:06:16" itemprop="dateCreated datePublished" datetime="2023-04-02T17:06:16+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:08:00" itemprop="dateModified" datetime="2023-06-30T17:08:00+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在字符串 A 中查找字符串 B，那 A 为主串，长度记为 n，B 为模式串，长度记为 m，n &gt; m</p>
<h2 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h2><p>暴力匹配算法（Brute Force）</p>
<p>BF 算法即在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/01.jpg" class="">

<p>BF 的最坏情况时间复杂度是 O(n*m)，但却是实际中运用比较常见的字符串匹配算法，原因：</p>
<ul>
<li>实际开发中，模式串和主串的长度都不会太长，而且每次模式串与主串匹配的时候，当中途遇到不能匹配的字符时就停止了</li>
<li>代码实现简单，不容易出错</li>
</ul>
<h2 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h2><p>对 BF 稍加改进，引入哈希算法，时间复杂度就会降低</p>
<p>RK 算法的思路：通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（先不考虑哈希冲突的问题）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了</p>
<p>通过设计哈希算法来提高计算子串哈希值的效率，比如假设要处理的字符串只包含 26 个小写字母，那就可以只用 26 进制表示一个字符串。为了保证将哈希值落在整形数据范围内，可以牺牲一下允许哈希冲突</p>
<p>当发生哈希冲突，有可能子串和模式串的哈希值相同但本身并不匹配，所以在哈希值相同时再去对比一下子串和模式串本身即可</p>
<p>RK 算法整体的时间复杂度就是 O(n)，但如果存在大量哈希冲突，将导致时间复杂度退化成 O(n*m)</p>
<h2 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h2><p>BM 算法包含两部分，分别是坏字符规则和好后缀规则</p>
<h3 id="坏字符串规则"><a href="#坏字符串规则" class="headerlink" title="坏字符串规则"></a>坏字符串规则</h3><p>BM 算法中的匹配顺序是按照模式串下标从大到小的顺序倒着匹配的，即我们从模式串的末尾往前倒着匹配</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/02.jpg" class="">

<p>当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作坏字符（主串中的字符）</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/03.jpg" class="">

<p>拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配</p>
<p>这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/04.jpg" class="">

<p>模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a，可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/05.jpg" class="">

<p>当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi（下标都是字符在模式串的下标）</p>
<p>如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/06.jpg" class="">

<h3 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h3><p>当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/07.jpg" class="">

<p>把已经匹配的 bc 叫作好后缀，记作 {u}，并拿它在模式串中查找，如果找到了另一个跟 {u} 相匹配的子串 {u*}，那我们就将模式串滑动到子串 {u*} 与主串中 {u} 对齐的位置</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/08.jpg" class="">

<p>如果在模式串中找不到另一个等于 {u} 的子串，我们就直接将模式串，滑动到主串中 {u} 的后面，因为之前的任何一次往后滑动，都没有匹配主串中 {u} 的情况</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/09.jpg" class="">

<p>但这种滑动太过上头，所以不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的</p>
<p>某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc</p>
<p>前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/10.jpg" class="">

<p>从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的</p>
<h3 id="规则选择"><a href="#规则选择" class="headerlink" title="规则选择"></a>规则选择</h3><p>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h4><p>如果拿坏字符在模式串中顺序遍历查找，效率比较低</p>
<p>引入哈希表，将模式串中的每个字符及其下标存进哈希表，这样可以快速找到坏字符在模式串的位置下标</p>
<p>如果字符串的字符集不是很大，每个字符长度是 1 字节，则可以用大小为 256 的数组来记录每个字符在模式串中出现的位置，数组下标对应字符的 ASCII</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/11.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateHashTable</span><span class="params">(<span class="type">const</span> string &amp; str, <span class="type">int</span> * bc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bc[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bc[(<span class="type">int</span>)str[i]] = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bm</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> * bc = <span class="keyword">new</span> <span class="type">int</span> [SIZE];</span><br><span class="line">    <span class="built_in">GenerateHashTable</span>(needle, bc);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="type">int</span> j; </span><br><span class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)  <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="keyword">if</span> (a[i+j] != b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置    </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位    </span></span><br><span class="line">        i = i + (j - bc[(<span class="type">int</span>)a[i+j]]);   <span class="comment">// 没有考虑到为负的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="好后缀规则-1"><a href="#好后缀规则-1" class="headerlink" title="好后缀规则"></a>好后缀规则</h4><ul>
<li>在模式串中，查找跟好后缀匹配的另一个子串</li>
</ul>
<p>因为好后缀也是模式串本身的后缀子串，所以可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置</p>
<p>通过长度可以确定一个唯一的后缀子串</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/12.jpg" class="">

<p>引入关键的变量 suffix 数组，suffix 数组的下表 k 表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀 {u} 相匹配的子串 {u*} 的起始下标值</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/13.jpg" class="">

<ul>
<li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串</li>
</ul>
<p>suffix 只能处理在模式串中查找跟好后缀匹配的另一个子串，所以需要布尔类型数组 prefix，来记录模式串的后缀子串是否能匹配模式串中的前缀子串</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/14.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateGS</span><span class="params">(<span class="type">const</span> string &amp; str, <span class="type">int</span> * suffix, <span class="type">bool</span> * prefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        suffix[i] = <span class="number">-1</span>;</span><br><span class="line">        prefix[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)  <span class="comment">// str[0, i]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; str[j] == str[m- <span class="number">1</span> - k])</span><br><span class="line">        &#123;</span><br><span class="line">            suffix[k] == j;</span><br><span class="line">            --j;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prefix[k] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设好后缀的长度是 k，<code>suffix[k] != -1</code>，则后移 j - suffix[k] + 1 位（j 为坏字符在模式串中的下标）</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/15.jpg" class="">

<p>如果 <code>suffix[k] == -1</code>，表示模式串中不存在另一个跟好后缀匹配的子串片段，好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k&#x3D;m-r，如果 prefix[k] 等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位</p>
<p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，我们就将整个模式串后移 m 位</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP 核心思想跟 BM 思想非常接近，在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况</p>
<p>在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作坏字符，把已经匹配的那段字符串叫作好前缀</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/16.jpg" class="">

<p>当遇到坏字符的时候，我们就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/17.jpg" class="">

<p>只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/18.jpg" class="">

<p>把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/19.jpg" class="">

<p>求好前缀的最长可匹配前缀和后缀子串，不涉及主串，只需要通过模式串本身就能求解，先预处理计算好，在模式串和主串匹配的过程中，直接拿过来就用</p>
<p>KMP 算法可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标，把这个数组定义为 next 数组叫失效函数</p>
<p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标</p>
<img src="/2023/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/20.jpg" class="">

<p>我们按照下标从小到大，依次计算 next 数组的值；当我们要计算 next[i] 的时候，前面的 next[0]，next[1]，……，next[i-1] 应该已经计算出来了，利用已经计算出来的 next 值，可以快速推导出 next[i] 的值</p>
<p>假设 b[0, i] 的最长可匹配后缀子串是 b[r, i]，如果把最后一个字符去掉，那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但不一定是最长可匹配后缀子串</p>
<p>既然 b[0, i-1] 最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]，那么就可以考察 b[0, i-1] 的次长可匹配后缀子串 b[x, i-1] 对应的可匹配前缀子串 b[0, i-1-x] 的下一个字符 b[i-x] 是否等于 b[i]，如果等于，那 b[x, i] 就是 b[0, i] 的最长可匹配后缀子串</p>
<p>次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]；查找 b[0, i-1] 的次长可匹配后缀子串就是查找 b[0, y] 的最长匹配后缀子串的问题</p>
<p>按照这个思路，我们可以考察完所有的 b[0, i-1] 的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i] 就是 b[0, i] 的最长可匹配后缀子串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerteNext</span><span class="params">(string &amp; needle, <span class="type">int</span> * next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;  <span class="comment">// 记录上一个的 next</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; needle.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">-1</span> &amp;&amp; needle[k + <span class="number">1</span>] != b[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k]; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (needle[k + <span class="number">1</span>] == needle[i])</span><br><span class="line">        &#123; </span><br><span class="line">            ++k;</span><br><span class="line">        &#125; </span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string &amp; haystack, string &amp; needle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> * next = <span class="keyword">new</span> <span class="type">int</span>[needle.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="built_in">GenerteNext</span>(needle, next);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// needle 字符串的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>() - needle.<span class="built_in">size</span>() + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 滑动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">// 一直找到a[i]和b[j] </span></span><br><span class="line">             j = next[j - <span class="number">1</span>] + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(haystack[i] == needle[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == needle.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>空间复杂度是 O(m)，m 表示模式串的长度</p>
<p>计算 next 数组的时间复杂度是 O(m)，查询部分时间复杂度是 O(n)，n 表示主串长度</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:43:13" itemprop="dateCreated datePublished" datetime="2023-04-02T16:43:13+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 17:08:00" itemprop="dateModified" datetime="2023-06-30T17:08:00+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>并查集既是一种数据结构，也是一种算法，支持查找和合并两种操作，不支持分割一个集合</p>
<p>用集合的某个元素来来代表这个集合，这个元素称为集合的代表元，集合内的所有元素组织成以代表元为根的树状结构</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/01.png" class="">

<p>对于每个元素都有指针指向其父节点，代表元的父节点是自己</p>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>查找元素所在集合的代表元，在树状结构中向上移动，直到到达根节点</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>每次查找的时候，将查找 x 到代表元路径上的所有点父节点设为根节点，使得查找操作平均时间复杂度为 O(1)</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/02.png" class="">

<h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>把 x 和 y 所在集合合并，其中将秩低的集合合并至秩高的集合，即总是将较矮的树合并至较高的树</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/03.png" class="">

<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>维护无向图的连通性，判断两个点是否在同一连通块内，和判断增加一条边是否产生环</li>
<li>计算有多少个不相交的集合</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank;  <span class="comment">// 秩</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">        rank = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; parent.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            parent[i] = i;  <span class="comment">// 初始化时每个结点的父节点都是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x != parent[x]) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">Find</span>(parent[x]);  <span class="comment">// 压缩路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">Find</span>(x), py = <span class="built_in">Find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(px == py) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[px] &gt; rank[py]) parent[py] = px;</span><br><span class="line">        <span class="keyword">if</span>(rank[px] &lt; rank[py]) parent[px] = py;</span><br><span class="line">        <span class="keyword">if</span>(rank[px] == rank[py]) &#123;</span><br><span class="line">            parent[py] = px;</span><br><span class="line">            rank[px]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/26/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/28/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chaxxro</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
