<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chaxxro.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="好记性不如烂键盘">
<meta property="og:type" content="website">
<meta property="og:title" content="也无风雨也无晴">
<meta property="og:url" content="https://chaxxro.github.io/page/36/index.html">
<meta property="og:site_name" content="也无风雨也无晴">
<meta property="og:description" content="好记性不如烂键盘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chaxxro">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaxxro.github.io/page/36/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/36/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>也无风雨也无晴</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">也无风雨也无晴</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chaxxro</p>
  <div class="site-description" itemprop="description">好记性不如烂键盘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">410</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%95%B0/" class="post-title-link" itemprop="url">字典树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:41:40" itemprop="dateCreated datePublished" datetime="2023-04-02T16:41:40+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</p>
<p>将 how, hi, her, hello, so, see 组织成 Trie 树为：</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%95%B0/01.jpg" class="">

<p>根节点不包含任务信息，每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（红色节点不是叶子结点）</p>
<p>构造过程：</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%95%B0/02.jpg" class="">

<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%95%B0/03.jpg" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>借助散列表的思想，通过一个下标与字符的映射数组，来存储子节点的指针</li>
</ol>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%95%B0/04.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    TrieNode * children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> ending;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TrieNode</span>(<span class="type">char</span> c) : <span class="built_in">data</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">        ending = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; node : children)</span><br><span class="line">        &#123;</span><br><span class="line">            node = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode * p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> c : text) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) p = <span class="keyword">new</span> <span class="built_in">TrieNode</span>(c);</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;ending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode * p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> c : text) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;ending;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>构建 Trie 树时间复杂度是 O(n)，查询时间复杂度是 O(k)</p>
<p>Trie 树虽然非常高效，但非常消耗内存，为避免重复存储前缀子串，维护了一个长度为 26 的节点指针数组，但很多字符都没有使用，而且真实情况下数组不止 26 个</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><p>字符集不能太大，如果字符集太大那么存储空间就会浪费太多，即使优化也要付出牺牲查询、插入的效率</p>
</li>
<li><p>要求字符串的前缀重合比较多，否则空间消耗变大</p>
</li>
<li><p>需要从零开始实现一个 Trie 树</p>
</li>
<li><p>Trie 树种使用了指针，数据块不连续，所以对缓存不友好</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/" class="post-title-link" itemprop="url">栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:40:02" itemprop="dateCreated datePublished" datetime="2023-04-02T16:40:02+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>栈是一种操作受限的线性表，只允许在一端插入和删除数据<br>后进者先出，先进者后出，不能冲中间任意抽出</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/01.jpg" class="">

<p>事实上，从功能上说数组或链表确实可以替代栈，但特定的数据结构是对特定场景的抽象；而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，容易出错</p>
<p>当某个数据集合只涉及在一端插入和删除数据，并满足后进先出、先进后出的特性，应该首选栈</p>
<ul>
<li><p>操作：栈的操作主要包括两个，入栈和出站，也就是在栈顶插入一个数据和从栈顶删除一个数据</p>
</li>
<li><p>实现方式：栈可以用数组来实现，也可以用链表来实现；用数组实现的栈叫顺序栈，用链表实现的栈叫链式栈</p>
</li>
<li><p>支持动态扩容的顺序栈：实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了；当栈满了之后，就申请一个更大的数组，将原来的数据全部拷贝到新的数组中</p>
</li>
</ul>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/02.jpg" class="">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/" class="post-title-link" itemprop="url">跳表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:37:22" itemprop="dateCreated datePublished" datetime="2023-04-02T16:37:22+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>二分查找底层依赖数据的随机访问特性，所以只能用数组来实现</p>
<p>如果数据存储在链表中，对链表进行稍加改造，就可以支持类似二分查找的算法，把改造之后的数据结构称作跳表</p>
<p>跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/01.jpg" class="">

<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/02.jpg" class="">

<p>对链表建立一级索引，每两个节点提取一个节点到上一级，把抽出来的那一级叫做索引或索引层；down 指针指向下一级节点；加上一层索引之后，查找一个节点需要遍历的节点个数减少，查找效率提升了</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/03.jpg" class="">

<p>在一级索引的基础上，每两个节点就抽出一个节点到第二级索引，需要遍历的节点数量又减少了这种链表加多级索引的结构就是跳表</p>
<p>假设最高索引有 2 个节点，会有 logn 级索引，每层最多遍历 3 个节点，所以时间复杂度 O(logn)<br>空间换时间的设计思路</p>
<p>包含 n 个节点，需要额外接近 n 个节点的存储空间</p>
<p>实际上，索引节点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引节点大很多时，索引占用的空间可以忽略</p>
<p>动态插入、删除的时间复杂度也是 O(logn)</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/04.jpg" class="">

<p>删除时，如果节点在索引中出现，除了删除原始链表中的节点，还要删除索引中的</p>
<p>当不停往调表中插入数据时，如果不更新索引就有可能出现某两个索引节点之间数据非常多，极端情况下跳表会退化成单链表；需要某种手段来维护索引与原始链表大小之间的平衡，也就是说如果链表中结点多了，索引节点也要相应的增加；通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机生成一个k ，那就将这个结点添加到第一级到第 k 级的索引中</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/05.jpg" class="">

<h2 id="索引建立策略"><a href="#索引建立策略" class="headerlink" title="索引建立策略"></a>索引建立策略</h2><p>新插入的结点应该跨越的层数是通过抛硬币来决定新插入结点跨越的层数</p>
<p>每次要插入一个结点的时候，就来抛硬币，如果抛出来的是正面，则继续抛，直到出现负面为止，统计这个过程中出现正面的次数，这个次数作为结点跨越的层数</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>例如，当插入 3 时，通过抛硬币得到跨越层数为 0，则插入 3 跨越 0 层</p>


<p>插入 4 时，通过抛硬币得到跨越层数为 2</p>


<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>直接把元素和所跨越层数删除</p>


<h2 id="红黑树和跳表"><a href="#红黑树和跳表" class="headerlink" title="红黑树和跳表"></a>红黑树和跳表</h2><p>红黑树插入、删除结点时，是通过调整结构来保持红黑树的平衡，比起跳跃表直接通过一个随机数来决定跨越几层，在时间复杂度的花销上是要高于跳跃表的</p>
<p>跳表的复杂度和红黑树一样，但实现起来更简单</p>
<p>在并发环境下，红黑树在插入和删除的时候由于需要做一些平衡的操作，这样的操作可能会涉及到整个树的其他部分，而跳表的操作显然更加局部性一些，锁需要盯住的节点更少，因此在并发情况下性能好一些</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkipList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">typedef</span> shared_ptr&lt;Node&gt; node_ptr;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">int</span> level;          <span class="comment">// 跨越几层</span></span><br><span class="line">        vector&lt;node_ptr&gt; next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> v, <span class="type">int</span> l) : <span class="built_in">next</span>(l, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            level = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">Node</span>() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;delete &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> maxLevel;               <span class="comment">// 允许的最大层数</span></span><br><span class="line">	<span class="type">int</span> size;                   <span class="comment">// 当前节点数</span></span><br><span class="line">	<span class="type">int</span> levelCount;             <span class="comment">// 当前层数</span></span><br><span class="line">	Node::node_ptr head;        <span class="comment">// 头结点</span></span><br><span class="line">	default_random_engine dre;  <span class="comment">// 随机数引擎</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SkipList</span>() &#123;</span><br><span class="line">		maxLevel = <span class="number">4</span>;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">		levelCount = <span class="number">1</span>;</span><br><span class="line">		head = <span class="built_in">make_shared</span>&lt;Node&gt;(INT_MIN, maxLevel);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为简化处理，跳表不会插入重复值</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> level = <span class="built_in">get_level</span>() % maxLevel + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">auto</span> node = <span class="built_in">make_shared</span>&lt;Node&gt;(val, level);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注意这里的逻辑</span></span><br><span class="line">		<span class="keyword">auto</span> idx = head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (idx-&gt;next[i] &amp;&amp; idx-&gt;next[i]-&gt;value &lt; val) &#123;</span><br><span class="line">				idx = idx-&gt;next[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">auto</span> tmp = idx-&gt;next[i];</span><br><span class="line">			idx-&gt;next[i] = node;</span><br><span class="line">			node-&gt;next[i] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		levelCount = <span class="built_in">max</span>(levelCount, level);</span><br><span class="line">		++size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> Node::node_ptr <span class="title">find</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> idx = head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (idx-&gt;next[i] &amp;&amp; idx-&gt;next[i]-&gt;value &lt; val) &#123;</span><br><span class="line">				idx = idx-&gt;next[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (idx-&gt;next[<span class="number">0</span>] &amp;&amp; idx-&gt;next[<span class="number">0</span>]-&gt;value == val) &#123;</span><br><span class="line">			<span class="keyword">return</span> idx-&gt;next[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> idx = head;</span><br><span class="line">		Node::node_ptr node = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (idx-&gt;next[i] &amp;&amp; idx-&gt;next[i]-&gt;value &lt; val) &#123;</span><br><span class="line">				idx = idx-&gt;next[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (idx-&gt;next[i] &amp;&amp; idx-&gt;next[i]-&gt;value == val) &#123;</span><br><span class="line">				node = idx-&gt;next[i];</span><br><span class="line">				idx-&gt;next[i] = node-&gt;next[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">auto</span> idx = head-&gt;next[i];</span><br><span class="line">			<span class="keyword">while</span> (idx) &#123;</span><br><span class="line">				cout &lt;&lt; idx-&gt;value &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">				idx = idx-&gt;next[i];</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 获取随机层数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">dre</span>() % <span class="number">2</span>) &#123;</span><br><span class="line">			++level;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> level;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:35:17" itemprop="dateCreated datePublished" datetime="2023-04-02T16:35:17+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>二叉树在极端情况下会退化成链表，时间复杂度退化到 O(n)</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>二叉树中任意一个节点的左右子树的高度相差不大于 1</p>
<p>完全二叉树（叶节点在最底下两层，最后一层叶节点靠左排列，并且除了最后一层其他层的节点个数都要达到最大；数组方式存储时没有空间的浪费）、满二叉树（叶节点全部在最底层，除了叶节点之外，每个节点都有左右两个子节点）都是平衡二叉树，非完全二叉树也有可能是平衡二叉树</p>
<h2 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h2><p>平衡就是让整个树左右看起来比较对称、比较平衡，不出现左子树很高、右子树很矮的情况，这样能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作效率高一些；只要树的高度不比 log2n 大很多（仍是对数量级）</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>它是一种不严格的平衡二叉查找树</p>
<ul>
<li><p>红黑树中的节点一类被标记为黑色，一类被标记为红色；</p>
</li>
<li><p>根节点是黑色的；</p>
</li>
<li><p>每个叶子节点都是黑色的空节点，即叶子节点不存储数据；</p>
</li>
<li><p>任何相邻的节点都不能同时为红色，即红色节点都是被黑色节点隔开的；</p>
</li>
<li><p>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</p>
</li>
</ul>
<p>红黑树高度近似 2log2n，它的插入、删除、查找等操作时间复杂度是 O(logn)</p>
<p>因为红黑树是一种性能稳定的二叉查找树，所以但凡用到动态插入、删除、查找数据的场景，都可以用到它</p>
<h3 id="左旋、右旋"><a href="#左旋、右旋" class="headerlink" title="左旋、右旋"></a>左旋、右旋</h3><p>左旋：围绕某个节点的左旋</p>
<p>右旋：围绕某个节点的右旋</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/01.jpg" class="">

<h3 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h3><p>规定：插入的节点必须是红色的，而且二叉树中新插入的节点都是放在叶子节点上</p>
<ol>
<li><p>如果插入节点的父节点是黑色的，那什么都不用做</p>
</li>
<li><p>如果插入节点是根节点，那改变它的颜色，变成黑色</p>
</li>
<li><p>此外所有操作都会违背红黑树定义，故需要调整，调整过程包含两种基础操作：左右旋和改变颜色；新节点插入之后，如果红黑树的平衡被打破，只需要根据每种情况的特定不停调整，就可以让红黑树保持平衡</p>
</li>
</ol>
<p>父节点的兄弟节点—叔叔节点</p>
<p>父节点的父节点——祖父节点</p>
<p>正在处理的节点——关注节点</p>
<p>情况1：关注节点a的叔叔节点d是红色</p>
<ol>
<li><p>将关注节点 a 的父亲节点 b、叔叔节点d的颜色都设置成黑色</p>
</li>
<li><p>关注节点的祖父节点 c 设置成红色</p>
</li>
<li><p>关注节点变成祖父节点 c</p>
</li>
</ol>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/02.jpg" class="">

<p>情况2：关注节点 a 的叔叔节点 d 是黑色，a 是父节点 b 的右子节点</p>
<ol>
<li><p>关注节点变成父节点 b</p>
</li>
<li><p>围绕关注节点 b 左旋</p>
</li>
<li><p>调到情况 3</p>
</li>
</ol>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/03.jpg" class="">

<p>情况3：关注节点 a 的叔叔节点 d 是黑色，a 是父节点 b 的左子节点</p>
<ol>
<li><p>围绕 a 的祖父节点 c 右旋</p>
</li>
<li><p>将 a 的父节点 b、兄弟节点 c 的颜色互换</p>
</li>
</ol>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/04.jpg" class="">

<h3 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h3><p>第一步是针对删除节点初步调整，只是保证整颗红黑树在一个节点删除之后，每个节点达到其可达叶子节点的所有路径包含相同数目的黑色节点</p>
<p>第二步是针对关注节点进行二次调整，即不存在相邻的两个红色节点</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="定时器管理"><a href="#定时器管理" class="headerlink" title="定时器管理"></a>定时器管理</h3><p>对于定时器管理，需要预先计算出这些定时器下次被触发的时间点，然后根据这个时间点由小到大排序，从而加速定时器查找</p>
<p>如果使用二分搜索树，由于定时器执行的时间点是一直在变化的，如果这棵二分查找树的根节点不变的情况下，二分查找树会变得很不平衡，所以使用能够自动调节高度的红黑树会比使用普通的二分查找树会来的更加合理</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:33:59" itemprop="dateCreated datePublished" datetime="2023-04-02T16:33:59+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>队列是一种操作受限的线性表数据结构，先进者先出；队列只支持两个基本操作，入队和出队，从队列头部取一个元素</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/01.jpg" class="">

<ul>
<li><p>顺序队列：顺序队列用数组来实现</p>
</li>
<li><p>链式队列：链式队列用链表来实现</p>
</li>
<li><p>具体实现</p>
</li>
</ul>
<p>队列需要两个指针，一个是 head 指针指向对头，一个 tail 指针指向队尾</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/02.jpg" class="">

<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/03.jpg" class="">

<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p>循环队列的特点是当队列尾部到达数组的尽头时可以绕回队列的头部，在逻辑形式上看循环队列即形成了一个环形队列，从而达到了更高效的存储和操作效率</p>
<p>通常环形队列会预留一个位置来判断环形队列的满和空。在队列空时，此时头指针和尾指针都指向相同的位置，在队列满时，此时尾指针 +1 就是等于头指针指向第一个元素</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88/" class="post-title-link" itemprop="url">单调栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:33:16" itemprop="dateCreated datePublished" datetime="2023-04-02T16:33:16+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>单调栈即满足单调性的栈结构</p>
<p>单调栈分为单调递增栈和单调递减栈，就是栈内元素是升序还是降序排列的，这也涉及到出栈的逻辑</p>
<p>单调递增栈表示从栈底到栈顶是递增的</p>
<p>单调递减栈表示从栈底到栈顶是递减的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调递增栈</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; inc_stack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putincstack</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!inc_stack.<span class="built_in">empty</span>() &amp;&amp; inc_stack.<span class="built_in">top</span>() &gt;= v) &#123;</span><br><span class="line">        inc_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    inc_stack.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单调递减栈</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; des_stack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putdesstack</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!des_stack.<span class="built_in">empty</span>() &amp;&amp; des_stack.<span class="built_in">top</span>() &lt;= v) &#123;</span><br><span class="line">        des_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    des_stack.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在 O(N) 的时间复杂度，找出每个数左右两边第一个大于或小于它的解</p>
<p>对于单调递减栈，可以快速找到左边第一个大于自己的元素和右边第一个大于自己的元素：</p>
<ul>
<li><p>一个元素入栈后不破坏单调栈的单调性，那么栈顶元素就是待入栈元素在原数组位置左边第一个比自己大的元素</p>
</li>
<li><p>一个待入栈元素要入栈，导致一个元素出栈时，这个待入栈元素是该出栈元素右边第一个比自己大的元素</p>
</li>
</ul>
<p>对于单调递增栈，可以快速找到左边第一个小于自己的元素和右边第一个小于自己的元素：</p>
<ul>
<li><p>如果一个元素入栈后不破坏单调栈的单调性，那么栈顶元素就是待入栈元素在原数组位置左边第一个比自己小的元素</p>
</li>
<li><p>由于一个待入栈元素要入栈，导致一个元素出栈时，这个待入栈元素是该出栈元素右边第一个比自己小的元素</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">单调队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:31:59" itemprop="dateCreated datePublished" datetime="2023-04-02T16:31:59+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>单调队列就是单调递增或者单调递减的队列，但并不是通常的 FIFO，而是一个双端队列，既可以从队列的头取走元素，也可以从队列的尾取走元素</p>
<p>队列从队首到队尾具有单调性，单调队列的队头元素就是待求解区间的极值</p>
<p>单调递增队列：保证队列头元素一定是当前队列的最小值，用于维护区间的最小值</p>
<p>单调递减队列：保证队列头元素一定是当前队列的最大值，用于维护区间的最大值</p>
<p>实现队列：</p>
<ul>
<li><p>去尾：当队列有新元素待入队，需要从队尾开始，删除影响队列单调性的元素，维护队列的单调性。去尾操作结束后，将该新元素入队列</p>
</li>
<li><p>删头：判断队头元素是否在待求解的区间之内，如果不在，就将其删除</p>
</li>
<li><p>取解：经过上面两个操作，取出队列的头元素 ，就是当前区间的极值</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调递减队列</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i]) &#123;</span><br><span class="line">        dq.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">// 控制队列长度</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>() - dq.<span class="built_in">front</span>() &gt; k - <span class="number">1</span>) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">列表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:27:45" itemprop="dateCreated datePublished" datetime="2023-04-02T16:27:45+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>链表是线型表结构，但不需要连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/01.jpg" class="">

<p>链表结构非常多，常见的链表结构：单链表、双向链表和循环链表</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>链表通过指针将一组零散的内存块串联起来，把内存块称为链表的结点</p>
<p>为了将所有结点串联起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，把这个记录下一个结点地址的指针叫做后继指针 next</p>
<p>第一个结点（头结点）和最后一个结点（尾结点）比较特殊；头结点用来记录链表的基地址，尾结点的 next 指针指向一个空地址 NULL，表示这是链表的最后一个结点</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/02.jpg" class="">

<p>因为链表本身内存不连续，所以在链表中插入和删除一个数据不需要搬运转移，所以操作数据非常快</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/03.jpg" class="">

<p>但链表要随机访问一个元素就没有数组那么高效，它不能像数组一样通过首地址和下标来寻址对应的内存地址，而是需要根据指针一个结点一个结点的依次遍历，直到找到相应的结点</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>跟单链表的区别在于尾结点不是指向 NULL，而是指向头结点</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/04.jpg" class="">

<p>循环链表的优点是从链尾到链头比较方便</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/05.jpg" class="">

<p>如果存储同样多的数据，双向链表比单链表占用更多的内存空间，但支持双向遍历，带来了双向链表操作的灵活性；双向链表的删除、插入都比单向链表高效</p>
<h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/06.jpg" class="">

<h2 id="链表、数组比较"><a href="#链表、数组比较" class="headerlink" title="链表、数组比较"></a>链表、数组比较</h2><img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/07.jpg" class="">

<h2 id="利用哨兵简化单链表操作"><a href="#利用哨兵简化单链表操作" class="headerlink" title="利用哨兵简化单链表操作"></a>利用哨兵简化单链表操作</h2><p>针对单链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理，这样代码会<br>很繁琐、不简洁，而且容易因为考虑不全而出错</p>
<p>引入哨兵结点，在任何时候不管链表是不是空，head 指针都会一直指向哨兵结点；把这种有哨兵结点的链表叫带头链表，没有哨兵结点的链表叫做不带头链表</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/08.jpg" class="">

<h2 id="单链表有环的问题"><a href="#单链表有环的问题" class="headerlink" title="单链表有环的问题"></a>单链表有环的问题</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hiddenfox/p/3408931.html">总结</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ListNode * fast = head, * slow = head;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(fast == slow)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 环</span></span><br><span class="line">    &#125;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 没有环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 环的长度</span></span><br><span class="line"><span class="comment">方法一：快慢指针相遇后，让快指针不动，慢指针继续运动到再次相遇，走过的路程就是环的长度</span></span><br><span class="line"><span class="comment">方法二：环的长度等于第一次相遇时循环的次数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 环的开始节点</span></span><br><span class="line"><span class="comment">两个指针分别从第一个节点和快慢指针相遇的节点开始遍历，相遇处为环开始节点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="单链表翻转"><a href="#单链表翻转" class="headerlink" title="单链表翻转"></a>单链表翻转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.就地翻转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *pre </span>= head, *cur = head-&gt;next;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 新建链表，头结点插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *cur </span>= head, *nex = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        cur = nex;</span><br><span class="line">        <span class="keyword">if</span>(nex) nex = nex-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 利用栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!head)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *cur </span>= head;</span><br><span class="line">	dummy.next = head;</span><br><span class="line">	stack&lt;ListNode *&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (cur)</span><br><span class="line">	&#123;</span><br><span class="line">		s.<span class="built_in">push</span>(cur);</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = &amp;dummy;</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ListNode * temp = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">		cur-&gt;next = temp;</span><br><span class="line">		cur = temp;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    head = dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 递归</span></span><br><span class="line">ListNode * head = <span class="literal">nullptr</span>;  <span class="comment">// 全局变量，反转链表的头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resverseList</span><span class="params">(ListNode * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reverseList</span>(node-&gt;next);</span><br><span class="line">        node-&gt;next-&gt;next = node;</span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个链表相交"><a href="#两个链表相交" class="headerlink" title="两个链表相交"></a>两个链表相交</h3><ul>
<li>两个链表无环</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 判断链表连接后是否有环</span></span><br><span class="line"><span class="comment">先遍历第一个链表到他的尾部，然后将尾部的 next 指针指向第二个链表头部第一个节点(尾部指针的 next 本来指向的是 null)，这样两个链表就合成了一个链表，判断原来的两个链表是否相交也就转变成了判断新的链表是否有环的问题了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">从第二个链表的头部进行遍历，找到第一个和第一个链表重复的节点即是两个链表的交点；如果找到最后为 null，则说明两个单向链表不相交</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种方法不容易找到相交点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 从相同长度处开始遍历</span></span><br><span class="line"><span class="comment">两个链表如果相交的话，那么最后的一个节点一定是相同的，否则是不相交的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分别遍历到两个链表的尾部，然后判断他们是否相同，如果相同，则相交；否则不相交</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">假设第一个链表长度为 len1，第二个 len2，然后找出长度较长的，让长度较长的链表指针向后移动 len1 - len2，然后在开始遍历两个链表，判断节点是否相同即可</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3. 使用 hash 表进行判断</span></span><br><span class="line"><span class="comment">4. 使用两个栈进行判断</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一个有环一个无环则不可能相交</p>
</li>
<li><p>两个都有环，相交于环外，两个链表共用一个环，从假装从环开始节点处断开，当做两个没有环的链表处理</p>
</li>
</ul>


<ul>
<li>两个都有环，相交于入口处，两个链表共用一个环，则选取一条链找这条链的环开始节点即可</li>
</ul>


<ul>
<li>两个都有环，相交于环内</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有两个相交点，各自的环入口节点即为各自第一次相交的节点</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/" class="post-title-link" itemprop="url">堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:21:33" itemprop="dateCreated datePublished" datetime="2023-04-02T16:21:33+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>堆是一种特殊的树</p>
<ol>
<li><p>堆是一个完全二叉树。除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列</p>
</li>
<li><p>堆中每一个节点的值都大于等于（或小于等于）其子树中每个节点的值。每个节点的值都大于等于子树中每个节点值的堆为大顶堆，每个节点都小于等于子节点的堆为小顶堆</p>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>完全二叉树比较适合用数组来存储，这样不需要存储左右节点的指针，单纯通过数组的下标就可以找到一个节点的左右子节点和父节点</p>
<p>数组下标为 i 的节点，左子节点下标为 2 * i，右子节点下标为 2 * i + 1，父节点下标为 i &#x2F; 2，i 需要从 1 开始</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/01.jpg" class="">

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>往堆中插入一个元素后，需要进行调整让其满足堆的特性，叫做堆化</p>
<p>堆化可以顺着节点所在路径向上或向下，然后对比交换</p>
<p>从下往上的堆化：</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/02.jpg" class="">

<h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><p>把最后一个节点放到堆顶，然后利用父子节点对比方法，互换两个节点，直到父子节点之间满足大小关系为止</p>
<p>从上往下的堆化：</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/03.jpg" class="">

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>堆化的时间复杂度 O(logn)，插入和删除堆顶元素的主要逻辑是堆化所以时间复杂度也是 O(logn)</p>
<p>堆排序的建堆过程时间复杂度 O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">heap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">heap</span>() : <span class="built_in">h</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从下往上堆化</span></span><br><span class="line">    h.<span class="built_in">push_back</span>(n);</span><br><span class="line">    <span class="type">int</span> pos = h.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos / <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (h[pos] &gt; h[pos / <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[pos], h[pos / <span class="number">2</span>]);</span><br><span class="line">        pos /= <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = h.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">swap</span>(h[pos], h[<span class="number">1</span>]);</span><br><span class="line">    h.<span class="built_in">pop_back</span>();</span><br><span class="line">    pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">2</span> * pos &gt;= h.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> * pos + <span class="number">1</span> &gt;= h.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[pos] &lt; h[pos * <span class="number">2</span>]) &#123;</span><br><span class="line">          <span class="built_in">swap</span>(h[pos], h[<span class="number">2</span> * pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[<span class="number">2</span> * pos] &gt; h[<span class="number">2</span> * pos + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (h[pos] &lt; h[<span class="number">2</span> * pos]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(h[pos], h[<span class="number">2</span> * pos]);</span><br><span class="line">            pos = <span class="number">2</span> * pos;</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (h[pos] &lt; h[<span class="number">2</span> * pos + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(h[pos], h[<span class="number">2</span> * pos + <span class="number">1</span>]);</span><br><span class="line">            pos = <span class="number">2</span> * pos + <span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">哈希表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-02 16:19:24" itemprop="dateCreated datePublished" datetime="2023-04-02T16:19:24+08:00">2023-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 16:41:02" itemprop="dateModified" datetime="2024-08-06T16:41:02+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>哈希表用的是数组支持按照下标随机访问数据特性，所以哈希表其实就是数组的一种扩展，由数组演化而来</p>
<p>数组存储的值与数组下标形成映射，所以利用数组支持根据下标随机访问时间复杂度 O(1) 的特性，可以快速查找</p>
<p>存储的值为哈希键（key）<br>将哈希键转换为数组下标的映射方法为哈希函数（hash function），得到的值为哈希值（value)</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/01.png" class="">

<p>通过哈希函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置</p>
<p>当按照键值查询数据时，可以用同样的哈希函数将键值转化为数组下标，从对应的数组下标的位置获取数据</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>把它定义成 hash(key)，key 表示元素的键值，经过哈希函数计算得到哈希值</p>
<p>哈希函数设计的基本要求：</p>
<ul>
<li><p>哈希函数计算得到的哈希值是一个非负整数；因为数组下标从 0 开始，所以散列值必须是非负整数</p>
</li>
<li><p>如果 key1 &#x3D; key2，那 hash(key1) &#x3D;&#x3D; hash(key2)；相同的 key，经过哈希函数得到的值也应该相同</p>
</li>
<li><p>如果 key1 !&#x3D; key2，那 hash(key1) !&#x3D; hash(key2)；无法避免哈希冲突</p>
</li>
</ul>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>再好的哈希函数也无法避免哈希冲突，常用开放寻址法和链表法来解决</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>核心思想是如果出现了哈希冲突，就重新探测一个空闲位置将其插入；插入方法有：线性探测、二次探测和双重哈希</p>
<ol>
<li>线性探测：当往哈希表中插入数据时，如果某个数据经过哈希函数之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止</li>
</ol>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/02.png" class="">
<p>从图中可以看出，哈希表大小为 10，已经有 6 个元素插入到哈希表中；x 经过哈希函数得到哈希值 7，但这个位置已经有数据了，所以产生了冲突；按顺序一个一个往后找，看有没有空闲位置，遍历到尾部都没有找到空闲位置，于是再从表头开始找，直到找到空位 2，于是将其值插入到这个位置</p>
<p>在哈希表中查找元素的过程类似于插入过程；通过哈希函数求出查找元素的键值对应的哈希值，然后比较数组中下标为哈希值的元素和要查找的元素；如果相等，说明是要查找的元素，如果不是，则按顺序往后依次查找，如果遍历到数组中的空位位置，还没找到，则说明查找到的元素不在哈希表中</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/03.png" class="">

<p>哈希表跟数组一样，不仅支持插入、查找，还支持删除，对于使用线性探测的哈希表，删除操作有些不同，不能单纯地把要删除的元素设置为空，因为在查找的时候，通过找到一个空闲位置来判定数据在不在哈希表中，如果这个空闲位置是后来删除的，就会导致原来的查找算法失败，本来存在数据会被认为不存在；为解决这个问题，可以将删除的元素特殊标记为 deleteed，当线性探测查找的时候，遇到标记为 deleted 的空间，并不停下来而是继续探测</p>
<img src="/2023/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/04.png" class="">
<p>线性探测存在很大的问题，当散列表插入的数据越来越多时，哈希冲突发生的可能性就越来越大，空闲位置会越来越少，线性探测的时间就会越来越久；极端情况下可能需要探测整个哈希表，所以最坏的时间复杂度是 O(n)；同理，删除和查找时也有可能会线性探测整张哈希表才能查找或删除数据</p>
<ol start="2">
<li>二次探测：线性探测每次探测的步长是 1，二次探测步长是线性探测的二次方</li>
</ol>
<p>线性探测的下标序列：hash(key)+0、hash(key)+1、hash(key)+2、…</p>
<p>二次探测的下标序列是：hash(key)+0^2、hash(key)+1^2、hash(key)+2^2、…</p>
<ol start="3">
<li>双重哈希：先用一个哈希函数，如果计算得到的存储位置被占用，再用第二个哈希函数，以此类推直到找到空闲的存储位置</li>
</ol>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>在每一个表格元素中维护一个 <code>list</code>，哈希函数为元素分配一个 <code>list</code>，然后在 <code>list</code> 上执行元素的插入、搜寻、删除等操作</p>
<p>使用链表法，装载因子将大于 1</p>
<p>但不管采用哪种探测方法，当哈希表中位置不多时，哈希冲突的概率大大提高；为了保证哈希表的操作效率，一般情况下尽可能保证哈希表中有一定比例的空闲槽位，用装载因子来表示空位的多少</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">装载因子 = 填入表中的元素个数 / 散列表长度</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/35/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><span class="page-number current">36</span><a class="page-number" href="/page/37/">37</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/37/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chaxxro</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
