<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chaxxro.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="好记性不如烂键盘">
<meta property="og:type" content="website">
<meta property="og:title" content="也无风雨也无晴">
<meta property="og:url" content="https://chaxxro.github.io/page/38/index.html">
<meta property="og:site_name" content="也无风雨也无晴">
<meta property="og:description" content="好记性不如烂键盘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chaxxro">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaxxro.github.io/page/38/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/38/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>也无风雨也无晴</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">也无风雨也无晴</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chaxxro</p>
  <div class="site-description" itemprop="description">好记性不如烂键盘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">411</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:35:40" itemprop="dateCreated datePublished" datetime="2023-04-01T16:35:40+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><p>排序算法的内存消耗：针对排序算法的空间复杂度，引入原地排序概念，即空间复杂度 O(1) 的排序算法</p>
</li>
<li><p>排序算法的稳定性：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变</p>
</li>
<li><p>有序度、逆序度：对于包含n个数据的数组，有 n! 种排列方式。有序度是数组中具有有序关系的元素对的个数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 有序元素对：a[i] &lt;= a[j]  i &lt; j</span><br><span class="line">// 完全有序的数组：有序度 n * (n - 1) / 2</span><br><span class="line">// 逆序元素对：a[i] &gt; a[j]  i &lt; j</span><br><span class="line">// 逆序度 = 满有序度 - 有序度</span><br></pre></td></tr></table></figure>
<p>排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/10.png" class="">

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据，每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它们交换；</p>
<p>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作</p>
<p>当某次冒泡操作没有进行数据交互时，说明已经排序完成了，可以不再继续冒泡操作了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubblesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j] &gt; v[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[j], v[j + <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>冒泡排序只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度为 O(1)，故是原地排序</p>
</li>
<li><p>冒泡排序在相邻两个元素大小相等时不做交换，所以相同大小的数据在排序前后不会改变顺序，故冒泡排序是稳定的排序算法</p>
</li>
<li><p>时间复杂度：平均时间复杂度 O(n^2)，最坏复杂度 O(n^2)，最好复杂度 O(n)</p>
</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/01.jpg" class="">

<p>将数组中的数据分为两个区间，已排序区间和未排序区间</p>
<p>插入排序的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空</p>
<p>初始已排序区间只有一个元素</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/02.jpg" class="">

<p>插入排序包含两种操作，元素的比较和元素的移动；对于一个给定的初始序列，移动操作的次数总是固定的，即逆序度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j + <span class="number">1</span>] &lt; v[j]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[j + <span class="number">1</span>], v[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>插入排序是原地排序</p>
</li>
<li><p>插入排序是稳定排序</p>
</li>
<li><p>复杂度：平均时间复杂度 O(n^2)，最坏复杂度 O(n^2)，最好复杂度 O(n)</p>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序也分已排序区间和未排序区间，但选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾，每次操作确定一个元素的正确位置</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/03.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> pos = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; size; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j] &lt; v[pos]) &#123;</span><br><span class="line">				pos = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[i], v[pos]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>选择排序是原地排序</p>
</li>
<li><p>选择排序是稳定排序</p>
</li>
<li><p>复杂度：平均时间复杂度 O(n^2)，最好最坏复杂度都是 O(n^2)</p>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>核心思想就是分治，将一个大问题分解成小的子问题；使用递归来实现</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/04.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">merge</span>(v, start, mid);</span><br><span class="line">	<span class="built_in">merge</span>(v, mid + <span class="number">1</span>, end);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(end - start + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (k &lt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; mid + <span class="number">1</span> &amp;&amp; j &lt; end + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[i] &lt; v[j]) &#123;</span><br><span class="line">				tmp[k++] = v[i++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				tmp[k++] = v[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i &lt; mid + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (i &lt; mid + <span class="number">1</span>) &#123;</span><br><span class="line">				tmp[k++] = v[i++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; end + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; end + <span class="number">1</span>) &#123;</span><br><span class="line">				tmp[k++] = v[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> p = start; p &lt;= end; ++p) &#123;</span><br><span class="line">		v[p] = tmp[p - start];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">merge</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>归并排序是稳定排序</p>
</li>
<li><p>时间复杂度：归并排序最好、最坏和平均时间复杂度都是 O(nlogn)</p>
</li>
<li><p>空间复杂度：归并排序的合并函数需要借助额外的存储空间，空间复杂度为 O(n)</p>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>如果要排序数组中下标从 p 到 r 之间的一组数据，选择中间任意一个数组作为分区点 pivot</p>
<p>遍历 p 到 r 之间的数据，将小于 pivot 的放左边，大于 pivot 的放右边，将 pivot 放中间</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/05.jpg" class="">

<p>原地分区过程：</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/06.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/07.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pos = start;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[i] &lt; v[end]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(v[pos++], v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(v[pos], v[end]);</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &lt;= start) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> p = <span class="built_in">partition</span>(v, start, end);</span><br><span class="line">	<span class="built_in">quicksort</span>(v, start, p - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quicksort</span>(v, p + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">quicksort</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>快排原地不稳定排序</p>
</li>
<li><p>空间复杂度 O(1)</p>
</li>
<li><p>当 pivot 选择合适，每次将区间分为大小相近的两个小区间，则快排最好时间复杂度是 O(nlogn)。当 pivot 选择不合适，每次分区得到的两个区间都不均等，需要进行 n 次分区操作，则最坏时间复杂度 O(n^2)，所以可以通过合理的选择 pivot 来避免这种情况。平均时间复杂度是 O(nlogn)</p>
</li>
</ul>
<p>这种 O(n^2) 时间复杂度出现的主要原因还是因为分区点选得不够合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。改进方法：</p>
<ol>
<li><p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。但是，如果要排序的数组比较大，那三数取中可能就不够了，可能要五数取中或者十数取中</p>
</li>
<li><p>每次从要排序的区间中随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的</p>
</li>
</ol>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序时间复杂度非常稳定，是 O(nlogn)，并且还是原地排序算法</p>
<p>堆排序的过程大致分解成两个大的步骤，建堆和排序</p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>将数组原地建成一个堆，不借助另一个数组，在原数组上操作</p>
<ul>
<li><p>从下往上堆化：借助堆插入思路，假设堆中只包含一个数据，就是下标为 0 的数据。通过调用插入操作，将下标从 1 到 n-1 的数据依次插入到堆中，每个数据插入堆中</p>
</li>
<li><p>从上往下堆化：因为叶子节点往下堆化只能跟自己比较，所以从第一个非叶子节点开始，即下标从 n&#x2F;2-1 开始到 1 的数据进行堆化，下标 n&#x2F;2 到 n-1 的节点都是叶子节点，不需要堆化</p>
</li>
</ul>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/11.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/12.jpg" class="">

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>建堆结束之后，数组中的数据已经按照大顶堆的特性组织的</p>
<p>把数组中第一个元素跟最后一个元素交换，最大元素就放到了下标为 n 的位置，类似于删除堆顶元素操作。堆顶元素移除后把下标为 n 的元素放到堆顶，然后再堆化，以此类推完成排序</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/13.jpg" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当元素下标为 n，其父节点 (n - 1) / 2，子节点 2n + 1 + k，k 取 0 和 1</span></span><br><span class="line"><span class="comment">注意这里是以 0 为基准的下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从下往上，依次将下标 1～n-1 的数据插入堆中</span></span><br><span class="line">  <span class="comment">// for (int i = 1; i &lt; n; ++i) &#123;</span></span><br><span class="line">  <span class="comment">//    int j = i;</span></span><br><span class="line">  <span class="comment">//    while (j &gt; 0) &#123;</span></span><br><span class="line">  <span class="comment">//            int p = (j - 1) / 2;</span></span><br><span class="line">  <span class="comment">//            if (v[p] &lt; v[j]) &#123;</span></span><br><span class="line">  <span class="comment">//                    swap(v[p], v[j]);</span></span><br><span class="line">  <span class="comment">//                    j = p;</span></span><br><span class="line">  <span class="comment">//            &#125;</span></span><br><span class="line">  <span class="comment">//            else break;</span></span><br><span class="line">  <span class="comment">//    &#125;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从上往下，从第一个非叶子结点开始向下堆化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="type">int</span> l = <span class="number">2</span> * j + <span class="number">1</span>, r = <span class="number">2</span> * j + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (r &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (v[l] &lt; v[r])</span><br><span class="line">          tmp = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          tmp = l;</span><br><span class="line">        <span class="keyword">if</span> (v[j] &lt; v[tmp]) &#123;</span><br><span class="line">          <span class="built_in">swap</span>(v[j], v[tmp]);</span><br><span class="line">          j = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[j] &lt; v[l]) &#123;</span><br><span class="line">          <span class="built_in">swap</span>(v[j], v[l]);</span><br><span class="line">          j = l;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="built_in">build_heap</span>(v, size - i);</span><br><span class="line">    <span class="built_in">swap</span>(v[size - <span class="number">1</span> - i], v[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与快排比较"><a href="#与快排比较" class="headerlink" title="与快排比较"></a>与快排比较</h3><ol>
<li><p>堆排序数据访问方式没有快排友好：堆排跳着访问数据，快排顺序访问数据，对 CPU 缓存不友好</p>
</li>
<li><p>对于同样的数据，在排序过程中，堆排数据交换次数多于快排</p>
</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p>优先级队列：将一个堆看做一个优先级队列，往优先级队列中插入元素相当于往堆中插入一个元素，从优先级队列中取出有优先级最高的元素相当于取出堆顶元素</p>
</li>
<li><p>求 TopK</p>
</li>
<li><p>求中位数</p>
</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法</p>
<p>希尔排序将全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性朝最终位置移动一大步。然后再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; size; i += step) &#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; j + step &lt; size; j += step) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + step] &lt; nums[j]) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(nums[j + step], nums[j]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> step = nums.<span class="built_in">size</span>() / <span class="number">2</span>; step &gt; <span class="number">0</span>; --step) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; ++i) &#123;</span><br><span class="line">      <span class="built_in">shellsort</span>(nums, i, step);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>当要排序 n 个数据所处的范围并不大的时候，比如最大值为 k，就可以把数据划分 k 个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间</p>
<p>因为只涉及扫描遍历操作，所有时间复杂度是 O(n+k)</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/09.jpg" class="">
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序</p>
<p>桶内排完序之后再把每个桶里的数据按照顺序依次去除，组成的序列就是有序的了</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/08.jpg" class="">

<ul>
<li><p>桶排序的时间复杂度接近 O(n)</p>
</li>
<li><p>桶排序对排序数据的要求非常苛刻：要排序的数据需要很容易地划分成 m 个桶，并且桶与桶之间有着天然的大小顺序，这样每个桶内的数据排序完后桶与桶之间的数据不需要再进行排序。数据在各个桶之间的分布是比较均匀的，在低端情况下会退化为 O(nlogn) 的排序</p>
</li>
<li><p>桶排序比较适合用于外部排序中，即数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中</p>
</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序对要排序的数据是有要求的，需要能分割出独立的位来比较，而且位之间有递进关系，如果高位的数据大则剩下地位则不需要比较。而且每位的数据范围不能大，能采用线性排序算法来排序</p>
<h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><p>线性排序算法的时间复杂度底但适用场景比较特殊，不适合用于通用的排序算法；</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；但如果对大规模数据进行排序，时间复杂度为 O(nlogn) 的算法更加高效；所以一般首选时间复杂度为 O(nlogn) 的排序算法来实现排序函数</p>
<p>因为归并排序的控件复杂度为 O(n^2)，不是原地排序，所以一般采用快速排序算法</p>
<h3 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h3><p>快速排序在最坏情况下的时间复杂度为 O(n^2)，这种情况的出现原因主要是因为分区点的选择不够合理</p>
<p>最理想的分区点是：被区分点分开的两个分区中，数据的数据量差不多；为了提高地让每次分区都比较平均</p>
<ol>
<li><p>三数取中法，从区间的首、尾、中间分别取数，对比大小后取 3 个数的中间值作为分区点</p>
</li>
<li><p>随机法</p>
</li>
</ol>
<p>每次从要排序的区间中，随机选择一个元素作为分区点；虽然不能保证每次分区点都选的比较好，但是从概率的角度，平均情况下分区点事比较好的</p>
<h3 id="递归注意事项"><a href="#递归注意事项" class="headerlink" title="递归注意事项"></a>递归注意事项</h3><p>递归要警惕堆栈溢出，递归过深而堆栈过小，导致堆栈溢出</p>
<ol>
<li><p>限制递归深度</p>
</li>
<li><p>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/" class="post-title-link" itemprop="url">贪心算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:34:39" itemprop="dateCreated datePublished" datetime="2023-04-01T16:34:39+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下期望值最大。这类问题首先联想到贪心算法</p>
<p>大部分情况下，能用贪心解决的问题，得出结果的正确性是显而易见的。但实际上，贪心并不总能给出全局最优解</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="分糖果："><a href="#分糖果：" class="headerlink" title="分糖果："></a>分糖果：</h3><p>m 个糖果和 n 个孩子，m &lt; n，把糖果分给这些孩子吃，所以糖果只能分配给一部分孩子</p>
<p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm</p>
<p>每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足，小孩需求分别是 g1，g2，g3，……，gn</p>
<p>如何分配糖果，能尽可能满足最多数量的孩子？可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的</p>
<p>这个问题的限制值就是糖果个数 m，对于一个孩子来说，如果小的糖果可以满足，就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子</p>
<p>所以可以从需求小的孩子开始分配糖果，满足一个需求大的孩子跟满足一个需求小的孩子，对期望值的贡献是一样的。每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p>
<h3 id="钱币找零"><a href="#钱币找零" class="headerlink" title="钱币找零"></a>钱币找零</h3><p>假设有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。用这些钱来支付 K 元，最少要用多少张纸币呢？</p>
<p>肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐</p>
<p>在贡献相同期望值（纸币数目）的情况下，希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路</p>
<h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h3><p>假设有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]</p>
<p>从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？     </p>
<p>这个问题的解决思路是这样的：假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上</p>
<p>按照起始端点从小到大的顺序对这 n 个区间排序。每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:29:19" itemprop="dateCreated datePublished" datetime="2023-04-01T16:29:19+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>动态规划适合用来求解最优问题，比如最大值、最小值等，它可以显著地降低时间复杂度，提高代码的执行效率</p>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><h3 id="回溯算法实现"><a href="#回溯算法实现" class="headerlink" title="回溯算法实现"></a>回溯算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxW = INT_MIN;  <span class="comment">// 结果放到 maxW 中</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">5</span>] &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;  <span class="comment">// 物品重量</span></span><br><span class="line"><span class="type">int</span> w = <span class="number">9</span>;  <span class="comment">// 背包承受最大重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cw)</span>  <span class="comment">// 现考察是否装入第 i(0-4) 个物品，目前背包重量 cw</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == <span class="number">5</span>)  <span class="comment">// cw == w 表示装满了  i == 5 表示物品都考擦完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW)   maxW = cw;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f</span>(i + <span class="number">1</span>, cw);  <span class="comment">// 选择不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + weight[i] &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(i + <span class="number">1</span>, cw + weight[i]);  <span class="comment">// 装第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01.jpg" class="">

<p>递归树中的每个节点表示一种状态，用 (i, cw) 表示</p>
<p>从递归树中可以发现有些子问题是重复的，比如 f(2, 2) 和 f(3, 4) 都被重复计算了两次，通过记录 f(i, cw) 的值避免冗余计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxW = INT_MIN;  <span class="comment">// 结果放到 maxW 中</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">5</span>] &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;  <span class="comment">// 物品重量</span></span><br><span class="line"><span class="type">int</span> w = <span class="number">9</span>;  <span class="comment">// 背包承受最大重量</span></span><br><span class="line"><span class="type">bool</span> mem[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cw)</span>  <span class="comment">// 现考察是否装入第 i(0-4) 个物品，目前背包重量 cw</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == <span class="number">5</span>)  <span class="comment">// cw == w 表示装满了  i == 5 表示物品都考擦完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW)   maxW = cw;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mem[i][cw])  <span class="keyword">return</span>;  <span class="comment">// 重复状态</span></span><br><span class="line">    mem[i][cw] = <span class="literal">true</span>;  <span class="comment">// 记录 (i, cw) 这个状态</span></span><br><span class="line">    <span class="built_in">f</span>(i + <span class="number">1</span>, cw);  <span class="comment">// 选择不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + weight[i] &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(i + <span class="number">1</span>, cw + weight[i]);  <span class="comment">// 装第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; e : mem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; l : e)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划实现"><a href="#动态规划实现" class="headerlink" title="动态规划实现"></a>动态规划实现</h3><p>把整个求解过程分为 n 个阶段，每个阶段决策一个物品是否放入背包中，每个物品决策（放入或不放入）完之后，背包的物品重量会有多种情况</p>
<p>把每一层重复的状态合并，只记录不同的状态，然后基于上一层的状态集合来推导一下层的状态集合；通过合并每一层重复的状态，就保证了每一层不同状态的个数都不会冲过 w 个（w 表示背包的承载重量）</p>
<p>用二维数组 <code>bool states[n][w + 1]</code> 来记录每层可以达到的不同状态</p>
<p>第 0 个（下标从 0 开始编号）物品重量是 2，要么装入要么不装入，对应背包两种状态，用 <code>states[0][0] = true, states[0][2] = true</code> 来表示这两种状态</p>
<p>第 1 个物品重量是 2，基于之前的背包状态，在决策完这个物品之后会有 3 个不同的状态，分别是 0(0 + 0), 2(0 + 2, 2 + 0), 4(2 + 2)，用 <code>states[1][0] = true, states[1][2] = true, states[0][4] = true</code></p>
<p>以此类推，考察完所有物品后，整个状态数组都计算好了，只需要在最后一层找一个值为 true 的最接近 w 的值，就是背包中物品重量的最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">bool</span> ** states, <span class="type">int</span> n, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    states = <span class="keyword">new</span> <span class="type">bool</span>* [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        states[i] = <span class="keyword">new</span> <span class="type">bool</span> [w + <span class="number">1</span>];  <span class="comment">// w + 1 个状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行的数据要特殊处理，可利用哨兵优化</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w)    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不把第 i 个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j])    states[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把第 i 个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w - weight[i]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j])    states[i][j + weight[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = w; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n - <span class="number">1</span>][i] == <span class="literal">true</span>)    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/02.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/03.jpg" class="">

<p>动态规划思想：把问题分解为多个阶段，每个阶段对应一个决策，记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合去推导下一个阶段的状态集合，动态地往前推进</p>
<p>尽管动态规划的执行效率比较高，但上面的代码需要额外申请一个 n * (w + 1) 的二维数组，空间消耗比较大（空间换时间）</p>
<p>实际上只需要一个大小为 w + 1的一维数组，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">bool</span> * states, <span class="type">int</span> n, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    states = <span class="keyword">new</span> <span class="type">bool</span> [w + <span class="number">1</span>];  <span class="comment">// w + 1 个状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行的数据要特殊处理，可利用哨兵优化</span></span><br><span class="line">    states[<span class="number">0</span>] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w)    states[weight[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一维数组只需要考虑放入背包的情况</span></span><br><span class="line">        <span class="comment">// 把第 i 个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = w - weight[i]; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里是从大到小来处理的</span></span><br><span class="line">            <span class="comment">// 如果换成 j 从小到大，会出现 for 循环里重复计算</span></span><br><span class="line">            <span class="keyword">if</span>(states[j])    states[j + weight[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = w; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[i] == <span class="literal">true</span>)    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包问题升级"><a href="#0-1-背包问题升级" class="headerlink" title="0-1 背包问题升级"></a>0-1 背包问题升级</h2><p>引入物品价值，对于一组不同重量、不同价值、不可分割的物品，如何选择物品在满足重量限制的前提下装入物品总价值最大</p>
<h3 id="回溯实现"><a href="#回溯实现" class="headerlink" title="回溯实现"></a>回溯实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxV = INT_MIN;  <span class="comment">// 最大价值</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">5</span>] &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;  <span class="comment">// 物品重量</span></span><br><span class="line"><span class="type">int</span> value[<span class="number">5</span>] &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> w = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cw, <span class="type">int</span> cv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv &gt; maxV)   maxV = cv;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f</span>(i + <span class="number">1</span>, cw, cv);  <span class="comment">// 不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + weight[i] &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(i + <span class="number">1</span>, cw + weight[i], cv + value[i]);  <span class="comment">// 选择第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/04.jpg" class="">

<p>对于 f(2, 2, 4) 和 f(2, 2, 3)，在背包物品重量一样的情况下 f(2, 2, 4) 的物品总价值更大，故可以舍弃 f(2, 2, 3)，只需要沿着 f(2, 2, 4) 的决策路线继续往下决策</p>
<p>也就是说对于 (i, cw) 相同的不同状态只保留 cv 最大的，继续递归处理，但回溯的办法就没办法适应了</p>
<h3 id="动态规划实现-1"><a href="#动态规划实现-1" class="headerlink" title="动态规划实现"></a>动态规划实现</h3><p>把整个求解过程分为 n 个阶段，每个阶段决策一个物品是否放入到背包中，每个阶段决策完之后，背包中的物品的总重量以及总价值会有多种情况，即会达到多种不同状态</p>
<p>用二维数组 <code>states[n][w + 1]</code> 来记录每层可达到的不同状态，数组存储的值是当前状态对应的最大总价值，把每层 (i, cw) 重复状态合并，只记录 cv 值最大的状态，然后基于这些状态来推导下一层的状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> * <span class="title">knapsack</span><span class="params">(<span class="type">int</span> ** states, <span class="type">int</span> n, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 states 数组</span></span><br><span class="line">    <span class="type">int</span> * states = <span class="keyword">new</span> <span class="type">int</span> * [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        states[i] = <span class="keyword">new</span> <span class="type">int</span> [w + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            states[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊处理第一行</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w)    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不选择第 i 个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>)   states[i][j] = states[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择第 i 个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= w - weight[i]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = states[i - <span class="number">1</span>][j] + value[i];</span><br><span class="line">                <span class="keyword">if</span>(v &gt; states[i][j + weight[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    states[i][j + weight[i]] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> maxv = <span class="number">-1</span>;  <span class="comment">// 计算的最大价值</span></span><br><span class="line">    <span class="type">int</span> minm = <span class="number">0</span>;  <span class="comment">// 最大价值对应的最大质量</span></span><br><span class="line">    <span class="keyword">for</span>(; minm &lt;= w; ++minm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n - <span class="number">1</span>][minm] &gt; maxv)    maxv = states[n - <span class="number">1</span>][minm];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反推组合情况</span></span><br><span class="line">    <span class="comment">// 在满足重量的情况下，价值都是 -1</span></span><br><span class="line">    <span class="keyword">if</span>(minm == w + <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line">    <span class="comment">// 在满足重量情况下，最大价值为 maxv，质量为 maxm</span></span><br><span class="line">    <span class="type">bool</span> * ans = <span class="keyword">new</span> <span class="type">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i&gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要选择第 i 个物品，必须重量不超标</span></span><br><span class="line">        <span class="comment">// 并且在决策第 i - 1 个物品后质量为 maxm - weight[i]</span></span><br><span class="line">        <span class="keyword">if</span>(maxm - weight[i] &gt;= <span class="number">0</span> &amp;&amp; states[i - <span class="number">1</span>][maxm- weight[i]] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxm = maxm - weight[i];</span><br><span class="line">            ans[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 states 数组倒推组合情况；由于状态 (i, j) 只能从 (i - 1, j) 或 (i - 1, j - value[i]) 两个状态推导过来，所以只需检查者两个状态是否可达</p>
<h2 id="什么问题适合用动态规划"><a href="#什么问题适合用动态规划" class="headerlink" title="什么问题适合用动态规划"></a>什么问题适合用动态规划</h2><h3 id="一个模型三个特征"><a href="#一个模型三个特征" class="headerlink" title="一个模型三个特征"></a>一个模型三个特征</h3><ul>
<li><p>多阶段决策最优解模型：解决问题的过程中需要经历多个决策阶段，每个决策阶段都对应一组状态；然后寻找一组决策序列，经过这组序列能够产生最终期望求解的最优解</p>
</li>
<li><p>最优子结构特征：问题最优解包含子问题的最优解，即可以通过子问题的最优解推导出问题的最优解，即后面阶段的状态可以通过前面阶段的状态推导出来</p>
</li>
<li><p>无后效性特征：一是在推导后面阶段状态时只关心前面阶段的状态值，而不关心这个状态时怎么一步一步推导出来的；二是某阶段一旦确定，就不受后面阶段的决策影响</p>
</li>
<li><p>重复子问题特征：不同决策序列，到达某个相同的阶段时，可能会产生重复的状态</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假设有个 n * n 的矩阵 w[n][n]，矩阵存储的都是正整数，棋子从起始位置运动到终止位置，每次只能向下移动一格或向右移动一格，把经过的格子的数字加起来作为路径的长度，求最短路径</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/05.jpg" class="">

<ul>
<li><p>一个模型：从 (0, 0) 到 (n - 1, n - 1) 总共要走 2 * (n - 1) 步，也就对应了 2 * (n - 1) 个阶段，并且每个阶段对应一个状态集合；状态定义为 min_dist(i, j)，i 表示行，j 表示列，min_dist(i, j) 的值表示从 (0, 0) 到 (i, j) 的最短路径长度</p>
</li>
<li><p>用回溯算法求解的递归树中有重复节点。即存在重复子问题特征</p>
</li>
<li><p>走到 (i, j) 时只能通过 (i - 1, j) 或 (i, j - 1) 这两个位置移动过来，所以计算 (i, j) 状态时只需要关心 (i - 1, j) 和 (i, j - 1) 两个位置对应的状态，并不关心是通过怎么样的路线到达这两个位置的，所以前面阶段的状态确定之后不会被后面阶段的决策改变。即存在无后效性特征</p>
</li>
<li><p>min_dist(i ,j) 可以通过 min_dist(i, j - 1) 和 min_dist(i - 1, j) 推导出来。即存在最优子结构特征</p>
</li>
</ul>
<h2 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h2><h3 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h3><p>一般能用动态规划解决的问题，都能通过回溯算法的暴力搜索解决，所以可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点然后对应画出递归树</p>
<p>第一种思路：找到重复子问题后，可以直接用回溯加记录的方法避免重复子问题，在执行效率上跟动态规划没有区别</p>
<p>第二种思路：状态转移表法，先画出一个状态表，一般是二维的，可以把它想象成二维数组，包括行、列、值三个变量；根据决策的先后过程从前往后，根据递推关系，分阶段填入状态表中的每个状态；最后将递推填表的过程翻译成代码；如果问题的状态比较复杂需要很多变量表示，可以将状态表写成高维的</p>
<p>回溯算法解决最短路径问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mindist = INT_MAX;  <span class="comment">// 最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// w[n][n] 数组表示格子的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minDist</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> dist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里已经到达了 n - 1, n - 1 这个位置</span></span><br><span class="line">    <span class="comment">// 与 mindist 比较的值是传入的 dist</span></span><br><span class="line">    <span class="keyword">if</span>(i == n &amp;&amp; j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist &gt; mindist)    mindist = dist;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往下走</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; n)   <span class="built_in">minDist</span>(i + <span class="number">1</span>, j, dist + w[i][j]);</span><br><span class="line">    <span class="comment">// 往右走</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; n)   <span class="built_in">minDist</span>(i, j + <span class="number">1</span>, dist + w[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/06.jpg" class="">

<p>虽然递归树中没有重复的 (i, j, dist), 但 (i, j) 有重复的，对于重复的 (i, j) 只保存 dist 最小的</p>
<p>画出二维状态表，行、列表示棋子所在的位置，值表示最短路径</p>
<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/07.jpg" class="">

<img src="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/08.jpg" class="">

<p>根据填表过程，翻译成代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义状态矩阵</span></span><br><span class="line">    <span class="type">int</span> ** states = <span class="keyword">new</span> <span class="type">int</span> * [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        states[i] = <span class="keyword">new</span> <span class="type">int</span> [n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化第一行第一列</span></span><br><span class="line">    <span class="type">int</span> sum_row = <span class="number">0</span>, sum_col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum_row += w[<span class="number">0</span>][i];</span><br><span class="line">        sum_col += w[i][<span class="number">0</span>];</span><br><span class="line">        states[<span class="number">0</span>][i] = sum_row;</span><br><span class="line">        states[i][<span class="number">0</span>] = sum_col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            states[i][j] = <span class="built_in">min</span>(states[i - <span class="number">1</span>][j], states[i][j - <span class="number">1</span>]) + w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> states[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h3><p>状态转移方程法类似递归，需要分析某个问题如果通过子问题来递归求解，也就是最优子结构，根据最优子结构写出递归公式，即状态转移方程</p>
<p>有两种代码实现方法，一种是递归加记录，一种是迭代递推</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line"><span class="built_in">min_dist</span>(i, j) = w[i][j] + <span class="built_in">min</span>(<span class="built_in">min_dist</span>(i, j - <span class="number">1</span>), <span class="built_in">min_dist</span>(i - <span class="number">1</span>, j))</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归加记录实现</span></span><br><span class="line"><span class="type">int</span> mem[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDist</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)    <span class="keyword">return</span> w[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(mem[i][j] &gt; <span class="number">0</span>)   <span class="keyword">return</span> mem[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minLeft = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)  minLeft =<span class="built_in">minDist</span>(i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> minUp = INT_MAX;</span><br><span class="line">    <span class="built_in">IF</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>)  minUp = <span class="built_in">minDist</span>(i - <span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line">    mem[i][j] = w[i][j] + <span class="built_in">min</span>(minLeft, minUp);</span><br><span class="line">    <span class="keyword">return</span> mem[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/" class="post-title-link" itemprop="url">分治算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:28:38" itemprop="dateCreated datePublished" datetime="2023-04-01T16:28:38+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>分治算法的核心思想其实就是四个字，分而治之，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解</p>
<p>分治算法一般都比较适合用递归来实现</p>
<p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>
<ol>
<li><p>分解：将原问题分解成一系列子问题</p>
</li>
<li><p>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</p>
</li>
<li><p>合并：将子问题的结果合并成原问题</p>
</li>
</ol>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ul>
<li><p>原问题与分解成的小问题具有相同的模式</p>
</li>
<li><p>原问题分解成的子问题可以独立求解，子问题之间没有相关性</p>
</li>
<li><p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解</p>
</li>
<li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BD%8D%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BD%8D%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">位操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:27:34" itemprop="dateCreated datePublished" datetime="2023-04-01T16:27:34+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="英文字符转小写"><a href="#英文字符转小写" class="headerlink" title="英文字符转小写"></a>英文字符转小写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">(<span class="string">&#x27;A&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="英文字符转大写"><a href="#英文字符转大写" class="headerlink" title="英文字符转大写"></a>英文字符转大写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;b&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">(<span class="string">&#x27;B&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;d&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">(<span class="string">&#x27;D&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="消除数字的二进制最后一个-1"><a href="#消除数字的二进制最后一个-1" class="headerlink" title="消除数字的二进制最后一个 1"></a>消除数字的二进制最后一个 1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t = n &amp; (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入一个无符号整数，返回二进制中 1 的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>(<span class="type">unsigned</span> <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断一个数是不是 2 的指数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/" class="post-title-link" itemprop="url">二分搜索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:24:16" itemprop="dateCreated datePublished" datetime="2023-04-01T16:24:16+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>每次通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到查找的元素，或者区间被缩小为 0</p>
<p>时间复杂度 O(logn)</p>
<ul>
<li>二分查找依赖的是顺序表，简单说是数组</li>
</ul>
<p>其他数据结构比如链表，是不能进行二分查找的，主要原因是二分查找需要按照下标随机访问元素，数组按下标随机访问数据的时间复杂度是O(1)，而链表随机访问时间复杂度是O(n)，所以如果数据使用链表存储，二分查找的时间复杂度就会变得很高</p>
<ul>
<li><p>二分查找针对的是有序数据</p>
</li>
<li><p>数据量太小不适合二分查找</p>
</li>
</ul>
<p>如果数据量很小，顺序遍历就足够了；只有数据量比较大的时候，二分查找的优势才会比较明显</p>
<p>但如果数据之前的比较操作耗时，不管数据量大小，都推荐适用二分查找</p>
<ul>
<li>数据量太大也不适合二分查找</li>
</ul>
<p>二分查找的底层依赖数组这种数据结构，而数组为了支持随机访问的特性，需要内存空间的连续，对内存的要求比较苛刻</p>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [left, right) 左闭右开区间</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最小的一个 l 使得 g(x) 为 true</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 写成 （left + right) / 2 有可能溢出，故写成这个形式</span></span><br><span class="line">      <span class="comment">// 可选</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">f</span>(mid))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">g</span>(mid))  <span class="comment">//  g(x) 在序列上右边全是 true，左边全是 false </span></span><br><span class="line">      &#123;</span><br><span class="line">          right = mid;  <span class="comment">// [left, mid)</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          left = mid + <span class="number">1</span>;  <span class="comment">// [mid + 1, right)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;  <span class="comment">// 这里的 left 有数组越界的可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF/" class="post-title-link" itemprop="url">回溯算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:23:06" itemprop="dateCreated datePublished" datetime="2023-04-01T16:23:06+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解</p>
<p>回溯的处理思想，有点类似枚举搜索，枚举所有的解，找到满足期望的解</p>
<p>为了有规律地枚举所有可能的解，避免遗漏和重复，可以把问题求解的过程分为多个阶段。每个阶段，都会面对一个岔路口，先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走</p>
<p>回溯算法非常适合用递归代码实现</p>
<p>经典问题：八皇后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;&#123;<span class="string">&quot;Q&quot;</span>&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">	vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">board</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = [&amp;](<span class="type">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(board[i] == board[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(board[r] - board[i] == r - i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(board[r] - board[i] == i - r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; helper = [&amp;](<span class="type">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n == r) &#123;</span><br><span class="line">			vector&lt;string&gt; <span class="built_in">temp</span>(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				temp[i][board[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				board[r] = i;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(r)) <span class="built_in">helper</span>(r + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">helper</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h2><p>0-1 背包是非常经典的算法问题，很多场景都可以抽象成这个问题模型，经典解法是动态规划，不过采用回溯算法更简单但没有那么高效的解法</p>
<p>有一个背包，背包总的承载重量是 W kg。现在有 n 个物品，每个物品的重量不等，并且不可分割，期望选择几件物品，装载到背包中，在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大</p>
<p>可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择，先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/LeetCode-1349/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/LeetCode-1349/" class="post-title-link" itemprop="url">lc-1349</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:01:49" itemprop="dateCreated datePublished" datetime="2023-04-01T16:01:49+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>DP + 位运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用行状态做 DP</span></span><br><span class="line"><span class="comment">dp[i][s]：第 i 行状态为 s 时的最多人数</span></span><br><span class="line"><span class="comment">dp[i + 1][s] = max(dp[i][t] + row(i + 1, t))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">取一个数的二进制子集</span></span><br><span class="line"><span class="comment">generate a subset of v</span></span><br><span class="line"><span class="comment">x = v</span></span><br><span class="line"><span class="comment">while x:</span></span><br><span class="line"><span class="comment">    x = (x - 1) &amp; v</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-students-taking-exam/">题目</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=QJvCYx1eGxE">分析</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/LeetCode-1416/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/LeetCode-1416/" class="post-title-link" itemprop="url">lc-1416</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:01:49" itemprop="dateCreated datePublished" datetime="2023-04-01T16:01:49+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>DP + 递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归形式：</span></span><br><span class="line"><span class="comment">int helper(string s) &#123;</span></span><br><span class="line"><span class="comment">    if(s.empty() == 0) return 1;</span></span><br><span class="line"><span class="comment">    if(s[0] == &#x27;0&#x27;) return 0;</span></span><br><span class="line"><span class="comment">    int ans = 0;</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt; s.length(); ++i) &#123;</span></span><br><span class="line"><span class="comment">        int num = stoi(s.substr(0, i));</span></span><br><span class="line"><span class="comment">        if(num &gt; K) break;</span></span><br><span class="line"><span class="comment">        ans += (ans + helper(s.substr(i))) % kmod;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return ans;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">使用 hash 记忆化后仍超时</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dp[i] : s[i ~ n] cnt</span></span><br><span class="line"><span class="comment">dp[i] = sum(dp[j]) j : i ~ n</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/restore-the-array//">题目</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=mdUTRI2FMtU">分析</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/01/LeetCode-1425/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/LeetCode-1425/" class="post-title-link" itemprop="url">lc-1425</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 16:01:49" itemprop="dateCreated datePublished" datetime="2023-04-01T16:01:49+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-04 16:29:17" itemprop="dateModified" datetime="2024-02-04T16:29:17+08:00">2024-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>DP + 滑动窗口 + BST + 单调队列</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/constrained-subsequence-sum/">题目</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=B5fa989qz4U&t=8s">分析</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/37/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><span class="page-number current">38</span><a class="page-number" href="/page/39/">39</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/39/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chaxxro</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
