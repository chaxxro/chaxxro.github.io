<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chaxxro.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="好记性不如烂键盘">
<meta property="og:type" content="website">
<meta property="og:title" content="也无风雨也无晴">
<meta property="og:url" content="https://chaxxro.github.io/page/18/index.html">
<meta property="og:site_name" content="也无风雨也无晴">
<meta property="og:description" content="好记性不如烂键盘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chaxxro">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaxxro.github.io/page/18/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/18/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>也无风雨也无晴</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">也无风雨也无晴</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chaxxro</p>
  <div class="site-description" itemprop="description">好记性不如烂键盘</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">411</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" class="post-title-link" itemprop="url">进程调度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-28 20:50:12" itemprop="dateCreated datePublished" datetime="2023-04-28T20:50:12+08:00">2023-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li><p>非抢占式调度算法：挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情</p>
</li>
<li><p>抢占式调度算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制</p>
</li>
</ul>
<h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><ul>
<li><p>CPU 利用率：如果运行的程序，发生了 I&#x2F;O 事件的请求，那 CPU 使用率必然会很低，为了提高 CPU 利用率，<br>在这种发生 I&#x2F;O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行</p>
</li>
<li><p>系统吞吐量：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）<br>的降低；要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量</p>
</li>
<li><p>周转时间：进程运行时间和进程等待时间总和称为周转时间；一个进程的周转时间越小越好</p>
</li>
<li><p>等待时间：处于就绪队列的进程不能等太久</p>
</li>
<li><p>响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准</p>
</li>
</ul>
<h2 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="非抢占式的先来先服务（First-Come-First-Severd-FCFS）"><a href="#非抢占式的先来先服务（First-Come-First-Severd-FCFS）" class="headerlink" title="非抢占式的先来先服务（First Come First Severd, FCFS）"></a>非抢占式的先来先服务（First Come First Severd, FCFS）</h3><p>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，<br>才会继续从队列中选择第一个进程接着运行</p>
<p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统</p>
<h3 id="非抢占式的最短作业优先（Shortest-Job-First-SJF）"><a href="#非抢占式的最短作业优先（Shortest-Job-First-SJF）" class="headerlink" title="非抢占式的最短作业优先（Shortest Job First, SJF）"></a>非抢占式的最短作业优先（Shortest Job First, SJF）</h3><p>优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量</p>
<p>对长作业不利，很容易造成一种极端现象</p>
<h3 id="非抢占式高响应比优先（Highest-Response-Ratio-Next-HRRN）"><a href="#非抢占式高响应比优先（Highest-Response-Ratio-Next-HRRN）" class="headerlink" title="非抢占式高响应比优先（Highest Response Ratio Next, HRRN）"></a>非抢占式高响应比优先（Highest Response Ratio Next, HRRN）</h3><p>每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行</p>
<p>等待时间越长，优先权越高</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/01.png" class="">

<h3 id="抢占式时间轮片"><a href="#抢占式时间轮片" class="headerlink" title="抢占式时间轮片"></a>抢占式时间轮片</h3><p>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行</p>
<p>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程</p>
<p>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换</p>
<h3 id="最高优先级"><a href="#最高优先级" class="headerlink" title="最高优先级"></a>最高优先级</h3><p>从就绪队列中选择最高优先级的进程进行运行</p>
<p>进程的优先级可以分为，静态优先级或动态优先级：</p>
<ul>
<li><p>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化</p>
</li>
<li><p>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级</p>
</li>
</ul>
<p>该算法还分为抢占式和非抢占式：</p>
<ul>
<li><p>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程</p>
</li>
<li><p>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行</p>
</li>
</ul>
<h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><p>多级反馈队列是时间片轮转和最高优先级的综合和发展</p>
<p>多级：有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短</p>
<p>反馈：如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/02.png" class="">

<ul>
<li><p>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短</p>
</li>
<li><p>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成</p>
</li>
<li><p>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行</p>
</li>
</ul>
<p>对于短作业可能可以在第一级队列很快被处理完；对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-28 20:48:52" itemprop="dateCreated datePublished" datetime="2023-04-28T20:48:52+08:00">2023-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>线程是进程的子任务，是 CPU 调度和分派的基本单位，实现进程内部的并发</p>
<p>进程内每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源</p>
<h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><ul>
<li><p>用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理</p>
</li>
<li><p>内核线程：在内核中实现的线程，是由内核管理的线程</p>
</li>
<li><p>轻量级进程：在内核中来支持用户线程</p>
</li>
</ul>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/01.png" class="">

<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/02.png" class="">

<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/03.png" class="">

<h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>用户线程是基于用户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB）<br>也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB</p>
<p>用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，<br>包括线程的创建、终止、同步和调度等</p>
<p>优点：</p>
<ul>
<li><p>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），<br>TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统</p>
</li>
<li><p>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了</p>
</li>
<li><p>当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的</p>
</li>
<li><p>由于时间片分配给进程，在多线程执行时，每个线程得到的时间片较少，执行会比较慢</p>
</li>
</ul>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责</p>
<p>优点：</p>
<ul>
<li><p>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行</p>
</li>
<li><p>多线程的进程获得更多的 CPU 运行时间</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB</p>
</li>
<li><p>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-28 20:47:10" itemprop="dateCreated datePublished" datetime="2023-04-28T20:47:10+08:00">2023-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发</p>
<ul>
<li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程，线程依赖于进程而存在</p>
</li>
<li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存；资源分配给进程，同一进程的所有线程共享该进程的所有资源，共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）；每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量</p>
</li>
<li><p>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</p>
</li>
<li><p>进程切换的开销远大于线程切换的开销；在创建或撤消进程时，系统都要为之分配或回收资源，因此系统开销远大于创建或撤销线程的开销</p>
</li>
<li><p>由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信可以使用直接读写进程数据段（如全局变量）；进程通信需要使用进程同步和互斥手段来保证数据的一致性</p>
</li>
<li><p>进程编程调试简单可靠性高，线程编程调试相对复杂</p>
</li>
<li><p>进程间不会相互影响；一个线程挂掉将导致整个进程挂掉</p>
</li>
<li><p>进程适应于多核、多机分布，线程适用于多核</p>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>在一个进程的基本状态，即创建状态、运行状态、就绪状态、阻塞状态、挂起状态、结束状态</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B/01.png" class="">

<ul>
<li><p>创建状态：进程正在被创建时的状态</p>
</li>
<li><p>运行状态：该时刻进程占用 CPU</p>
</li>
<li><p>就绪状态：可运行，但因为其他进程正在运行而暂停停止</p>
</li>
<li><p>阻塞状态：该进程正在等待某一事件发生而暂时停止运行，即使给它 CPU 控制权，它也无法运行</p>
</li>
<li><p>结束状态：进程正在从系统中消失时的状态</p>
</li>
</ul>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B/02.png" class="">

<p>挂起状态表示进程没有占有物理内存空间（由于虚拟内存管理原因，进程所使用的空间可能并没有映射到物理内存，而是在硬盘上）</p>
<ul>
<li><p>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现</p>
</li>
<li><p>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行</p>
</li>
</ul>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B/03.png" class="">

<h2 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h2><p>在操作系统中，是用进程控制块（process control block，PCB）数据结构来描述进程，PCB 是进程存在的唯一标识</p>
<p>一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失</p>
<h3 id="PCB-结构体"><a href="#PCB-结构体" class="headerlink" title="PCB 结构体"></a>PCB 结构体</h3><h4 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h4><ul>
<li><p>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符</p>
</li>
<li><p>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务</p>
</li>
</ul>
<h4 id="进程控制和管理信息"><a href="#进程控制和管理信息" class="headerlink" title="进程控制和管理信息"></a>进程控制和管理信息</h4><ul>
<li><p>进程当前状态，如 new、ready、running、waiting 或 blocked 等</p>
</li>
<li><p>进程优先级：进程抢占 CPU 时的优先级</p>
</li>
</ul>
<h4 id="资源分配清单"><a href="#资源分配清单" class="headerlink" title="资源分配清单"></a>资源分配清单</h4><ul>
<li><p>内存信息</p>
</li>
<li><p>进程打开所有文件的文件描述符表</p>
</li>
<li><p>进程的信号处理函数</p>
</li>
<li><p>I&#x2F;O 设备</p>
</li>
</ul>
<h4 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h4><ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行</li>
</ul>
<h3 id="PCB-组织方式"><a href="#PCB-组织方式" class="headerlink" title="PCB 组织方式"></a>PCB 组织方式</h3><p>通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列</p>
<ul>
<li><p>将所有处于就绪状态的进程链在一起，称为就绪队列</p>
</li>
<li><p>把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列</p>
</li>
<li><p>对于运行队列，在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序</p>
</li>
</ul>
<p>因为面临进程创建，销毁等调度导致进程状态发生变化，所以使用链表，以便能够更加灵活的插入和删除</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程，终止父进程时同时也会终止其所有的子进程</p>
<ol>
<li><p>为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败</p>
</li>
<li><p>为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源</p>
</li>
<li><p>初始化 PCB</p>
</li>
<li><p>如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行</p>
</li>
</ol>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 kill 掉）</p>
<ol>
<li><p>查找需要终止的进程的 PCB</p>
</li>
<li><p>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程</p>
</li>
<li><p>如果其还有子进程，则应将其所有子进程终止</p>
</li>
<li><p>将该进程所拥有的全部资源都归还给父进程或操作系统</p>
</li>
<li><p>将其从 PCB 所在队列中删除</p>
</li>
</ol>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待；一旦被阻塞等待，它只能由另一个进程唤醒</p>
<ol>
<li><p>找到将要被阻塞进程标识号对应的 PCB</p>
</li>
<li><p>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行</p>
</li>
<li><p>将该 PCB 插入的阻塞队列中去</p>
</li>
</ol>
<h3 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h3><p>只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它</p>
<ol>
<li><p>在该事件的阻塞队列中找到相应进程的 PCB</p>
</li>
<li><p>将其从阻塞队列中移出，并置其状态为就绪状态</p>
</li>
<li><p>把该 PCB 插入到就绪队列中，等待调度程序调度</p>
</li>
</ol>
<h2 id="多进程管理"><a href="#多进程管理" class="headerlink" title="多进程管理"></a>多进程管理</h2><h3 id="多进程并行"><a href="#多进程并行" class="headerlink" title="多进程并行"></a>多进程并行</h3><p>对于一个单核 CPU 来讲，从宏观上是并行的，而从微观上是串行的，它使用时间片划分周期调用来实现；每个任务在一段时间内会分到一段时间片(占 cpu 的时间)，在这段时间内该任务只能运行时间片长度从而达到同时的效果</p>
<h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><p>Linux 中的进程都是由其它进程启动</p>
<p>Linux 启动时，0 进程启动 1 号进程 (init) 和 2 号进程(内核线程)，0 号进程退出，其它进程是由 1、2 直接或间接产生</p>
<ul>
<li><p>1号进程 (init) 是所有用户进程的祖先</p>
</li>
<li><p>2号进程(内核线程)是内核进程的祖先</p>
</li>
</ul>
<h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><ul>
<li><p>正常退出：<code>main()</code> 中 <code>return</code> 进程的所有线程结束；<code>exit()</code> 代表整个进程的结束，是库函数；<code>_exit()</code> 或者 <code>_Exit()</code> 是系统调用函数；<code>exit()</code> 通过调用 <code>_exit()</code> 来实现退出的，但 <code>exit()</code> 多干了两件事情: 清空缓冲区、调用退出处理函数；退出处理函数可以做一些清理工作，需要先登记才生效，退出处理函数保存在退出处理函数栈中(先进后出的原则)</p>
</li>
<li><p>异常退出：被信号打断（ctrl + c、段错误、kill -9）；主线程被取消</p>
</li>
</ul>
<h3 id="资源回收"><a href="#资源回收" class="headerlink" title="资源回收"></a>资源回收</h3><p>子进程退出时, 不管是正常还是异常, 父进程会收到信号；子进程退出后，内核会释放掉该进程资源（打开的文件、占用的内存等），但仍会保留一部分信息由父进程负责回收（进程号、退出状态、<br>运行时间），系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程</p>
<ul>
<li><p>僵尸进程：子进程先结束，会通知父进程(通过信号)，让父进程回收资源，如果父进程不处理信号，子进程则变成僵尸进程；僵尸进程是一个进程必然会经过的过程，这是每个子进程在结束时都要经过的阶段</p>
</li>
<li><p>孤儿进程：父进程先结束，子进程就会变成孤儿进程，就会由 1 号进程（ init ）负责回收，但在实际编程中要避免这种情况</p>
</li>
</ul>
<p>僵尸进程是一个早已死亡的进程，但在进程表中仍占了一个位置。由于进程表的容量是有限的，所以僵尸进程不仅占用系统的内存资源，影响系统的性能，而且如果其数目太多，还会导致系统瘫痪</p>
<p>当子进程结束的时候，它并没有真正的被销毁，而是留下一个称为僵尸进程的数据结构，这些数据会一直保留到系统将它传递给它的父进程为止。此时，该僵尸子进程已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态信息供其他进程收集</p>
<p>如果父进程没有捕获 SIGCHLD 信号处理函数调用 <code>wait()</code> 或 <code>waitpid()</code> 等待子进程结束，也没有显式忽略该信号，那么它就一直保持僵尸状态。如果父进程结束时子进程仍为僵尸进程，那么 init 进程会自动接手这个子进程，将它清除掉的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态</p>
<p>僵尸进程是不能直接使用 kill -9 命令杀掉的，重启电脑或杀掉父进程可解决僵尸进程</p>
<p>预防僵尸进程措施：</p>
<ul>
<li><p>在父进程创建子进程之前，就向系统申明自己不会对这个子进程的 exit 动作进行任何关注行为，这样子进程退出后，系统不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了</p>
</li>
<li><p>在创建完子进程后，用 <code>waitpid()</code> 等待子进程返回</p>
</li>
</ul>
<h3 id="父子进程共享的文件描述符"><a href="#父子进程共享的文件描述符" class="headerlink" title="父子进程共享的文件描述符"></a>父子进程共享的文件描述符</h3><p>PCB 里有个数组专门用于记录打开的文件，数组元素为指向所打开的文件所创建的文件表项，文件表项是用于描述文件当前被某个进程打开后的状态信息，包括文件状态标志，记录当前文件读取的位移量，以及文件的 i 节点指针</p>
<p>不同进程打开同一个文件后，进程表和文件表的关系；<code>fork()</code> 之后打开文件，与不同进程打开同一文件情况相同</p>


<p><code>fork()</code> 之前打开文件，子进程是共享父进程的文件表项</p>


<p>进程调用 <code>fork()</code> 后，子进程和父进程的文件描述符所对应的文件表项是共享的，这意味着子进程对文件的读写直接影响父进程的文件位移量(反之同理)</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>自从多任务操作系统诞生以来，进程执行占用 cpu 的能力就是一个必须要可以人为控制的事情</p>
<p>进程优先级起作用的方式，无论是只有一个 cpu 的时代，还是多核 cpu 时代，都是通过控制进程占用 cpu 时间的长短来实现的</p>
<p>在同一个调度周期中，优先级高的进程占用的时间长些，而优先级低的进程占用的短些</p>
<p>cgroup 相较于优先级，更能直观的反馈出资源分配的比例，但实际上从内核目前的进程调度器 cfs 的角度看，同时实现 cpushare 方式的 cgroup 和优先级这两个机制完全是相同的概念</p>
<h3 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h3><p>nice 值是反应一个进程静态优先级状态的值，其取值范围是 -20 至 19，一共 40 个级别</p>
<p>nice 越小，表示进程优先级越高，而值越大优先级越低</p>
<p>可以通过 <code>nice</code> 命令来对一个将要执行的命令进行 <code>nice</code>值设置</p>
<p>使用 <code>renice</code> 命令可以对一个正在运行的进程进行 nice 值的调整</p>
<h3 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h3><p>priority 值表示 PRI 和 PR 值，动态优先级</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-ipc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-ipc/" class="post-title-link" itemprop="url">进程通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-28 20:42:15" itemprop="dateCreated datePublished" datetime="2023-04-28T20:42:15+08:00">2023-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，<br>所以进程之间要通信必须通过内核</p>
<p>进程间通信主要包括管道、消息队列、信号量、信号、共享内存、以及套接字 socket 等</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>主要包括匿名管道和命名管道，匿名管道用于具有亲缘关系的父子进程通信，命名管道还可允许无亲缘关系进程通信</p>
<p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据</p>
<ul>
<li><p>匿名管道：半双工的，数据只能在一个方向上流动，具有固定的读端和写端；只能用于具有亲缘关系的进程之间的通信（父子进程或者兄弟进程之间）；可以看成是一种特殊的文件，对于它的读写也可以使用普通的 <code>read</code>、<code>write</code> 等函数，但不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；缓冲区是有限，所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式</p>
</li>
<li><p>命名管道：可以在无关的进程之间交换数据；有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中；</p>
</li>
</ul>
<p>命名管道严格遵循先进先出</p>
<p>管道的效率低，不适合进程间频繁地交换数据</p>
<h3 id="匿名管道创建"><a href="#匿名管道创建" class="headerlink" title="匿名管道创建"></a>匿名管道创建</h3><p>通过系统调用 <code>int pipe(int fd[2])</code> 创建匿名管道， 并返回了两个描述符，一个是管道的读取端描述符 fd[0]，另一个是管道的写入端描述符 fd[1]</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-ipc/01.png" class="">

<p>使用 <code>fork</code> 创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有两个 <code>fd[0]</code> 与 <code>fd[1]</code>，两个进程就可以通过各自的 <code>fd</code> 写入和读取同一个管道文件实现跨<br>进程通信了</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-ipc/02.png" class="">

<p>如果需要双向通信，则应该创建两个管道</p>
<h3 id="命名管道创建"><a href="#命名管道创建" class="headerlink" title="命名管道创建"></a>命名管道创建</h3><p>通过系统调用 <code>int mkfifo(const char * filename, mode_t mode)</code>，创建成功则返回 0，否则返回 -1，使用 <code>open()</code> 打开命名管道</p>
<p>当前进程以写方式（且设置了阻塞标识）打开命名管道时，如果已有别的进程以读打开该命名管道时，则当前的打开操作成功返回，否则一直阻塞直到有进程为读打开该命名管道</p>
<p>当前进程以读方式（且设置了阻塞标识）打开命名管道时，如果已有别的进程为写打开该命名管道时，则当前的打开操作成功返回，否则一直阻塞直到有进程为写打开该管道</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间；让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，解决了由用户态向内核态拷贝所消耗的时间；需要依靠某种进程同步操作，如互斥锁和信号量等</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-ipc/03.png" class="">

<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列存放在内核中，具有写权限的进程可以按照一定得规则向消息队列中添加新信息，有读权限的进程则可以从消息队列中读取信息；消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取；消息队列存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除；消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</p>
<p>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-ipc/04.png" class="">

<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>特性由 3 个属性确定，它们分别是：域、端口号、协议类型；域指定套接字通信中使用的网络介质（网络或 UNIX 文件系统）</p>
<p>同一主机不同进程使用 socket 通信时，可以使用 UNIX Domain Socket，其优势：</p>
<ul>
<li><p>传输不需要经过网络协议栈，不需要打包拆包等操作，只是数据的拷贝过程</p>
</li>
<li><p>分为 SOCK_STREAM 和 SOCK_DGRAM，由于是在本机通过内核通信，不会丢包也不会出现发送包的次序和接收包的次序不一致的问题</p>
</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是是一个计数器，可以用来控制多个进程对共享资源的访问，用于实现进程间的互斥与同步，<br>而不是用于存储进程间通信数据</p>
<p>若要在进程间传递数据需要结合共享内存</p>
<p>程序对信号量的操作都是原子操作</p>
<p>通过对信号量进行 PV 操作，获取共享资源；P 操作将信号量减一，若减一后大于等于 0，则继续执行，否者进入等待队列；S 操作将信号量加一，若加一后大于 0，则继续执行，否则释放等待队列中第一个进程</p>
<p>互斥信号量的初值一般为 1，P、V 操作必须成对出现，先做 P 操作，进临界区，后做 V 操作，出临界区</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E5%8D%8F%E7%A8%8B/" class="post-title-link" itemprop="url">协程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-28 20:41:25" itemprop="dateCreated datePublished" datetime="2023-04-28T20:41:25+08:00">2023-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么需要协程"><a href="#为什么需要协程" class="headerlink" title="为什么需要协程"></a>为什么需要协程</h2><p>移动互联网时代的到来，服务端对高并发的要求越来越高，也就是需要高性能的网络服务器</p>
<p>C10K 需要单机同时支持 1 万个并发连接，C10M 单机要支持 1 千万并发连接</p>
<p>如果要满足单机 1 千万的并发连接，有几种方案选择：</p>
<ol>
<li><p>多线程同步模型：预先创建出很多个处理线程，每个线程采用同步阻塞 IO 的方式串行处理请求，由操作系统通过线程切换来实现并发处理。这种方式编码简单，但由于线程堆栈占用空间大，内存消耗太快，同时线程切换代价高，导致系统整体性能较差</p>
</li>
<li><p>基于事件驱动的异步网络模型：由应用框架来实现事件驱动和状态切换，该方案可以充分利用 CPU，性能较高，但因为逻辑处理都是基于回调，逻辑代码过于分散，导致代码开发效率不高，代码逻辑不易懂也容易出错</p>
</li>
</ol>
<p>协程能够让开发人员很便捷地去开发业务逻辑代码，同时能够达到异步回调模型的性能</p>
<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程是一类程序组件，它是对子过程概念的泛化，并且是属于非抢占的多任务处理</p>
<ul>
<li><p>泛化的子过程是说协程是泛化的函数，可以暂停和恢复执行</p>
</li>
<li><p>非抢占的多任务处理说明协程是协作式多任务处理，需主动让出 CPU</p>
</li>
</ul>
<p>协程就是一个函数，只是它支持多次的暂停和恢复执行，需要自己手动维护调用栈和其他的一些信息</p>
<p>协作式多任务处理，协程主动让出 CPU，天然就支持协作式多任务</p>
<p>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  <span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 x y z</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">co_yield_ct</span>();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">co_yield_ct</span>();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切出操作是由 co_yield_ct() 函数实现</span></span><br><span class="line"><span class="comment">// 启动和恢复是由 co_resume() 实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  ...  <span class="comment">// 主协程</span></span><br><span class="line">  <span class="built_in">co_resume</span>(A);  <span class="comment">// 启动协程 A</span></span><br><span class="line">  <span class="built_in">co_resume</span>(B);  <span class="comment">// 启动协程 B</span></span><br><span class="line">  <span class="built_in">co_resume</span>(A);  <span class="comment">// 从协程 A 切出处继续执行</span></span><br><span class="line">  <span class="built_in">co_resume</span>(B);  <span class="comment">// 从协程 B 切出处继续执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 x 3 y z</span></span><br></pre></td></tr></table></figure>

<h2 id="协程特点"><a href="#协程特点" class="headerlink" title="协程特点"></a>协程特点</h2><ul>
<li><p>协程可以主动让出 CPU 时间片，不是当前线程让出 CPU 时间片，而是线程内的某个协程让出时间片供同线程内其他协程运行</p>
</li>
<li><p>协程可以恢复 CPU 上下文，当另一个协程继续执行时，需要恢复 CPU 上下文环境</p>
</li>
<li><p>协程有个管理者，管理者可以选择一个协程来运行，其他协程要么阻塞，要么 ready，或者 died</p>
</li>
<li><p>运行中的协程将占有当前线程的所有计算资源</p>
</li>
<li><p>协程天生有栈属性，而且是 lock free</p>
</li>
</ul>
<h2 id="保存上下文"><a href="#保存上下文" class="headerlink" title="保存上下文"></a>保存上下文</h2><p>上下文其实本质上就是寄存器，所以保存上下文实际上就是把寄存器的值保存下来</p>
<ul>
<li><p><code>setjmp</code> 和 <code>longjmp</code></p>
</li>
<li><p>汇编</p>
</li>
<li><p>第三方库，如 ucontext、Boost.Context</p>
</li>
</ul>
<h2 id="协程类别"><a href="#协程类别" class="headerlink" title="协程类别"></a>协程类别</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>这里的栈指的是是否存在调用栈 callback stack</p>
<ul>
<li><p>stackful 有栈协程：实现类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核，例如 goroutine、libco</p>
</li>
<li><p>stackless 无栈协程：上下文都会放到公共内存中，在协程切换时使用状态机来切换，而不用切换对应的上下文，因此相比有栈协程要轻量许多，例如：C++20、Rust、JavaScript</p>
</li>
</ul>
<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><p>根据调度方式的不同，协程可以分为对称协程和非对称协程</p>
<ul>
<li><p>非对称协程：协程之间有明显的调用关系。协程让出执行权的目标只能是它的调用者，即协程之间存在调用和被调用关系，比如 A 协程调用了 B 协程后，B 协程当需要让出执行权时一定是将执行权给了 A 协程</p>
</li>
<li><p>对称协程：协程之间无明显的调用关系。任何一个协程都是相互独立且平等的，执行权可以在任意协程之间转移，比如 A 协程调用了 B 协程后，A 协程与 B 协程之后就没有任何关系了，B 协程让出执行权时，该执行权最终花落谁家都有可能</p>
</li>
</ul>
<p>协程 A 调用了协程 B：如果只有 B 完成之后才能切回 A，那么此时 AB 是非对称协程；如果 AB 被调用的概率相同，那么此时 AB 是对称协程</p>
<h3 id="线程关系"><a href="#线程关系" class="headerlink" title="线程关系"></a>线程关系</h3><p>和线程绑定的协程只有在对应线程运行的时候才有被执行的可能，如果对应线程中的某一个协程完全占有了当前线程，那么当前线程中的其他所有协程都不会被执行</p>
<ul>
<li><p>N:1：所有的协程运行于一个系统线程中。由于不跨线程，协程之间的切换不需要系统调用，从而切换可以非常快，受 cache 一致性的影响也小。但代价是协程无法高效地利用多核，代码必须非阻塞，否则所有的协程都被卡住</p>
</li>
<li><p>N:M：N 个协程会映射至 M 个线程</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">上下文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-28 20:38:16" itemprop="dateCreated datePublished" datetime="2023-04-28T20:38:16+08:00">2023-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CPU-上下文"><a href="#CPU-上下文" class="headerlink" title="CPU 上下文"></a>CPU 上下文</h2><p>在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器</p>
<p>CPU 寄存器和程序计数器是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文</p>
<p>CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务</p>
<p>系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行</p>
<p>CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换</p>
<h2 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h2><p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态</p>
<p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源</p>
<p>系统会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行</p>
<p>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</p>
<p>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行</p>
<ul>
<li><p>当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</p>
</li>
<li><p>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行</p>
</li>
<li><p>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度</p>
</li>
<li><p>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</p>
</li>
<li><p>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序</p>
</li>
</ul>
<h2 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h2><p>线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源</p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的</p>
<img src="/2023/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E4%B8%8A%E4%B8%8B%E6%96%87/01.png" class="">

<p>线程上下文切换分为同一进程线程切换和不同进程线程切换：</p>
<ul>
<li><p>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样</p>
</li>
<li><p>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</p>
</li>
</ul>
<h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行</p>
<p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源</p>
<p>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81/" class="post-title-link" itemprop="url">内核态</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-26 21:31:07" itemprop="dateCreated datePublished" datetime="2023-04-26T21:31:07+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间</p>
<p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的系统资源，并且在 cpu 的一些指令如果用错，将会导致整个系统崩溃</p>
<p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同</p>
<p>运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程</p>
<p>内核态和用户态之间的转换方式主要包括：系统调用，异常和中断</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>用户进程通过系统调用申请操作系统提供的服务程序完成工作</p>
<p>CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务</p>
<p>系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</p>
<p>所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换</p>
<p>需要注意的是，系统调用过程中并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟通常所说的进程上下文切换是不一样的。进程上下文切换，是指从一个进程切换到另一个进程运行，而系统调用过程中一直是同一个进程在运行</p>
<p>进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来。而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</p>
<p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，就会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>当外围设备完成用户请求的操作之后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">虚拟内存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-26 21:30:08" itemprop="dateCreated datePublished" datetime="2023-04-26T21:30:08+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，以及让程序获得更多可用内存，操作系统采用了虚拟内存技术</p>
<p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上</p>
<p>进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元 MMU 的映射关系，来转换变成物理地址，然后再通过物理地址访问内存</p>
<img src="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/01.png" class="">

<p>在每个进程创建加载时，内核只是为进程创建了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射，等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。进程运行过程中，要动态分配内存，比如 <code>malloc</code> 也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常</p>
<p>优点：</p>
<ul>
<li><p>扩大地址空间</p>
</li>
<li><p>内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方；对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改</p>
</li>
<li><p>公平内存分配</p>
</li>
<li><p>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>虚拟地址到物理地址的转换，增加了指令的执行时间</p>
</li>
<li><p>页面的换入换出需要磁盘 IO，非常耗时</p>
</li>
</ul>
<h2 id="虚拟内存大小"><a href="#虚拟内存大小" class="headerlink" title="虚拟内存大小"></a>虚拟内存大小</h2><p>操作系统分配虚拟地址空间时，这个虚拟内存的大小是取决于系统支持的虚拟地址范围，而不是物理内存的大小</p>
<p>这种机制使得进程可以感觉到它拥有大量的内存，而不必考虑实际物理内存的大小。操作系统会根据需要将虚拟内存映射到物理内存或者其他存储设备上，以实现数据的读写和访问</p>
<h2 id="程序分段"><a href="#程序分段" class="headerlink" title="程序分段"></a>程序分段</h2><p>程序是由若干个逻辑分段组成的，如可由代码段、数据段、栈段、堆段组成，不同的段是有不同的属性的，所以就用分段的形式把这些段分离出来</p>
<p>进程空间中以段为单位进行内存分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p>
<p>编译程序时会把段名转化为相应的段号，在执行的时候 cpu 是根据段号和段内偏移量去寻找地址的</p>
<p>为了保证程序能正常运行，必须从物理内存中找到各个逻辑段的存放位置，为此需要为每个进程建立一张段映射表，简称段表</p>
<img src="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/02.jpg" class="">

<p>段表里面保存的是这个段的基地址、段的界限和特权等级等，段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址</p>
<img src="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/03.jpg" class="">

<p>程序分段会存在内存碎片和内存交换效率低的问题</p>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈</p>
<p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页</p>
<h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>分页是把整个虚拟和内存物理内存空间切成一段段固定尺寸的大小，在 Linux 下，每一页的大小为 4KB</p>
<img src="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/04.png" class="">

<p>页表实际上存储在 CPU 的内存管理单元 MMU 中，于是 CPU 可以直接通过 MMU 找出要实际要访问的物理内存地址</p>
<p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行</p>
<p>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，也就是暂时写在硬盘上，称为换出 swap out。一旦需要的时候，再加载进来，称为换入 swap in。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高</p>
<p>分页的方式使得在加载程序的时候，不再需要一次性都把程序加载到物理内存中。完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去</p>
<p>在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址</p>
<p>一个进程对应一张页表</p>
<img src="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/05.png" class="">

<p>内存地址转换步骤：</p>
<ul>
<li><p>把虚拟内存地址，切分成页号和偏移量</p>
</li>
<li><p>根据页号，从页表里面，查询对应的物理页号</p>
</li>
<li><p>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址</p>
</li>
</ul>
<img src="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/06.png" class="">

<p>单级分页会导致页表占用内存过大，后采用多级页表，64 位系统需要四级页表</p>
<p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销</p>
<p>CPU 中加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB，通常称为页表缓存、转址旁路缓存、快表等</p>
<p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</p>
<h2 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h2><p>内存分段和内存分页组合起来后，通常称为段页式内存管理</p>
<p>段页式内存管理实现的方式：</p>
<ul>
<li><p>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制</p>
</li>
<li><p>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页</p>
</li>
</ul>
<p>地址结构就由段号、段内页号和页内位移三部分组成</p>
<p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号</p>
<img src="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/07.jpg" class="">

<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>
<ul>
<li><p>第一次访问段表，得到页表起始地址</p>
</li>
<li><p>第二次访问页表，得到物理页号</p>
</li>
<li><p>第三次将物理页号与页内位移组合，得到物理地址</p>
</li>
</ul>
<h2 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h2><p>如果页太小，就会产生大量的页表条目，降低了查询速度的同时还浪费了存放页面的主存空间</p>
<p>如果页太大，又会容易造成浪费</p>
<p>在某些对性能要求非常苛刻的场景中，页面会被设置得非常的大，这些页被称之为大页 Huge Page，可以减少页表条目，加快检索速度，提升 TLB 快表的命中率</p>
<p>使用大页的同时一般会禁止页面交换，大容量交换会让磁盘读写成为 CPU 处理的瓶颈</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B-%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-26 21:29:13" itemprop="dateCreated datePublished" datetime="2023-04-26T21:29:13+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>并发（concurrent）指宏观上看起来两个程序在同时运行，比如说在单核 cpu 上的多任务。从微观上看多个程序的指令是交织着在一个 CPU 核心上运行，在单个周期内只运行了一个指令。这种机制并不能提高计算机的性能，只能提高效率</p>
<p>并行（parrallel）指严格物理意义上的同时运行，比如多核 cpu 下两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。并行可以提高计算机的效率</p>
<h2 id="互斥与同步"><a href="#互斥与同步" class="headerlink" title="互斥与同步"></a>互斥与同步</h2><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性；互斥无法限制访问者对资源的访问顺序，即访问是无序的</p>
<p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问</p>
<h2 id="多核、多进程、多线程"><a href="#多核、多进程、多线程" class="headerlink" title="多核、多进程、多线程"></a>多核、多进程、多线程</h2><ul>
<li><p>计算机的 cpu 核数是同时可以并行的线程数量（cpu 只能看到线程，线程是 cpu 调度分配的最小单位）</p>
</li>
<li><p>如果计算机有多个 cpu 核，且计算机中的总的线程数量小于核数，那线程就可以并行运行在不同的核中</p>
</li>
<li><p>如果是单核多线程，那多线程之间就不是并行而是并发，为了均衡负载，cpu 调度器会不断的在单核上切换不同的线程执行</p>
</li>
<li><p>如果是多核多线程且线程数量大于核数，其中有些线程就会不断切换，并发执行，但实际上最大的并行数量还是当前这个进程中的核的数量，所以盲目增加线程数不仅不会让你的程序更快，反而会给你的程序增加额外的开销</p>
</li>
<li><p>对计算密集型任务，使用核心数个线程就可以占满 cpu 资源，进而可以充分利用 cpu，如果再多线程就会造成额外的开销</p>
</li>
<li><p>对于 IO 密集型任务，线程由于被 IO 阻塞，如果仍然用核心数个线程，cpu 是跑不满的，于是可以使用更多个线程来提高 cpu 使用率</p>
</li>
</ul>
<h2 id="单核机器的多线程需要加锁"><a href="#单核机器的多线程需要加锁" class="headerlink" title="单核机器的多线程需要加锁"></a>单核机器的多线程需要加锁</h2><p>线程锁通常用来实现线程的同步和通信，单核机器上的多线程程序，仍然存在线程同步的问题；在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaxxro.github.io/2023/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chaxxro">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="也无风雨也无晴">
      <meta itemprop="description" content="好记性不如烂键盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 也无风雨也无晴">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/" class="post-title-link" itemprop="url">socket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-26 21:23:51" itemprop="dateCreated datePublished" datetime="2023-04-26T21:23:51+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-22 22:18:02" itemprop="dateModified" datetime="2024-01-22T22:18:02+08:00">2024-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Unix&#x2F;Linux 基本哲学之一就是一切皆文件，都可以用 open –&gt; write&#x2F;read –&gt; close 模式来操作</p>
<p>socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（读&#x2F;写 IO、打开、关闭）</p>
<h2 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h2><p>套接字描述符是一个整数，最熟悉的句柄是 0、1、2 三个，0 是标准输入，1 是标准输出，2 是标准错误输出，分别对应 <code>FILE*</code> 结构 <code>stdin</code>、<code>stdout</code>、<code>stderr</code></p>
<p>当应用程序要创建一个套接字时，操作系统就返回一个小整数作为描述符来标识这个套接字，应用程序则使用这个描述符作为传递参数，通过调用函数来完成操作</p>
<p>应用程序只需记住这个描述符，并在以后操作该文件时使用它</p>
<p>系统为每个运行的进程维护一张单独的文件描述符表，当进程打开一个文件时，系统把一个指向此文件内部数据结构的指针写入文件描述符表，并把该表的索引值返回给调用者</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li>tcp</li>
</ul>
<img src="/2023/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/01.png" class="">

<ul>
<li>udp</li>
</ul>
<img src="/2023/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/02.png" class="">

<h2 id="socket-异常"><a href="#socket-异常" class="headerlink" title="socket 异常"></a>socket 异常</h2><p>TCP 连接建立之后，能感知 TCP 链路的方式是有限的，一种是以 <code>read</code> 为核心的读操作，另一种是以 <code>write</code> 为核心的写操作</p>
<img src="/2023/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/03.png" class="">

<h3 id="客户端连接服务器未监听端口"><a href="#客户端连接服务器未监听端口" class="headerlink" title="客户端连接服务器未监听端口"></a>客户端连接服务器未监听端口</h3><p>服务端会对收到的 SYN 回应一个 RST，客户端收到 RST 之后，终止连接并进入 CLOSED 状态，返回 <code>ECONNREFUSED</code></p>
<h3 id="服务器不可达"><a href="#服务器不可达" class="headerlink" title="服务器不可达"></a>服务器不可达</h3><p>服务端地址不可访问，返回 <code>EHOSTUNREACH</code></p>
<h3 id="超时连接"><a href="#超时连接" class="headerlink" title="超时连接"></a>超时连接</h3><p>客户端发送的 SYN 丢失在网络中，没有得到确认，客户端的 TCP 会超时重发 SYN，发送 7 个 SYN 后等待一个超时时间，仍然没有收到 ACK，则 <code>connect()</code> 返回超时</p>
<h3 id="服务器端-SYN-ACK-丢失"><a href="#服务器端-SYN-ACK-丢失" class="headerlink" title="服务器端 SYN-ACK 丢失"></a>服务器端 SYN-ACK 丢失</h3><p>客户端没有收到 SYN-ACK 包，类似于超时连接错误</p>
<p>服务器端由 LISTEN 进入 SYN_RECV，服务端的 TCP 会重发 SYN-ACK，直到超时，即 SYN 攻击</p>
<h3 id="客户端-ACK-丢失"><a href="#客户端-ACK-丢失" class="headerlink" title="客户端 ACK 丢失"></a>客户端 ACK 丢失</h3><p>服务器端没有收到 ACK 包，类似于 SYN 攻击</p>
<p>对于客户端来讲，由 SYN_SENT 状态进入了 ESTABLISED 状态，即连接成功，客户端可以发送数据，但实际上数据是发送不到服务端；客户端发送出去的数据得不到确认，最终，客户端产生一个复位信号并终止连接</p>
<h3 id="网络断开且互相不发送数据"><a href="#网络断开且互相不发送数据" class="headerlink" title="网络断开且互相不发送数据"></a>网络断开且互相不发送数据</h3><p>在没有 ICMP 报文的情况下，TCP 程序并不能理解感应到连接异常，双方都不知道网络已经不通，会一直保持 ESTABLISHDED 状态</p>
<p>如果程序是阻塞在 <code>read</code> 调用上，那么程序无法从异常中恢复，需要通过给 <code>read</code> 操作设置超时来解决</p>
<h3 id="网络断开但仍需发送数据"><a href="#网络断开但仍需发送数据" class="headerlink" title="网络断开但仍需发送数据"></a>网络断开但仍需发送数据</h3><p>接收一方不知道网络出问题，会一直等待数据到来</p>
<p>对于发送方发送数据，TCP 协议栈会不断尝试将发送缓冲区的数据发送出去，大概在重传 12 次、合计时间约为 9 分钟之后，协议栈会标识该连接异常</p>
<p>如果应用层 <code>write</code> 完数据后阻塞的 <code>read</code>，则 <code>read</code> 调用会返回一条 TIMEOUT 的错误信息，如果此时程序还执着地往这条连接写数据，写操作会立即失败，返回一个 SIGPIPE 信号给应用程序</p>
<p>需要引入心跳机制</p>
<h3 id="网络断开后重启"><a href="#网络断开后重启" class="headerlink" title="网络断开后重启"></a>网络断开后重启</h3><p>当重传的 TCP 分组到达重启后的系统，由于系统中没有该 TCP 分组对应的连接数据，系统会返回一个 RST，TCP 程序通过 <code>read()</code> 或 <code>write()</code> 调用可以分别对 RST 进行错误处理</p>
<p><code>read()</code> 会立即返回一个错误，错误信息为连接重置</p>
<p><code>write()</code> 会立即失败，应用程序会被返回一个 SIGPIPE 信号</p>
<h3 id="对端进程奔溃但仍接受数据"><a href="#对端进程奔溃但仍接受数据" class="headerlink" title="对端进程奔溃但仍接受数据"></a>对端进程奔溃但仍接受数据</h3><p>linux 下，按 ctrl+c 结束程序，会调用 <code>close()</code>，发送 FIN</p>
<p>接收方调用 <code>recv()</code> 返回 0</p>
<h3 id="对端进程奔溃但仍发送数据"><a href="#对端进程奔溃但仍发送数据" class="headerlink" title="对端进程奔溃但仍发送数据"></a>对端进程奔溃但仍发送数据</h3><p>对端奔溃后内核会做一些清理的事情，为这个套接字发送一个 FIN 包；根据 TCP 协议，收到对方的 FIN 包只意味着对方不会再发送任何消息， 在一个双方正常关闭的流程中，收到 FIN 包的一端将剩余数据发送给对面（通过一次或多次 <code>write</code>），然后关闭套接字；当数据到达服务器端时，内核发现这是一个指向关闭的套接字，会再次向客户端发送一个 RST 包，对于发送端而言如果此时再执行 <code>write</code> 操作，立即会返回一个 RST 错误信息</p>
<p>第一次调用 <code>send()</code> 返回成功，数据会被发送到奔溃的对端，奔溃端会回一个 RST</p>
<p>再次调用 <code>send()</code> 返回 -1，errno 设置为 32 Broken pipe，会向应用程序发送 <code>SIGPIPE</code> 信号</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/17/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/19/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chaxxro</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
